# mod: cli
# api: public
# txt: Functions to parse and check command-line arguments.

# env: EXPECTS_ARGUMENT: A constant to represent that a flag expects an argument.
declare -gx EXPECTS_ARGUMENT=${TRUE}
# env: NO_ARGUMENT: A constant to represent that a flag doesn'n expect an argument.
declare -gx NO_ARGUMENT=${FALSE}
# env: SINGLE: A constant to represent a parameter only accepts a value.
declare -gx SINGLE=${FALSE}
#env: MULTIPLE: A constant to represent a parameter accepts multiple values.
declare -gx MULTIPLE=${TRUE}

# fun: CLI.getModuleName
# api: private
# txt: Retrieves the name of the module.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the module.
# use: CLI.getModuleName;
# use: echo "Module: ${RESULT}";
function CLI.getModuleName() {
  export RESULT="CLI"
  return ${TRUE}
}

# fun: CLI.getFlagKeysVariableName
# api: private
# txt: Retrieves the name of the variable containing the flag keys.
# txt: Returns 0/TRUE always.
# use: CLI.getFlagKeysVariableName;
# use: local -n flagKeys=${RESULT};
function CLI.getFlagKeysVariableName() {
  CLI.getModuleName
  DW.getGlobalVariableName "${RESULT}" FLAG_KEYS
}

# fun: CLI.getFlagShortNamesVariableName
# api: private
# txt: Retrieves the name of the variable containing the short versions of the flag names.
# txt: Returns 0/TRUE always.
# use: CLI.getFlagShortNamesVariableName;
# use: local -n flagShortNames=${RESULT};
function CLI.getFlagShortNamesVariableName() {
  CLI.getModuleName
  DW.getGlobalVariableName "${RESULT}" FLAG_SHORT_NAMES
}

# fun: CLI.getFlagLongNamesVariableName
# api: private
# txt: Retrieves the name of the variable containing the long versions of the flag names.
# txt: Returns 0/TRUE always.
# use: CLI.getFlagLongNamesVariableName;
# use: local -n flagLongNames=${RESULT};
function CLI.getFlagLongNamesVariableName() {
  CLI.getModuleName
  DW.getGlobalVariableName "${RESULT}" FLAG_LONG_NAMES
}

# fun: CLI.getFlagDescriptionsVariableName
# api: private
# txt: Retrieves the name of the variable containing the flag descriptions.
# txt: Returns 0/TRUE always.
# use: CLI.getFlagDescriptionsVariableName;
# use: local -n flagDescriptions=${RESULT};
function CLI.getFlagDescriptionsVariableName() {
  CLI.getModuleName
  DW.getGlobalVariableName "${RESULT}" FLAG_DESCRIPTIONS
}

# fun: CLI.getMandatoryFlagsVariableName
# api: private
# txt: Retrieves the name of the variable containing the mandatory flag information.
# txt: Returns 0/TRUE always.
# use: CLI.getMandatoryFlagsVariableName;
# use: local -n mandatoryFlags=${RESULT};
function CLI.getMandatoryFlagsVariableName() {
  CLI.getModuleName
  DW.getGlobalVariableName "${RESULT}" MANDATORY_FLAGS
}

# fun: CLI.getFlagExpectingArgumentsVariableName
# api: private
# txt: Retrieves the name of the variable containing the information about whether each flag expects arguments.
# txt: Returns 0/TRUE always.
# use: CLI.getFlagExpectingArgumentsVariableName;
# use: local -n flagExpectingArguments=${RESULT};
function CLI.getFlagExpectingArgumentsVariableName() {
  CLI.getModuleName
  DW.getGlobalVariableName "${RESULT}" FLAG_EXPECTING_ARGUMENTS
}

# fun: CLI.getOptionalFlagDefaultValuesVariableName
# api: private
# txt: Retrieves the name of the variable containing the information about the default values for optional flags.
# txt: Returns 0/TRUE always.
# use: CLI.getOptionalFlagDefaultValuesVariableName;
# use: local -n optionalFlagDefaultValues=${RESULT};
function CLI.getOptionalFlagDefaultValuesVariableName() {
  CLI.getModuleName
  DW.getGlobalVariableName "${RESULT}" OPTIONAL_FLAG_DEFAULT_VALUES
}

# fun: CLI.getParameterNamesVariableName
# api: private
# txt: Retrieves the name of the variable containing the list of parameter names.
# txt: Returns 0/TRUE always.
# use: CLI.getParameterNamesVariableName;
# use: local -n parameterNames=${RESULT};
function CLI.getParameterNamesVariableName() {
  CLI.getModuleName
  DW.getGlobalVariableName "${RESULT}" PARAMETER_NAMES
}

# fun: CLI.getParameterDescriptionsVariableName
# api: private
# txt: Retrieves the name of the variable containing the parameter descriptions.
# txt: Returns 0/TRUE always.
# use: CLI.getParameterDescriptionsVariableName;
# use: local -n parameterDescriptions=${RESULT};
function CLI.getParameterDescriptionsVariableName() {
  CLI.getModuleName
  DW.getGlobalVariableName "${RESULT}" PARAMETER_DESCRIPTIONS
}

# fun: CLI.getMandatoryParametersVariableName
# api: private
# txt: Retrieves the name of the variable containing the information about whether each parameter is mandatory or not.
# txt: Returns 0/TRUE always.
# use: CLI.getMandatoryParametersVariableName;
# use: local -n mandatoryParameters=${RESULT};
function CLI.getMandatoryParametersVariableName() {
  CLI.getModuleName
  DW.getGlobalVariableName "${RESULT}" MANDATORY_PARAMETERS
}

# fun: CLI.getSingleParametersVariableName
# api: private
# txt: Retrieves the name of the variable containing the information about whether each parameter is single or not.
# txt: Returns 0/TRUE always.
# use: CLI.getSingleParametersVariableName;
# use: local -n singleParameters=${RESULT};
function CLI.getSingleParametersVariableName() {
  CLI.getModuleName
  DW.getGlobalVariableName "${RESULT}" SINGLE_PARAMETERS
}

# fun: getScriptCopyright
# api: public
# txt: Retrieves the script copyright.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the script copyright.
# use: getScriptCopyright;
# use: echo "Copyright: ${RESULT}";
function getScriptCopyright() {
  CLI.getModuleName
  DW.getGlobalString "${RESULT}" SCRIPT_COPYRIGHT

  return ${TRUE}
}

# fun: setScriptCopyright copyrightDescription
# api: public
# txt: Sets the script copyright message.
# opt: copyrightDescription: The copyright message.
# txt: Returns 0/TRUE always.
# use: setScriptCopyright "2018-today Acme Inc.";
function setScriptCopyright() {
  local _copyright="${1}"
  checkNotEmpty copyrightDescription "${_copyright}" 1

  CLI.getModuleName
  DW.setGlobalString "${RESULT}" SCRIPT_COPYRIGHT "${_copyright}"

  return ${TRUE}
}

# fun: getScriptDescription
# api: public
# txt: Retrieves the script description.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the script description.
# use: getScriptDescription; echo "description: ${RESULT}";
function getScriptDescription() {
  CLI.getModuleName
  DW.getGlobalString "${RESULT}" SCRIPT_DESCRIPTION

  return ${TRUE}
}

# fun: setScriptDescription description
# api: public
# txt: Defines the script description.
# opt: description: The description.
# txt: Returns 0/TRUE in any case.
# use: setScriptDescription "This script calculates fibonacci sequence items"
function setScriptDescription() {
  local _description="${1}"
  checkNotEmpty description "${_description}" 1

  CLI.getModuleName
  DW.setGlobalString "${RESULT}" SCRIPT_DESCRIPTION "${_description}"

  return ${TRUE}
}

# fun: getScriptLicenseSummary
# api: public
# txt: Retrieves the script license summary.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the license summary.
# use: getScriptLicenseSummary;
# use: echo "License summary: ${RESULT}";
function getScriptLicenseSummary() {
  CLI.getModuleName
  DW.getGlobalString "${RESULT}" SCRIPT_LICENSE_SUMMARY

  return ${TRUE}
}

# fun: setScriptLicenseSummary license
# api: public
# txt: Sets the script license summary.
# opt: license: The license message.
# txt: Returns 0/TRUE always.
# use: setScriptLicenseSummary "Distributed this under the GNU General Public License v3.";
function setScriptLicenseSummary() {
  local _license="${1}"
  checkNotEmpty license "${_license}" 1

  CLI.getModuleName
  DW.setGlobalString "${RESULT}" SCRIPT_LICENSE_SUMMARY "${_license}"

  return ${TRUE}
}

# fun: getScriptUrl
# api: public
# txt: Retrieves the script URL.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the url.
# use: getScriptUrl;
# use: echo "URL: ${RESULT}";
function getScriptUrl() {
  CLI.getModuleName
  DW.getGlobalString "${RESULT}" SCRIPT_URL

  return ${TRUE}
}

# fun: setScriptUrl url
# api: public
# txt: Sets the script URL.
# opt: url: The url.
# txt: Returns 0/TRUE always.
# use: setScriptUrl "https://github.com/rydnr/dry-wit";
function setScriptUrl() {
  local _url="${1}"

  CLI.getModuleName
  DW.setGlobalString "${RESULT}" SCRIPT_URL "${_url}"

  return ${TRUE}
}

# fun: addCommandLineFlag longName shortName description MANDATORY|OPTIONAL EXPECTS_ARGUMENT|NO_ARGUMENT defaultValue?
# api: public
# txt: Adds a command-line flag.
# opt: longName: The long name of the flag.
# opt: shortName: The short name of the flag.
# opt: description: The flag description.
# opt: MANDATORY|OPTIONAL: MANDATORY if the flag is mandatory; OPTIONAL otherwise.
# opt: EXPECTS_ARGUMENT|NO_ARGUMENT: EXPECTS_ARGUMENT if the flag contains a value; NO_ARGUMENT otherwise.
# opt: defaultValue: The default value (if the flag is optional).
# txt: Returns 0/TRUE if the flag is added successfully; 1/FALSE otherwise.
# use: if addCommandLineFlag "file" "f" "The file to read" MANDATORY EXPECTS_ARGUMENT "/tmp/file.log"; then
# use:   echo "-f|--file flag added"
# use: fi
function addCommandLineFlag() {
  local _longName="${1}"
  checkNotEmpty longName "${_longName}" 1
  local _shortName="${2}"
  checkNotEmpty shortName "${_shortName}" 2
  local _description="${3}"
  checkNotEmpty description "${_description}" 3
  local _mandatory="${4}"
  CLI.checkMandatoryOrOptional "${_mandatory}" 4
  local _expectsArgument="${5}"
  CLI.checkExpectsArgumentOrNoArgument "${_expectsArgument}" 5
  local _defaultValue=""
  if isGreaterThan $# 5; then
    _defaultValue="${6}"
  fi

  local -i _rescode=${TRUE}

  if removePrefix "${_longName}" "-"; then
    _longName="${RESULT}"
  fi
  if removePrefix "${_shortName}" "-"; then
    _shortName="${RESULT}"
  fi

  CLI.buildCommandLineFlagKey "${_shortName}" "${_longName}"
  local _flagKey="${RESULT}"

  CLI.getFlagKeysVariableName
  local -n _flagKeys=${RESULT}

  local -i _index

  if isEmpty "${_flagKeys[@]}"; then
    _index=0
  elif arrayDoesNotContain "${_flagKey}" "${_flagKeys[@]}"; then
    _index=${#_flagKeys[@]}
  else
    getIndexOfItemInArray "${_flagKey}" "${_flagKeys[@]}"
    _index=${RESULT}
  fi

  _flagKeys[${_index}]="${_flagKey}"

  CLI.getFlagShortNamesVariableName
  local -n _flagShortNames=${RESULT}
  _flagShortNames[${_longName}]="${_shortName}"

  CLI.getFlagLongNamesVariableName
  local -n _flagLongNames=${RESULT}
  _flagLongNames[${_shortName}]="${_longName}"

  CLI.getFlagDescriptionsVariableName
  local -n _flagDescriptions="${RESULT}"
  _flagDescriptions[${_flagKey}]="${_description}"

  normalizeUppercase "${_longName}"
  local _longNameInUpperCase="${RESULT}"
  if areEqual "${_mandatory}" "MANDATORY"; then
    addError "${_longNameInUpperCase}_IS_MANDATORY" "${_longName} is mandatory"
  fi

  CLI.getMandatoryFlagsVariableName
  local -n _mandatoryFlags="${RESULT}"
  _mandatoryFlags[${_flagKey}]=${_mandatory}

  if areEqual "${_expectsArgument}" "EXPECTS_ARGUMENT"; then
    addError "${_longNameInUpperCase}_EXPECTS_AN_ARGUMENT" "${_longName} expects an argument"
  fi

  CLI.getFlagExpectingArgumentsVariableName
  local -n _flagExpectingArguments="${RESULT}"
  _flagExpectingArguments[${_flagKey}]="${_expectsArgument}"

  CLI.getOptionalFlagDefaultValuesVariableName
  local -n _optionalFlagDefaultValues=${RESULT}
  _optionalFlagDefaultValues[${_flagKey}]="${_defaultValue}"

  return ${_rescode}
}

# fun: addCommandLineParameter paramName paramDescription MANDATORY|OPTIONAL SINGLE|MULTIPLE
# api: public
# txt: Declares the script expects another command-line parameter.
# opt: paramName: The parameter name.
# opt: paramDescription: The parameter description.
# opt: MANDATORY|OPTIONAL: MANDATORY if the parameter is mandatory; OPTIONAL otherwise.
# opt: SINGLE|MULTIPLE: SINGLE if the parameter can not be repeated; MULTIPLE otherwise.
# txt: Returns 0/TRUE always.
# use: addCommandLineParameter "project" "The project to process" MANDATORY SINGLE;
function addCommandLineParameter() {
  local _name="${1}"
  checkNotEmpty name "${_name}" 1
  local _description="${2}"
  checkNotEmpty description "${_description}" 2
  local _mandatoryOrOptional="${3}"
  checkNotEmpty mandatoryOrOptional "${_mandatoryOrOptional}" 3
  CLI.checkMandatoryOrOptional "${_mandatoryOrOptional}" 3
  local _singleOrMultiple="${4}"
  checkNotEmpty singleOrMultiple "${_singleOrMultiple}" 4
  CLI.checkSingleOrMultiple "${_singleOrMultiple}" 4

  CLI.getParameterNamesVariableName
  local -n _parameterNames="${RESULT}"

  if isEmpty "${_parameterNames[@]}" ||
    arrayDoesNotContain "${_name}" "${_parameterNames[@]}"; then

    _parameterNames[${#_parameterNames[@]}]="${_name}"

    CLI.getParameterDescriptionsVariableName
    local -n _parameterDescriptions=${RESULT}
    _parameterDescriptions["${_name}"]="${_description}"

    CLI.getMandatoryParametersVariableName
    local -n _mandatoryParameters=${RESULT}
    _mandatoryParameters["${_name}"]="${_mandatoryOrOptional}"

    CLI.getSingleParametersVariableName
    local -n _singleParameters=${RESULT}
    _singleParameters["${_name}"]="${_singleOrMultiple}"
  fi

  return ${TRUE}
}

# fun: flagEnabled flagName
# api: public
# txt: Checks whether a given flag is enabled.
# opt: flagName: the name of the flag variable.
# txt: Returns 0/TRUE if the flag is enabled, 1/FALSE otherwise.
# use: if flagEnabled MY_FLAG; then ...
function flagEnabled() {
  local _flagVar="${1}"
  checkNotEmpty flagName "${_flagVar}" 1

  local -i _rescode

  evalVar "${_flagVar}"
  local _flagVal="${RESULT}"

  if areEqual "${_flagVal}" "${TRUE}" ||
    areEqual "${_flagVal}" "TRUE" ||
    isTrue "${_flagVal}"; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: removeCommandLineFlag shortOrLongName
# api: public
# txt: Removes a command-line flag.
# opt: shortOrLongName: The flag (either short or long name).
# txt: Returns 0/TRUE if the flag is removed successfully; 1/FALSE otherwise.
# use: if removeCommandLineFlag "--file"; then
# use:   echo "--file flag removed";
# use: fi
function removeCommandLineFlag() {
  local _flag="${1}"
  checkNotEmpty shortOrLongName "${_flag}" 1

  local -i _rescode

  if CLI.retrieveCommandLineFlagKey "${_flag}"; then
    local _flagKey="${RESULT}"

    CLI.getFlagKeysVariableName
    local -n _flagKeys="${RESULT}"

    if isNotEmpty "${_flagKey}" &&
      isNotEmpty "${_flagKeys[@]}" &&
      arrayContains "${_flagKey}" "${_flagKeys[@]}"; then

      _flagKeys=("${_flagKeys[@]/${_flagKey}/}")
      CLI.retrieveCommandLineFlagLongNameFromKey "${_flagKey}"
      local _longName="${RESULT}"
      CLI.retrieveCommandLineFlagShortNameFromKey "${_flagKey}"
      local _shortName="${RESULT}"

      CLI.getFlagShortNamesVariableName
      local -n _flagShortNames="${RESULT}"
      unset _flagShortNames[${_longName}]

      CLI.getFlagLongNamesVariableName
      local -n _flagLongNames="${RESULT}"
      unset _flagLongNames[${_shortName}]

      CLI.getFlagDescriptionsVariableName
      local -n _flagDescriptions="${RESULT}"
      unset _flagDescriptions[${_flagKey}]

      CLI.getMandatoryFlagsVariableName
      local -n _mandatoryFlags="${RESULT}"
      unset _mandatoryFlags[${_flagKey}]

      CLI.getFlagExpectingArgumentsVariableName
      local -n _flagExpectingArguments="${RESULT}"
      unset _flagExpectingArguments[${_flagKey}]

      CLI.getOptionalFlagDefaultValuesVariableName
      local -n _optionalFlagDefaultValues="${RESULT}"
      unset _optionalFlagDefaultValues[${_flagKey}]
    fi
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: usage
# api: public
# txt: Prints the usage description.
# txt: Returns 0/TRUE always.
# use: usage
function usage() {
  CLI.commandLineFlagsUsage
  if ! CLI.commandLineParametersUsage; then
    echo
  fi
  CLI.scriptCopyrightUsage
  CLI.scriptLicenseSummaryUsage
  CLI.scriptUrlUsage
  if ! CLI.scriptDescriptionUsage; then
    echo
  fi
  echo "Where:"
  CLI.commandLineFlagsDetailedUsage
  CLI.commandLineParametersDetailedUsage
}

# fun: checkInput arguments
# api: private
# txt: Checks the command-line arguments.
# opt: arguments: The command-line arguments.
# txt: Returns 0/TRUE always, but it could raise an exception and exit.
# use: checkInput $@;
function checkInput() {
  local _flags=$(CLI.extractFlags $@)

  local -a _flagsChecked=()
  local -i _flagCount=0
  local _oldIFS="${IFS}"

  # Flags
  IFS="${DWIFS}"
  local _flag
  for _flag in ${_flags}; do
    IFS="${_oldIFS}"

    if isHelpFlagProvided; then
      break
    else
      _flagCount=$((_flagCount + 1))
      shift

      if areEqual "${_flag}" "--"; then
        break
      else
        CLI.checkFlag "${_flag}" $@
        local -i _shifts=$?
        IFS="${DWIFS}"
        local -i _i
        for _i in $(seq 1 1 ${_shifts} 2>/dev/null); do
          IFS="${_oldIFS}"
          shift
        done
        IFS="${_oldIFS}"
        _flagsChecked[${#_flagsChecked[@]}]="${_flag}"
      fi
    fi
  done
  IFS="${_oldIFS}"

  if ! isHelpFlagProvided; then
    CLI.checkForMissingMandatoryCommandLineFlags "${_flagsChecked[@]}"

    CLI.checkCommandLineParameters $@

    CLI.checkEnvironmentVariables

    if isFunctionPresent "dw_checkInput"; then
      dw_checkInput
    fi
  fi
}

# fun: parseInput arguments
# api: private
# txt: Parses the command-line arguments.
# opt: arguments: The command-line arguments.
# txt: Returns 0/TRUE if the command-line arguments were parsed successfully; 1/FALSE otherwise.
# use: parseInput $@;
function parseInput() {
  local _flags;
  _flags=$(CLI.extractFlags $@)
  local _oldIFS="${IFS}"
  local -a _providedFlags=()
  local -i _shifts

  IFS="${DWIFS}"
  local _flag
  for _flag in ${_flags}; do
    IFS="${_oldIFS}"
    shift
    _providedFlags[${#_providedFlags[@]}]="${_flag}"

    if areEqual "${_flag}" "--"; then
      break
    else
      CLI.parseFlag "${_flag}" "${@}"
      local -i _shifts=$?
      IFS="${DWIFS}"
      local -i _i
      for _i in $(seq 1 1 ${_shifts} 2>/dev/null); do
        IFS="${_oldIFS}"
        shift
      done
    fi
  done
  IFS="${_oldIFS}"

  CLI.parseNotProvidedFlags "${_providedFlags[@]}"

  CLI.parseCommandLineParameters ${@}
}

# fun: dw_parse_debug_cli_flag
# api: private
# txt: Callback function when the user includes the debug (-v|--debug) flag.
# txt: It's based on a naming convention: dw_parse_debug_cli_flag
function dw_parse_debug_cli_flag() {
  setDebugEnabled
}

# fun: dw_parse_trace_cli_flag
# api: private
# txt: Callback function when the user includes the trace (-vv|--trace) flag.
# txt: It's based on a naming convention: dw_parse_trace_cli_flag
function dw_parse_trace_cli_flag() {
  setTraceEnabled
}

# fun: dw_parse_quiet_cli_flag
# api: private
# txt: Callback function when the user includes the quiet (-q|--quiet) flag.
# txt: It's based on a naming convention: dw_parse_quiet_cli_flag
function dw_parse_quiet_cli_flag() {
  export QUIET=${TRUE}
}

# fun: setHelpFlagProvided
# api: private
# txt: Indicates the help flag has been specified.
# txt: Returns 0/TRUE always.
# use: setHelpFlagProvided;
function setHelpFlagProvided() {
  CLI.getModuleName
  DW.setGlobalInt "${RESULT}" HELP_FLAG_PROVIDED ${TRUE}
}

# fun: isHelpFlagProvided
# api: private
# txt: Retrieves whether the help flag has been specified.
# txt: Returns 0/TRUE in such case; 1/FALSE otherwise.
# use: if isHelpFlagProvided; then
# use:   echo "help requested";
# use: fi
function isHelpFlagProvided() {
  CLI.getModuleName
  DW.getGlobalInt "${RESULT}" HELP_FLAG_PROVIDED
  local -i _rescode=${RESULT}
  return ${_rescode}
}

# fun: dw_parse_help_cli_flag
# api: private
# txt: Callback function when the user includes the help (-h|--help) flag.
# txt: It's based on a naming convention: dw_parse_help_cli_flag
function dw_parse_help_cli_flag() {
  setHelpFlagProvided
}

# fun: CLI.extractFlags cliArguments
# api: private
# txt: Extracts the flags from the arguments.
# txt: Prints the flags to stdout.
# opt: cliArguments: The arguments to process.
# use: local _myFlags=$(CLI.extractFlags $*);
function CLI.extractFlags() {
  echo " $@" |
    awk -F" -" '{for (i=2; i<=NF; i++){printf("-%s \n", $i);}}' |
    awk -F" " '{print $1;}'
}

# fun: CLI.extractFlagValue flagName cliArguments
# api: private
# txt: Extracts the flag value for the arguments.
# txt: Prints the flag value to stdout.
# opt: flagName: the name of the flag.
# opt: cliArguments: The arguments to process.
# use: local _Ext=$(CLI.extractFlagValue "ext" $*);
function CLI.extractFlagValue() {
  local _flag=${1}
  checkNotEmpty flagName "${_flag}" 1
  shift
  checkNotEmpty cliArguments "${@}" 2

  echo " $@" |
    awk -F" -" '{printf("-"); for (i=2; i<=NF; i++){if(i%2 == 1) {printf("-");}; printf("%s \n", $i);}}' |
    grep -e "^${_flag} " |
    awk -v f="${_flag}" '{printf("echo \"%s\" | sed -e \"s_^%s __g\"\n", $2, f);}' |
    sh
}

# fun: CLI.retrieveCommandLineFlagShortNameForLongName longName
# api: private
# txt: Retrieves the short format of the flag whose long name is provided.
# opt: longName: The long name of the flag.
# txt: Returns 0/TRUE if the long name is found; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT will contain the short name of the flag.
# use: if CLI.retrieveCommandLineFlagShortNameForLongName "file"; then
# use:   echo "Short name of 'file' is ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagShortNameForLongName() {
  local _longName="${1}"
  checkNotEmpty longName "${_longName}" 1

  local -i _rescode

  CLI.getFlagShortNamesVariableName
  local -n _flagShortNames="${RESULT}"

  if CLI.commandLineFlagLongNameSupported "${_longName}"; then
    local _result="${_flagShortNames[${_longName}]}"
    if isEmpty "${_result}"; then
      _rescode=${FALSE}
    else
      _rescode=${TRUE}
      export RESULT="${_result}"
    fi
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: CLI.commandLineFlagLongNameSupported longName
# api: private
# txt: Checks whether given long name is a supported command line flag.
# opt: longName: The long name of the flag.
# txt: Returns 0/TRUE if the flag is supported; 1/FALSE otherwise.
# use: if CLI.commandLineFlagLongNameSupported profile; then
# use:   echo "--profile supported";
# use: fi
function CLI.commandLineFlagLongNameSupported() {
  local _longName
  _longName="${1}"
  checkNotEmpty longName "${_longName}" 1

  local -i _rescode

  CLI.getFlagLongNamesVariableName
  local -n _flagLongNames=${RESULT}

  if arrayContains "${_longName}" "${_flagLongNames[@]}"; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: CLI.isCommandLineFlagInLongFormat flag
# api: private
# txt: Retrieves whether given flag is in long format.
# opt: flag: the flag.
# txt: Returns 0/TRUE if the flag is in long format; 1/FALSE otherwise.
# use: if CLI.isCommandLineFlagInLongFormat "${flag}"; then
# use:   echo "Flag ${flag} is in long format";
# use: fi
function CLI.isCommandLineFlagInLongFormat() {
  local _flag="${1}"
  checkNotEmpty flag "${_flag}" 1

  local -i _rescode

  if areEqual "${_flag}" "${_flag#--}"; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
  fi

  return ${_rescode}
}

# fun: CLI.retrieveCommandLineFlagLongNameForShortName shortName
# api: private
# txt: Retrieves the short format of the flag whose long name is provided.
# opt: shortName: The short name of the flag.
# txt: Returns 0/TRUE if the short name is found; 1/FALSE otherwise.
# use: if CLI.retrieveCommandLineFlagLongNameForShortName "f"; then
# use:   echo "Long name of 'f' is ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagLongNameForShortName() {
  local _shortName="${1}"
  checkNotEmpty shortName "${_shortName}" 1

  local -i _rescode

  CLI.getFlagLongNamesVariableName
  local -n _flagLongNames=${RESULT}

  if CLI.commandLineFlagShortNameSupported "${_shortName}"; then
    local _result="${_flagLongNames[${_shortName}]}"
    if isEmpty "${_result}"; then
      _rescode=${FALSE}
    else
      _rescode=${TRUE}
      export RESULT="${_result}"
    fi
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: CLI.commandLineFlagShortNameSupported shortName
# api: private
# txt: Checks whether given short name is a supported command line flag.
# opt: shortName: The short name of the flag.
# txt: Returns 0/TRUE if the flag is supported; 1/FALSE otherwise.
# use: if CLI.commandLineFlagShortNameSupported s; then
# use:   echo "-s supported";
# use: fi
function CLI.commandLineFlagShortNameSupported() {
  local _shortName
  _shortName="${1}"
  checkNotEmpty shortName "${_shortName}" 1

  local -i _rescode

  CLI.getFlagShortNamesVariableName
  local -n _flagShortNames=${RESULT}

  if arrayContains "${_shortName}" "${_flagShortNames[@]}"; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: CLI.isCommandLineFlagInShortFormat flag
# api: private
# txt: Retrieves whether given flag is in short format.
# opt: flag: The flag.
# txt: Returns 0/TRUE if the flag is in short format; 1/FALSE otherwise.
# use: if CLI.isCommandLineFlagInShortFormat "${flag}"; then
# use:   echo "Flag ${flag} is in short format";
# use: fi
function CLI.isCommandLineFlagInShortFormat() {
  local _flag="${1}"
  checkNotEmpty flag "${_flag}" 1
  local -i _rescode

  if areEqual "${_flag}" "${_flag#-}" || CLI.isCommandLineFlagInLongFormat "${_flag}"; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
  fi

  return ${_rescode}
}

# fun: CLI.checkFlag flag
# api: private
# txt: Performs some checks on given flag.
# opt: flag: The flag to check.
# txt: It exits the script if the flag is unknown; otherwise returns the number of parameters to shift.
# use: CLI.checkFlag "-f" $@;
# use: echo "Must shift $?";
function CLI.checkFlag() {
  local _flag="${1}"
  checkNotEmpty flag "${_flag}" 1
  shift

  local -i _continue=${TRUE}
  local -i _result=0

  case ${_flag} in
    --)
      shift
      _continue=${FALSE}
      ;;
  esac

  if startsWith "${_flag}" "-DW:"; then
    _continue=${FALSE}
  fi

  if isTrue ${_continue}; then
    local _longName
    if CLI.retrieveCommandLineFlagLongName "${_flag}"; then
      _longName="${RESULT}"
    else
      _continue=${FALSE}
      #      exitWithError UNKNOWN_FLAG "Unknown flag ${_flag}";
    fi
  fi

  if isTrue ${_continue}; then
    local _shortName
    if CLI.retrieveCommandLineFlagShortName "${_flag}"; then
      _shortName="${RESULT}"
    else
      _continue=${FALSE}
      #      exitWithError UNKNOWN_FLAG "Unknown flag ${_flag}";
    fi
  fi

  if isTrue ${_continue}; then
    local _flagKey
    CLI.buildCommandLineFlagKey "${_shortName}" "${_longName}"
    _flagKey="${RESULT}"

    CLI.getFlagKeysVariableName
    local -n _flagKeys="${RESULT}"

    if arrayDoesNotContain "${_flagKey}" "${_flagKeys[@]}"; then
      _continue=${FALSE}
      #      exitWithError UNKNOWN_FLAG "Unknown flag ${_flag}";
    fi

  fi

  if isTrue ${_continue}; then
    CLI.checkCommandLineFlag "${_flagKey}" "${_longName}" $@
    _result=$((_result + $?))
  fi

  return ${_result}
}

# fun: CLI.retrieveCommandLineFlagLongName flag
# api: private
# txt: Retrieves the long name of a flag.
# opt: flag: The flag.
# txt: Returns 0/TRUE if the long name was retrieved; 1/FALSE otherwise.
# txt: If the script returns 0/TRUE, the variable RESULT will contain the long name of the flag.
# use: if CLI.retrieveCommandLineFlagLongName "-f"; then
# use:   echo "long name: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagLongName() {
  local _flag="${1}"
  checkNotEmpty flag "${_flag}" 1
  local _result
  local -i _rescode

  if CLI.isCommandLineFlagInLongFormat "${_flag}"; then
    _result="${_flag#--}"
    _rescode=${TRUE}
  elif CLI.isCommandLineFlagInShortFormat "${_flag}" &&
    CLI.retrieveCommandLineFlagLongNameForShortName "${_flag#-}"; then
    _result="${RESULT}"
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}"
  fi

  return ${_rescode}
}

# fun: CLI.retrieveCommandLineShortName flag
# api: private
# txt: Retrieves the short name of a flag.
# opt: flag: The flag.
# txt: Returns 0/TRUE if the short name was retrieved; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, then the variable RESULT contains the short name of the flag.
# use: if CLI.retrieveCommandLineShortName "--file"; then
# use:   echo "short name: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagShortName() {
  local _flag="${1}"
  checkNotEmpty flag "${_flag}" 1
  local _result
  local -i _rescode

  if CLI.isCommandLineFlagInLongFormat "${_flag}" &&
    CLI.retrieveCommandLineFlagShortNameForLongName "${_flag#--}"; then
    _result="${RESULT}"
    _rescode=${TRUE}
  elif CLI.isCommandLineFlagInShortFormat "${_flag}"; then
    _result="${_flag#-}"
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}"
  fi

  return ${_rescode}
}

# fun: CLI.checkCommandLineFlag flagKey longName
# api: private
# txt: Checks a command line flag.
# opt: flagKey: The key of the flag.
# opt: longName: The flag long name.
# txt: If the check is successful it returns the number of arguments to shift. Otherwise it exits with an error.
# use: CLI.checkCommandLineFlag "${flagKey}" "${longName}";
function CLI.checkCommandLineFlag() {
  local _flagKey="${1}"
  checkNotEmpty flagKey "${_flagKey}" 1
  local _longName="${2}"
  checkNotEmpty longName "${_longName}" 2
  shift
  shift

  local -i _functionDefined=${FALSE}
  local -i _result=${TRUE}

  CLI.buildNameOfTheCallbackFunctionToCheckFlag "${_longName}"
  local _checkCallback="${RESULT}"
  if isFunctionDefined "${_checkCallback}"; then
    _functionDefined=${TRUE}
  else
    toLower "${_checkCallback}"
    _checkCallback="${RESULT}"
    if isFunctionDefined "${_checkCallback}"; then
      _functionDefined=${TRUE}
    fi
  fi

  local -i _mandatory=${FALSE}
  if CLI.isCommandLineFlagMandatory "${_flagKey}"; then
    _mandatory=${TRUE}
  fi

  if CLI.doesCommandLineFlagExpectArgument "${_flagKey}"; then
    local _argument="${1}"
    toUpper "${_longName}"
    local _longNameInUpperCase="${RESULT}"
    if isTrue ${_mandatory} && isEmpty "${_argument}"; then
      exitWithError "${_longNameInUpperCase}_EXPECTS_AN_ARGUMENT" "${_longName} flag expects an argument"
    fi
    if isTrue ${_functionDefined}; then
      "${_checkCallback}" "${_argument}"
    fi
    _result=${FALSE}
  elif isTrue ${_functionDefined}; then
    "${_checkCallback}"
  fi

  return ${_result}
}

# fun: CLI.checkForMissingMandatoryCommandLineFlags flags
# api: private
# txt: Checks for mandatory command line flags that are declared but not provided.
# opt: flags: The flags provided.
# use: CLI.checkForMissingMandatoryCommandLineFlags "-f --file -v -vv";
function CLI.checkForMissingMandatoryCommandLineFlags() {
  local _flagsChecked="$@"

  local _oldIFS="${IFS}"

  CLI.getFlagKeysVariableName
  local -n _flagKeys="${RESULT}"

  if isNotEmpty "${_flagKeys[@]}"; then
    IFS="${DWIFS}"
    local _key
    for _key in ${_flagKeys[@]}; do
      IFS="${_oldIFS}"
      if CLI.retrieveCommandLineFlagLongNameFromKey "${_key}"; then
        local _longName="${RESULT}"
        toUpper "${_longName}"
        local _longNameInUpperCase="${RESULT}"
        if isEmpty "${_flagsChecked}" || ! CLI.isCommandLineFlagAlreadyChecked "${_flagsChecked}" "${_key}"; then
          if CLI.isCommandLineFlagMandatory "${_key}"; then
            exitWithError "${_longNameInUpperCase}_IS_MANDATORY" "${_longName} flag is mandatory"
          fi
        fi
      else
        exitWithError DRYWIT_BUG "flagKey ${_key} not found"
      fi
    done
    IFS="${_oldIFS}"
  fi
}

# fun: CLI.isCommandLineFlagAlreadyChecked alreadyCheckedFlags flagKey
# api: private
# txt: Checks whether the flag has been already checked.
# opt: alreadyCheckedFlags: The already-checked flags.
# opt: flagKey: The flag key to check.
# txt: Returns 0/TRUE if the flag has been checked; 1/FALSE otherwise.
# use: if CLI.isCommandLineFlagAlreadyChecked "-f -v -h" "${flagKey}"; then
# use:   echo "${flagKey} already checked";
# use: fi
function CLI.isCommandLineFlagAlreadyChecked() {
  local _flagsAlreadyChecked="${1}"
  checkNotEmpty alreadyCheckedFlags "${_flagsAlreadyChecked}" 1
  local _flagKey="${2}"
  checkNotEmpty flagKey "${_flagKey}" 2

  local -i _rescode

  CLI.retrieveCommandLineFlagLongNameFromKey "${_flagKey}"
  local _longName="--${RESULT}"
  CLI.retrieveCommandLineFlagShortNameFromKey "${_flagKey}"
  local _shortName="-${RESULT}"

  if arrayContains "${_longName}" "${_flagsAlreadyChecked}" ||
    arrayContains "${_shortName}" "${_flagsAlreadyChecked}"; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: CLI.checkCommandLineParameters parameter*
# api: private
# txt: Checks the command-line parameters.
# opt: parameter: The parameters provided.
# txt: If the parameter checks fail, exits; otherwise returns 0/TRUE.
# use: CLI.checkCommandLineParameters "/tmp/1.txt" "http://www.example.com";
function CLI.checkCommandLineParameters() {
  local _oldIFS="${IFS}"

  # Parameters
  CLI.getParameterNamesVariableName
  local -n _parameterNames="${RESULT}"

  IFS="${DWIFS}"
  local _parameterName
  for _parameterName in ${_parameterNames[@]}; do
    IFS="${_oldIFS}"

    local _parameterValue="${1}"
    shift

    local -i _mandatory
    if CLI.isCommandLineParameterMandatory "${_parameterName}"; then
      _mandatory=${TRUE}
    else
      _mandatory=${FALSE}
    fi

    local -i _callbackDefined
    if isFunctionDefined "dw_check_${_parameterName}_cli_parameter"; then
      _callbackDefined=${TRUE}
    else
      _callbackDefined=${FALSE}
    fi

    local -i _multiple
    if CLI.isCommandLineParameterMultiple "${_parameterName}"; then
      _multiple=${TRUE}
    else
      _multiple=${FALSE}
    fi

    local _parameterNameInUpperCase
    toUpper "${_parameterName}"
    _parameterNameInUpperCase="${RESULT}"

    if isEmpty "${_parameterValue}" && isTrue ${_mandatory}; then
      exitWithError "${_parameterNameInUpperCase}_IS_MANDATORY" "${_parameterName} is mandatory"
    fi

    if isTrue ${_callbackDefined}; then
      if isTrue ${_multiple}; then
        "dw_check_${_parameterName}_cli_parameter" "${_parameterValue}" ${@}
      else
        "dw_check_${_parameterName}_cli_parameter" "${_parameterValue}"
      fi
    else
      local -n _aux="${_parameterNameInUpperCase}"
      if isEmpty "${_aux}"; then
        declare -gx ${_parameterNameInUpperCase}="${_parameterValue}"
        export ${_parameterNameInUpperCase}
      fi
    fi
  done
  IFS="${_oldIFS}"
}

# fun: CLI.checkEnvironmentVariables
# api: private
# txt: Checks the environment variables.
# txt: If the environment variables checks fail, exits; otherwise returns 0/TRUE.
# use: CLI.checkEnvironmentVariables;
function CLI.checkEnvironmentVariables() {
  local _oldIFS="${IFS}"

  retrieveCustomEnvironmentVariables
  local _envVars="${RESULT}"

  IFS="${DWIFS}"
  local _envVarName
  for _envVarName in ${_envVars}; do
    IFS="${_oldIFS}"

    if isEnvVarMandatory "${_envVarName}"; then
      evalVar "${_envVarName}"
      local _envVarValue="${RESULT}"
      if isEmpty "${_envVarValue}"; then
        exitWithError "${_envVarName}_IS_MANDATORY" "${_envVarName} environment variable is mandatory"
      fi
    fi

    toLower "${_envVarName}"
    local _envVarNameInLowerCase="${RESULT}"

    local -i _callbackDefined
    if isFunctionDefined "dw_check_${_envVarNameInLowerCase}_cli_envvar"; then
      _callbackDefined=${TRUE}
    else
      _callbackDefined=${FALSE}
    fi
    if isTrue ${_callbackDefined}; then
      "dw_check_${_envVarNameInLowerCase}_cli_envvar" "${_envVar}"
    fi
  done
  IFS="${_oldIFS}"
}

# fun: CLI.isFlagDefined flagKey
# api: private
# txt: Checks whether given flag is defined.
# opt: flagKey: The flag key.
# txt: Returns 0/TRUE if the flag is defined; 1/FALSE otherwise.
# use: if CLI.isFlagDefined "f|file"; then
# use:   echo "f/file is defined";
# use: fi
function CLI.isFlagDefined() {
  local _flagKey="${1}"
  checkNotEmpty flagKey "${_flagKey}" 1

  CLI.getFlagKeysVariableName
  local -n _flagKeys="${RESULT}"

  arrayContains "${_flagKey}" "${_flagKeys[@]}"
  local -i _rescode=$?

  return ${_rescode}
}

# fun: CLI.buildNameOfTheCallbackFunctionToCheckFlag longName
# api: private
# txt: Builds the name of the callback function used when checking a flag.
# opt: longName: The long name of the flag.
# txt: Returns 0/TRUE always.
# txt: RESULT will contain the name of the callback function.
# use: CLI.buildNameOfTheCallbackFunctionToCheckFlag "file";
# use: echo "callback function: ${RESULT}";
function CLI.buildNameOfTheCallbackFunctionToCheckFlag() {
  local _longName="${1}"
  checkNotEmpty longName "${_longName}" 1

  export RESULT="dw_check_${_longName}_cli_flag"
}

# fun: CLI.buildNameOfTheCallbackFunctionToParseFlag longName
# api: private
# txt: Builds the name of the callback function used when parsing a flag.
# opt: longName: The long name of the flag.
# txt: Returns 0/TRUE always.
# txt: RESULT will contain the name of the callback function.
# use: CLI.buildNameOfTheCallbackFunctionToParseFlag "file";
# use: echo "callback function: ${RESULT}";
function CLI.buildNameOfTheCallbackFunctionToParseFlag() {
  local _longName="${1}"
  checkNotEmpty longName "${_longName}" 1

  export RESULT="dw_parse_${_longName}_cli_flag"
}

# fun: CLI.parseCallbackDefinedForFlag longName
# api: private
# txt: Checks whether the callback function to parse given flag (in its long-name version) exists.
# opt: longName: The long name of the flag.
# txt: Returns 0/TRUE if the callback function exists; 1/FALSE otherwise.
# txt: The variable RESULT contains the parse callback function.
# use: if CLI.parseCallbackDefinedForFlag "file"; then
# use:   echo "The callback function to parse 'file' flag exists: ${RESULT}";
# use: fi
function CLI.parseCallbackDefinedForFlag() {
  local _longName="${1}"
  checkNotEmpty longName "${_longName}" 1

  CLI.buildNameOfTheCallbackFunctionToParseFlag "${_longName}"
  local _result="${RESULT}"

  isFunctionDefined "${_result}"
  local -i _rescode=$?

  if isFalse ${_rescode}; then
    toLower "${_result}"
    local _toLower="${RESULT}"
    if isFunctionDefined "${_toLower}"; then
      _result="${_toLower}"
      _rescode=${TRUE}
    fi
  fi

  if isEmpty "${_result}"; then
    _rescode=${FALSE}
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}"
  else
    export RESULT=""
  fi

  return ${_rescode}
}

# fun: CLI.parseFlag flag remainingArguments
# api: private
# txt: Parses given flag.
# opt: flag: The flag to parse.
# opt: remainingArguments: The rest of the command-line flags and parameters.
# txt: Returns the number of parameters to shift.
# use: CLI.parseFlag "-f" $@;
# use: echo "Must shift $?";
function CLI.parseFlag() {
  local _flag="${1}"
  checkNotEmpty flag "${_flag}" 1
  shift
  local -i _result=0
  local -i _continue=${TRUE}

  case ${_flag} in
    --)
      _continue=${FALSE}
      ;;
  esac

  local _longName
  if isTrue ${_continue}; then
    if CLI.retrieveCommandLineFlagLongName "${_flag}"; then
      _longName="${RESULT}"
    else
      _continue=${FALSE}
      # exitWithError UNKNOWN_FLAG "Unknown flag ${_flag}";
    fi
  fi

  local _shortName
  if isTrue ${_continue}; then
    if CLI.retrieveCommandLineFlagShortName "${_flag}"; then
      _shortName="${RESULT}"
    else
      _continue=${FALSE}
      # exitWithError UNKNOWN_FLAG "Unknown flag ${_flag}";
    fi
  fi

  if isTrue ${_continue}; then
    CLI.buildCommandLineFlagKey "${_shortName}" "${_longName}"
    local _flagKey="${RESULT}"

    if CLI.isFlagDefined "${_flagKey}"; then
      local _argument
      if CLI.parseCallbackDefinedForFlag "${_longName}"; then
        local _callbackFunction="${RESULT}"
        if CLI.doesCommandLineFlagExpectArgument "${_flagKey}"; then
          _argument=("${@}");
          _result=$((_result + 1))
          "${_callbackFunction}" "${_argument[@]}"
        else
          "${_callbackFunction}"
        fi
      else
        if CLI.doesCommandLineFlagExpectArgument "${_flagKey}"; then
          _argument=${1}
          _result=$((_result + 1))
        fi
        if isEmpty "${_argument}"; then
          _argument=${TRUE}
        fi
        camelCaseToSnakeCase "${_longName}"
        normalizeUppercase "${RESULT}"
        local _upcasedLongName="${RESULT}"
        declare -gx ${_upcasedLongName}="${_argument}"
      fi
    else
      _continue=${FALSE}
      # exitWithError INVALID_OPTION "Unexpected flag: '${_flag}'";
    fi
  fi

  #  if isFalse ${_continue}; then
  #    _result=-1;
  #  fi

  return ${_result}
}

# fun: CLI.retrieveFlagKey flag
# api: private
# txt: Retrieves the command-line flag key from given flag representation (either long or short).
# opt: flag: The flag.
# txt: Returns 0/TRUE if the flag key was found; 1/FALSE otherwise.
#      If the function returs 0/TRUE, the variable RESULT contains the flag key.
# use: if CLI.retrieveFlagKey "-f"; then
# use:   echo "flag key: ${RESULT}";
# use: fi
function CLI.retrieveFlagKey() {
  local _flag="${1}"
  checkNotEmpty flag "${_flag}" 1

  local -i _rescode

  if CLI.retrieveCommandLineFlagLongName "${_flag}"; then
    local _longName="${RESULT}"
    if CLI.retrieveCommandLineFlagShortName "${_flag}"; then
      local _shortName="${RESULT}"
      CLI.buildCommandLineFlagKey "${_shortName}" "${_longName}"
      # implicit RESULT
      _rescode=${TRUE}
    else
      _rescode=${FALSE}
    fi
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: CLI.parseNotProvidedFlags providedFlags
# api: private
# txt: Performs the parse step for any optional flag not provided.
# opt: providedFlags: The provided flags.
# txt: Returns 0/TRUE if the process succeeds; 1/FALSE otherwise.
# use: if CLI.parseNotProvidedFlags "-f -v"; then
# use:   echo "Parsing not provided flags succeeded";
# use: fi
function CLI.parseNotProvidedFlags() {
  local -i _rescode=${TRUE}

  if isGreaterThan $# 0; then
    local _providedFlags="${@}"

    local -a _notProvidedFlags=()

    local _oldIFS="${IFS}"

    CLI.getFlagKeysVariableName
    local -n _flagKeys="${RESULT}"

    IFS="${DWIFS}"
    local _flagKey
    for _flagKey in ${_flagKeys[@]}; do
      IFS="${_oldIFS}"

      local -i _provided=${FALSE}

      CLI.retrieveCommandLineFlagLongNameFromKey "${_flagKey}"
      local _longName="${RESULT}"
      CLI.retrieveCommandLineFlagShortNameFromKey "${_flagKey}"
      _shortName="${RESULT}"
      IFS="${DWIFS}"
      for _providedFlag in ${_providedFlags}; do
        IFS="${_oldIFS}"
        if areEqual "${_providedFlag}" "--${_longName}" ||
          areEqual "${_providedFlag}" "-${_shortName}"; then
          _provided=${TRUE}
          break
        fi
      done
      IFS="${_oldIFS}"

      if isFalse ${_provided}; then
        local -i _defaultValueDefined=${FALSE}
        local _defaultValue

        if CLI.retrieveDefaultValueForOptionalFlag "${_flagKey}"; then
          _defaultValueDefined=${TRUE}
          _defaultValue="${RESULT}"
        fi

        if isTrue ${_defaultValueDefined}; then
          if CLI.parseCallbackDefinedForFlag "${_longName}"; then
            local _callbackFunction="${RESULT}"
            "${_callbackFunction}" "${_defaultValue}"
          else
            camelCaseToSnakeCase "${_longName}"
            normalizeUppercase "${RESULT}"
            local _upcasedLongName="${RESULT}"
            local -n _existingVariable=${_upcasedLongName}
            local _value="${_defaultValue}";
            if isEmpty "${_existingVariable:-}"; then
              declare -gx ${_upcasedLongName}="${_value}";
            fi
          fi
        else
          camelCaseToSnakeCase "${_longName}"
          normalizeUppercase "${RESULT}"
          local _upcasedLongName="${RESULT}"
          local -n _existingVariable=${_upcasedLongName}
          if isEmpty "${_existingVariable:-}"; then
            declare -gx ${_upcasedLongName}="";
          fi
        fi
      fi
    done
    IFS="${_oldIFS}"
  fi

  return ${_rescode}
}

# fun: CLI.retrieveDefaultValueForOptionalFlag flagKey
# api: private
# txt: Retrieves the default value for given optional flag.
# opt: flagKey: The flag key.
# txt: Returns 0/TRUE if the default value was defined; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the default value, if it's defined.
# use: if CLI.retrieveDefalutValueForOptionalFlag "f|file"; then
# use:   echo "f|file -> ${RESULT}";
# use: fi
function CLI.retrieveDefaultValueForOptionalFlag() {
  local _flagKey="${1}"
  checkNotEmpty flagKey "${_flagKey}" 1

  local -i _rescode

  CLI.getOptionalFlagDefaultValuesVariableName
  local -n _optionalFlagDefaultValues=${RESULT}

  local _result="${_optionalFlagDefaultValues[${_flagKey}]}"
  if isEmpty "${_result}"; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
    export RESULT="${_result}"
  fi

  return ${_rescode}
}

# fun: CLI.buildNameOfTheCallbackFunctionToParseParameter longName
# api: private
# txt: Builds the name of the callback function used when parsing a parameter.
# opt: longName: The long name of the parameter.
# txt: Returns 0/TRUE always.
# txt: RESULT will contain the name of the callback function.
# use: CLI.buildNameOfTheCallbackFunctionToParseParameter "file";
# use: echo "callback function: ${RESULT}";
function CLI.buildNameOfTheCallbackFunctionToParseParameter() {
  local _longName="${1}"
  checkNotEmpty longName "${_longName}" 1

  export RESULT="dw_parse_${_longName}_cli_parameter"
}

# fun: CLI.parseCallbackDefinedForParameter longName
# api: private
# txt: Checks whether the callback function to parse given parameter exists.
# opt: longName: The long name of the parameter.
# txt: Returns 0/TRUE if the callback function exists; 1/FALSE otherwise.
# txt: The variable RESULT contains the parse callback function.
# use: if CLI.parseCallbackDefinedForParameter "file"; then
# use:   echo "The callback function to parse 'file' parameter exists: ${RESULT}";
# use: fi
function CLI.parseCallbackDefinedForParameter() {
  local _longName="${1}"
  checkNotEmpty longName "${_longName}" 1

  CLI.buildNameOfTheCallbackFunctionToParseParameter "${_longName}"
  local _result="${RESULT}"
  isFunctionDefined "${_result}"
  local -i _rescode=$?

  if isFalse ${_rescode}; then
    toLower "${_result}"
    _result="${RESULT}"
    isFunctionDefined "${_result}"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}"
  else
    export RESULT=""
  fi

  return ${_rescode}
}

# fun: CLI.parseCommandLineParameters parameter*
# api: private
# txt: Parses the command-line parameters.
# opt: parameter: The CLI parameters.
# txt: Returns 0/TRUE always.
# use: CLI.parseCommandLineParameters "/tmp/1.txt" "http://www.example.com";
function CLI.parseCommandLineParameters() {
  local _oldIFS="${IFS}"

  CLI.getParameterNamesVariableName
  local -n _parameterNames="${RESULT}";

  IFS="${DWIFS}"
  local _parameterName
  for _parameterName in ${_parameterNames[@]}; do
    IFS="${_oldIFS}"

    local _parameterValue;
    local _parseCallback;
    if CLI.isCommandLineParameterMultiple "${_parameterName}"; then
      _parameterValue="${@}";
      if CLI.parseCallbackDefinedForParameter "${_parameterName}"; then
        _parseCallback="${RESULT}"
        "${_parseCallback}" ${_parameterValue}
      else
        camelCaseToSnakeCase "${_parameterName}"
        normalizeUppercase "${RESULT}"
        declare -gx "${RESULT}"="${_parameterValue}"
      fi
      break
    else
      _parameterValue="${1}"
      shift
      if CLI.parseCallbackDefinedForParameter "${_parameterName}"; then
        _parseCallback="${RESULT}"
        "${_parseCallback}" "${_parameterValue}"
      else
        camelCaseToSnakeCase "${_parameterName}"
        normalizeUppercase "${RESULT}"
        declare -gx "${RESULT}"="${_parameterValue}"
      fi
    fi
  done
  IFS="${_oldIFS}"
}

# fun: CLI.buildCommandLineFlagKey shortName longName
# api: private
# txt: Builds a key for given command-line flag.
# opt: shortName: The short name of the flag.
# opt: longName: The long name of the flag.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the key.
# use: CLI.buildCommandLineFlagKey "f" "file";
# use: echo "key: ${RESULT}";
function CLI.buildCommandLineFlagKey() {
  local _shortName="${1}"
  checkNotEmpty shortName "${_shortName}" 1
  local _longName="${2}"
  checkNotEmpty longName "${_longName}" 2

  export RESULT="${_shortName}|${_longName}"

  return ${TRUE}
}

# fun: CLI.retrieveCommandLineFlagKeyFromShortName shortName
# txt: Retrieves the key of a command-line flag from its short name.
# opt: shortName: The short name of the flag.
# txt: Returns 0/TRUE if the key was built successfully; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the key.
# use: if CLI.retrieveCommandLineFlagKeyFromShortName "f"; then
# use:   echo "key: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagKeyFromShortName() {
  local _shortName="${1}"
  checkNotEmpty shortName "${_shortName}" 1

  local -i _rescode=${TRUE}

  if removePrefix "${_shortName}" "-*"; then
    _shortName="${RESULT}"
  fi

  CLI.getFlagLongNamesVariableName
  local -n _flagLongNames="${RESULT}"

  local _longName="${_flagLongNames[${_shortName}]}"

  if isNotEmpty "${_longName}"; then
    if CLI.buildCommandLineFlagKey "${_shortName}" "${_longName}"; then
      _rescode=${TRUE}
      ## RESULT is passed directly.
    else
      _rescode=${FALSE}
      export RESULT=""
    fi
  else
    _rescode=${FALSE}
    export RESULT=""
  fi

  return ${_rescode}
}

# fun: CLI.retrieveCommandLineFlagKeyFromLongName longName
# api: private
# txt: Retrieves the key of a command-line flag from its long name.
# opt: longName: the long name of the flag.
# txt: Returns 0/TRUE if the key was built successfully; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the key.
# use: if CLI.retrieveCommandLineFlagKeyFromLongName "file"; then
# use:   echo "key: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagKeyFromLongName() {
  local _longName="${1}"
  checkNotEmpty longName "${_longName}" 1

  local -i _rescode=${TRUE}

  if removePrefix "${_longName}" "-*"; then
    _longName="${RESULT}"
  fi

  CLI.getFlagShortNamesVariableName
  local -n _flagShortNames="${RESULT}"

  local _shortName="${_flagShortNames[${_longName}]}"
  if isNotEmpty "${_shortName}"; then
    if CLI.buildCommandLineFlagKey "${_shortName}" "${_longName}"; then
      _rescode=${TRUE}
      ## RESULT is passed directly.
    else
      _rescode=${FALSE}
      export RESULT=""
    fi
  else
    _rescode=${FALSE}
    export RESULT=""
  fi

  return ${_rescode}
}

# fun: CLI.retrieveCommandLineFlagShortNameFromKey flagKey
# api: private
# txt: Retrieves the short name of given command-line flag key.
# opt: flagKey: The key.
# txt: Returns 0/TRUE if the short name was found; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the short name.
# use: if CLI.retrieveCommandLineFlagShortNameFromKey "f|file"; then
# use:   echo "short name: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagShortNameFromKey() {
  local _key="${1}"
  checkNotEmpty flagKey "${_key}" 1

  local -i _rescode

  local _result="${_key%%|*}"
  if areEqual "${_result}" "${_key}"; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
    export RESULT="${_result}"
  fi

  return ${_rescode}
}

# fun: CLI.retrieveCommandLineFlagLongNameFromKey flagKey
# api: private
# txt: Retrieves the long name of given command-line flag key.
# opt: flagKey: The flag key.
# txt: Returns 0/TRUE if the long name was found; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the long name.#
# use: if CLI.retrieveCommandLineFlagLongNameFromKey "f|file"; then
# use:   echo "long name: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagLongNameFromKey() {
  local _key="${1}"
  checkNotEmpty flagKey "${_key}" 1

  local -i _rescode

  local _result="${_key##*|}"
  if areEqual "${_result}" "${_key}"; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
    export RESULT="${_result}"
  fi

  return ${_rescode}
}

# fun: CLI.retrieveCommandLineFlagDescriptionFromKey flagKey
# api: private
# txt: Retrieves the description of given command-line flag key.
# opt: flagKey: The flag key.
# txt: Returns 0/TRUE if the description was found; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the description.
# use: if CLI.retrieveCommandLineFlagDescriptionFromKey "f|file"; then
# use:   echo "Description: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagDescriptionFromKey() {
  local _key="${1}"
  checkNotEmpty flagKey "${_key}" 1

  local -i _rescode

  CLI.getFlagDescriptionsVariableName
  local -n _flagDescriptions="${RESULT}"

  local _result="${_flagDescriptions[${_key}]}"
  if isEmpty "${_result}"; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
    export RESULT="${_result}"
  fi

  return ${_rescode}
}

# fun: CLI.retrieveCommandLineFlagKey shortOrLongName
# api: private
# txt: Retrieves the command-line flag.
# opt: shortOrLongName: The flag (either short or long version).
# txt: Returns 0/TRUE if the flag is defined; 1/FALSE otherwise.
# use: if CLI.retrieveCommandLineFlagKey "-f"; then
# use:   echo "flag key for -f: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineFlagKey() {
  local _flag="${1}"
  checkNotEmpty shortOrLongName "${_flag}" 1

  local -i _rescode

  if CLI.retrieveCommandLineFlagKeyFromShortName "${_flag}"; then
    _rescode=${TRUE}
    ## RESULT gets passed through.
  elif CLI.retrieveCommandLineFlagKeyFromLongName "${_flag}"; then
    _rescode=${TRUE}
    ## RESULT gets passed through.
  else
    _rescode=${FALSE}
    export RESULT=""
  fi

  return ${_rescode}
}

# fun: CLI.isCommandLineFlagDefined shortOrLongName
# api: private
# txt: Check whether a command-line flag is defined already or not.
# opt: shortOrLongName: The flag (either short or long version).
# txt: Returns 0/TRUE if the flag is defined; 1/FALSE otherwise.
# use: if CLI.isCommandLineFlagDefined "-f"; then
# use:   echo "-f is already defined";
# use: fi
function CLI.isCommandLineFlagDefined() {
  local _flag="${1}"
  checkNotEmpty shortOrLongName "${_flag}" 1

  local -i _rescode

  if CLI.retrieveCommandLineFlagKey "${_flag}"; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: CLI.isCommandLineFlagMandatory flagKey
# api: private
# txt: Checks whether given flag is mandatory or not.
# opt: flagKey: The flag key.
# txt: Returns 0/TRUE if the flag is mandatory; 1/FALSE otherwise.
# use: if CLI.isCommandLineFlagMandatory ${flagKey}"; then echo "${flagKey} is mandatory"; fi
function CLI.isCommandLineFlagMandatory() {
  local _flagKey="${1}"
  checkNotEmpty flagKey "${_flagKey}" 1

  local -i _rescode

  CLI.getMandatoryFlagsVariableName
  local -n _mandatoryFlags="${RESULT}"

  local _value="${_mandatoryFlags[${_flagKey}]}"

  if isEmpty "${_value}" ||
    isTrue "${_value}" ||
    areEqual "${_value}" "${MANDATORY}" ||
    areEqual "${_value}" "MANDATORY"; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: CLI.doesCommandLineFlagExpectArgument flagKey
# api: private
# txt: Checks whether given flag expects an argument.
# opt: flagKey: The flag key.
# txt: 0/TRUE if the flag expects an argument; 1/FALSE otherwise.
# use: if CLI.doesCommandLineFlagExpectArgument ${flagKey}"; then
# use:   echo "${flagKey} expects an argument";
# use: fi
function CLI.doesCommandLineFlagExpectArgument() {
  local _flagKey="${1}"
  checkNotEmpty flagKey "${_flagKey}" 1

  local -i _rescode

  CLI.getFlagExpectingArgumentsVariableName
  local -n _flagExpectingArguments="${RESULT}"

  local _value="${_flagExpectingArguments[${_flagKey}]}"

  if isEmpty "${_value}" ||
    isTrue "${_value}" ||
    areEqual "${_value}" "${EXPECTS_ARGUMENT}" ||
    areEqual "${_value}" "EXPECTS_ARGUMENT"; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: CLI.retrieveCommandLineParameterDescriptionFromName paramName
# api: private
# txt: Retrieves the description of given command-line parameter.
# opt: paramName: The name.
# txt: Returns 0/TRUE if the description was found; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the description.
# use: if CLI.retrieveCommandLineParameterDescriptionFromName "project"; then
# use:   echo "Description: ${RESULT}";
# use: fi
function CLI.retrieveCommandLineParameterDescriptionFromName() {
  local _name="${1}"
  checkNotEmpty paramName "${_name}" 1

  local -i _rescode

  CLI.getParameterDescriptionsVariableName
  local -n _parameterDescriptions="${RESULT}"

  local _result="${_parameterDescriptions[${_name}]}"
  if isEmpty "${_result}"; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
    export RESULT="${_result}"
  fi

  return ${_rescode}
}

# fun: CLI.isCommandLineParameterMandatory paramName
# api: private
# txt: Checks whether given parameter is mandatory or not.
# opt: paramName: The parameter name.
# txt: Returns 0/TRUE if the parameter is mandatory; 1/FALSE otherwise.
# use: if CLI.isCommandLineParameterMandatory "file"; then
# use:   echo "file is mandatory";
# use: fi
function CLI.isCommandLineParameterMandatory() {
  local _name="${1}"
  checkNotEmpty paramName "${_name}" 1

  local -i _rescode

  CLI.getMandatoryParametersVariableName
  local -n _mandatoryParameters="${RESULT}"

  local _value="${_mandatoryParameters[${_name}]}"

  if isEmpty "${_value}" ||
    isTrue "${_value}" ||
    areEqual "${_value}" "MANDATORY"; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: CLI.isCommandLineParameterSingle paramName
# api: private
# txt: Checks whether given parameter is single or not.
# opt: paramName: The parameter name.
# txt: Returns 0/TRUE if the parameter only expects a single value; 1/FALSE otherwise.
# use: if CLI.isCommandLineParameterSingle "file"; then
# use:   echo "file accepts only one value";
# use: fi
function CLI.isCommandLineParameterSingle() {
  local _name="${1}"
  checkNotEmpty paramName "${_name}" 1

  local -i _rescode

  CLI.getSingleParametersVariableName
  local -n _singleParameters="${RESULT}"

  local _value="${_singleParameters[${_name}]}"

  if isEmpty "${_value}" ||
    isTrue "${_value}" ||
    areEqual "${_value}" "SINGLE"; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: CLI.isCommandLineParameterMultiple paramName
# api: private
# txt: Checks whether given parameter is multiple or not.
# opt: paramName: The parameter name.
# txt: Returns 0/TRUE if the parameter allows multiple values; 1/FALSE otherwise.
# use: if CLI.isCommandLineParameterMultiple "file"; then
# use:   echo "file can accept multiple values";
# use: fi
function CLI.isCommandLineParameterMultiple() {
  local _name="${1}"
  checkNotEmpty paramName "${_name}" 1

  local -i _rescode

  if CLI.isCommandLineParameterSingle "${_name}"; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
  fi

  return ${_rescode}
}

# fun: CLI.commandLineFlagsUsage
# api: private
# txt: Prints a line describing how to run the script.
# txt: Returns 0/TRUE if this function printed anything; 1/FALSE otherwise.
# use: if CLI.commandLineFlagsUsage then ... fi
function CLI.commandLineFlagsUsage() {
  local -i _rescode=${TRUE}

  DW.getScriptName
  local _message="${RESULT}"

  local _oldIFS="${IFS}"

  CLI.getFlagKeysVariableName
  local -n _flagKeys="${RESULT}"

  IFS="${DWIFS}"
  local _flagKey
  for _flagKey in ${_flagKeys[@]}; do
    IFS="${_oldIFS}"
    CLI.retrieveCommandLineFlagShortNameFromKey "${_flagKey}"
    local _shortName="${RESULT}"
    CLI.retrieveCommandLineFlagLongNameFromKey "${_flagKey}"
    local _longName="${RESULT}"
    _message="${_message} "
    CLI.isCommandLineFlagMandatory "${_flagKey}"
    local -i _mandatory=$?
    if isFalse ${_mandatory}; then
      _message="${_message}["
    fi
    _message="${_message}-${_shortName}|--${_longName}"
    if CLI.doesCommandLineFlagExpectArgument "${_flagKey}"; then
      _message="${_message} arg"
    fi
    if isFalse ${_mandatory}; then
      _message="${_message}]"
    fi
  done
  IFS="${_oldIFS}"

  echo -n "${_message}"

  return ${_rescode}
}

# fun: CLI.scriptDescriptionUsage
# api: private
# txt: Conditionally prints (to stdout) a line with the script description.
# txt: Returns 0/TRUE if this function printed anything; 1/FALSE otherwise.
# use: if CLI.scriptDescriptionUsage then ... fi
function CLI.scriptDescriptionUsage() {
  local -i _rescode

  getScriptDescription
  local _scriptDescription="${RESULT}"

  if isEmpty "${_scriptDescription}"; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
    echo -e "\n${_scriptDescription}\n"
  fi

  return ${_rescode}
}

# fun: CLI.scriptLicenseSummaryUsage
# api: private
# txt: Conditionally prints (to stdout) a line with the license summary.
# txt: Returns 0/TRUE if this function printed anything; 1/FALSE otherwise.
# use: if CLI.scriptLicenseSummaryUsage then
# use:   ...
# use: fi
function CLI.scriptLicenseSummaryUsage() {
  local -i _rescode

  getScriptLicenseSummary
  local _scriptLicenseSummary="${RESULT}"

  if isEmpty "${_scriptLicenseSummary}"; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
    echo "${_scriptLicenseSummary}"
  fi

  return ${_rescode}
}

# fun: CLI.scriptUrlUsage
# api: private
# txt: Conditionally prints (to stdout) a line with the script URL.
# txt: Returns 0/TRUE if this function printed anything; 1/FALSE otherwise.
# use: if CLI.scriptUrlUsage then
# use:   ...
# use: fi
function CLI.scriptUrlUsage() {
  local -i _rescode

  getScriptUrl
  local _scriptUrl="${RESULT}"

  if isEmpty "${_scriptUrl}"; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
    echo "${_scriptUrl}"
  fi

  return ${_rescode}
}

# fun: CLI.scriptCopyrightUsage
# api: private
# txt: Conditionally prints (to stdout) a line with the copyright.
# txt: Returns 0/TRUE if this function printed anything; 1/FALSE otherwise.
# use: if CLI.scriptCopyrightUsage then
# use:   ...
# use: fi
function CLI.scriptCopyrightUsage() {
  local -i _rescode

  getScriptCopyright
  local _scriptCopyright="${RESULT}"

  if isEmpty "${_scriptCopyright}"; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
    echo "${_scriptCopyright}"
  fi

  return ${_rescode}
}

# fun: CLI.commandLineFlagsDetailedUsage
# api: private
# txt: Prints a line describing the details of the command-line flags.
# txt: Returns 0/TRUE if this function printed anything; 1/FALSE otherwise.
# use: if CLI.commandLineFlagsDetailedUsage then
# use:   ...
# use: fi
function CLI.commandLineFlagsDetailedUsage() {
  local -i _rescode

  local _message=""
  local _oldIFS="${IFS}"

  CLI.getFlagKeysVariableName
  local -n _flagKeys="${RESULT}"

  IFS="${DWIFS}"
  local _flagKey
  for _flagKey in ${_flagKeys[@]}; do
    IFS="${_oldIFS}"
    CLI.retrieveCommandLineFlagShortNameFromKey "${_flagKey}"
    local _shortName="${RESULT}"
    CLI.retrieveCommandLineFlagLongNameFromKey "${_flagKey}"
    local _longName="${RESULT}"
    CLI.retrieveCommandLineFlagDescriptionFromKey "${_flagKey}"
    local _description="${RESULT}"
    _message="${_message}  * -${_shortName}|--${_longName}"
    if CLI.doesCommandLineFlagExpectArgument "${_flagKey}"; then
      _message="${_message} arg"
    fi
    _message="${_message}: ${_description}."
    if CLI.isCommandLineFlagMandatory "${_flagKey}"; then
      _message="${_message} Mandatory.\n"
    else
      _message="${_message} Optional.\n"
    fi
  done
  IFS="${_oldIFS}"

  if isEmpty "${_message}"; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
    echo -n -e "${_message}"
  fi

  return ${_rescode}
}

# fun: CLI.commandLineParameterIsSingle paramName
# api: private
# txt: Checks whether given parameter is single or not.
# opt: paramName: The parameter name.
# txt: Returns 0/TRUE if the parameter is single; 1/FALSE otherwise.
# use: if CLI.commandLineParameterIsSingle ${name}"; then
# use:   echo "${name} is multiple";
# use: fi
function CLI.commandLineParameterIsSingle() {
  local _name="${1}"
  checkNotEmpty paramName "${_name}" 1

  local -i _rescode

  CLI.getSingleParametersVariableName
  local -n _singleParameters="${RESULT}"

  local _value="${_singleParameters[${_name}]}"

  if isEmpty "${_value}" ||
    isTrue "${_value}" ||
    areEqual "${_value}" "SINGLE"; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: CLI.commandLineParameterIsMultiple paramName
# api: private
# txt: Checks whether given parameter is multiple or not.
# opt: paramName: The parameter name.
# txt: Returns 0/TRUE if the parameter is multiple; 1/FALSE otherwise.
# use: if CLI.commandLineParameterIsMultiple ${name}"; then
# use:   echo "${name} is multiple";
# use: fi
function CLI.commandLineParameterIsMultiple() {
  local _name="${1}"
  checkNotEmpty paramName "${_name}" 1

  local -i _rescode

  if CLI.commandLineParameterIsSingle "${_name}"; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
  fi

  return ${_rescode}
}

# fun: CLI.commandLineParameterIsMandatory paramName
# api: private
# txt: Checks whether given parameter is mandatory or not.
# opt: paramName: The parameter name.
# txt: Returns 0/TRUE if the parameter is mandatory; 1/FALSE otherwise.
# use: if CLI.commandLineParameterIsMandatory ${name}"; then
# use:   echo "${name} is mandatory";
# use: fi
function CLI.commandLineParameterIsMandatory() {
  local _name="${1}"
  checkNotEmpty paramName "${_name}" 1

  local -i _rescode

  CLI.getMandatoryParametersVariableName
  local -n _mandatoryParameters="${RESULT}"

  local _value="${_mandatoryParameters[${_name}]}"

  if isEmpty "${_value}" ||
    isTrue "${_value}" ||
    areEqual "${_value}" "MANDATORY"; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: CLI.commandLineParametersUsage
# api: private
# txt: Prints a line describing the script's flags.
# txt: Returns 0/TRUE if this function printed anything; 1/FALSE otherwise.
# use: if CLI.commandLineParametersUsage then ... fi
function CLI.commandLineParametersUsage() {
  local -i _rescode
  local _message=""

  local _oldIFS="${IFS}"

  CLI.getParameterNamesVariableName
  local -n _parameterNames="${RESULT}"

  IFS="${DWIFS}"
  local _name
  for _name in ${_parameterNames[@]}; do
    IFS="${_oldIFS}"
    _message="${_message} ${_name}"
    if CLI.commandLineParameterIsMultiple "${_name}"; then
      if CLI.isCommandLineParameterMandatory "${_name}"; then
        _message="${_message}+"
      else
        _message="${_message}*"
      fi
    fi
  done
  IFS="${_oldIFS}"

  if isEmpty "${_message}"; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
    echo -e "${_message}"
  fi

  return ${_rescode}
}

# fun: CLI.commandLineParametersDetailedUsage
# api: private
# txt: Prints a line describing the details of the command-line parameters.
# txt: Returns 0/TRUE if this function printed anything; 1/FALSE otherwise.
# use: if CLI.commandLineParametersDetailedUsage then ... fi
function CLI.commandLineParametersDetailedUsage() {
  local -i _rescode
  local _message=""

  local _oldIFS="${IFS}"

  CLI.getParameterNamesVariableName
  local -n _parameterNames="${RESULT}"

  IFS="${DWIFS}"
  local _name
  for _name in ${_parameterNames[@]}; do
    IFS="${_oldIFS}"
    if isNotEmpty "${_message}"; then
      _message="\n"
    fi
    _message="${_message}  * ${_name}"
    if CLI.commandLineParameterIsMultiple "${_name}"; then
      _message="${_message}*"
    fi
    CLI.retrieveCommandLineParameterDescriptionFromName "${_name}"
    local _description="${RESULT}"
    _message="${_message}: ${_description}."

    if CLI.commandLineParameterIsMandatory "${_name}"; then
      _message="${_message} Mandatory."
    else
      _message="${_message} Optional."
    fi
  done
  IFS="${_oldIFS}"

  if isEmpty "${_message}"; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
    echo -e "${_message}"
  fi

  return ${_rescode}
}

# fun: printHelp
# api: public
# txt: Prints the help message.
# txt: Returns 0/TRUE always.
# use: printHelp;
function printHelp() {

  DW.getScriptName
  if isFunctionPresent defineEnv "${RESULT}"; then
    defineEnv
  fi
  usage
  printEnvironment
  printExitValues
}

# fun: printUsage
# api: public
# txt: Prints the usage message.
# txt: Returns 0/TRUE always.
# use: printUsage;
function printUsage() {
  printHelp >&2
}

# fun: CLI.checkMandatoryOrOptional paramValue paramIndex
# api: private
# txt: Performs a precondition check on given parameter to ensure it's either MANDATORY or OPTIONAL.
# opt: paramValue: The parameter value.
# opt: paramIndex: The parameter index.
# txt: Exits if the check fails; otherwise returns 0/TRUE.
# use: CLI.checkMandatoryOrOptional "${mandatoryOrOptional}" 1 # -> throws an error if the first (1) parameter ("paramValue") is neither MANDATORY or OPTIONAL.
function CLI.checkMandatoryOrOptional() {
  local _value="${1}"
  checkNotEmpty paramValue "${_value}" 1
  local _index="${2}"
  checkNotEmpty paramIndex "${_index}" 2

  CHECK.checkOneOf 1 "MANDATORY|OPTIONAL" "${_value}" "MANDATORY OPTIONAL" "${_index}"
}

# fun: CLI.checkSingleOrMultiple paramValue paramIndex
# api: private
# txt: Performs a precondition check on given parameter to ensure it's either SINGLE or MULTIPLE.
# opt: paramValue: The parameter value.
# opt: paramIndex: The parameter index.
# txt: Exits if the check fails; otherwise returns 0/TRUE.
# use: CLI.checkSingleOrMultiple "${singleOrMultiple}" 1 # -> throws an error if the first (1) parameter ("${paramValue}") is neither SINGLE or MULTIPLE.
function CLI.checkSingleOrMultiple() {
  local _value="${1}"
  checkNotEmpty paramValue "${_value}" 1
  local _index="${2}"
  checkNotEmpty paramIndex "${_index}" 2

  CHECK.checkOneOf 1 "SINGLE|MULTIPLE" "${_value}" "SINGLE MULTIPLE" "${_index}"
}

# fun: CLI.checkExpectsArgumentOrNoArgument paramValue paramIndex
# api: private
# txt: Performs a precondition check on given parameter to ensure it's either EXPECTS_ARGUMENT or NO_ARGUMENT.
# opt: paramValue: The parameter value.
# opt: paramIndex: The parameter index.
# txt: Exits if the check fails; otherwise returns 0/TRUE.
# use: CLI.checkExpectsArgumentOrNoArgument "${expectsArgumentOrNoArgument}" 1 # -> throws an error if the first (1) parameter ("${paramValue}") is neither EXPECTS_ARGUMENT or NO_ARGUMENT.
function CLI.checkExpectsArgumentOrNoArgument() {
  local _value="${1}"
  checkNotEmpty paramValue "${_value}" 1
  local _index="${2}"
  checkNotEmpty paramIndex "${_index}" 2

  CHECK.checkOneOf 1 "EXPECTS_ARGUMENT|NO_ARGUMENT" "${_value}" "EXPECTS_ARGUMENT NO_ARGUMENT" "${_index}"
}

# fun: CLI.defaultState
# api: private
# txt: Sets up the default state.
#      Returns 0/TRUE always.
# use: CLI.defaultState
function CLI.defaultState() {
  ## Built-in flags.
  addCommandLineFlag "debug" "v" "Display debug messages" OPTIONAL NO_ARGUMENT
  addCommandLineFlag "trace" "vv" "Display trace messages" OPTIONAL NO_ARGUMENT
  addCommandLineFlag "quiet" "q" "Be silent" OPTIONAL NO_ARGUMENT
  addCommandLineFlag "help" "h" "Display information about how to use the script" OPTIONAL NO_ARGUMENT
}

# fun: CLI.resetState
# api: private
# txt: Resets the module state.
# txt: Returns 0/TRUE always.
# use: CLI.resetState
function CLI.resetState() {
  CLI.getModuleName
  local _moduleName="${RESULT}"

  # env: FLAG_KEYS: The CLI flags' keys.
  DW.declareGlobalArray "${_moduleName}" FLAG_KEYS
  # env: FLAG_LONG_NAMES: The CLI flags' long names.
  DW.declareGlobalMap "${_moduleName}" FLAG_LONG_NAMES
  # env: FLAG_SHORT_NAMES: The CLI flags' short names.
  DW.declareGlobalMap "${_moduleName}" FLAG_SHORT_NAMES
  # env: MANDATORY_FLAGS: The CLI flags' mandatory information.
  DW.declareGlobalMap "${_moduleName}" MANDATORY_FLAGS
  # env: FLAG_EXPECTING_ARGUMENTS: Whether each CLI flag expects an argument or not.
  DW.declareGlobalMap "${_moduleName}" FLAG_EXPECTING_ARGUMENTS
  # env: FLAG_DESCRIPTIONS: The description of each CLI flag.
  DW.declareGlobalMap "${_moduleName}" FLAG_DESCRIPTIONS
  # env: OPTIONAL_FLAG_DEFAULT_VALUES: The default value of each CLI flag.
  DW.declareGlobalMap "${_moduleName}" OPTIONAL_FLAG_DEFAULT_VALUES
  # env: PARAMETER_NAMES: The names of the CLI parameters.
  DW.declareGlobalArray "${_moduleName}" PARAMETER_NAMES
  # env: PARAMETER_DESCRIPTIONS: The descriptions of the CLI parameters.
  DW.declareGlobalMap "${_moduleName}" PARAMETER_DESCRIPTIONS
  # env: MANDATORY_PARAMETERS: Whether each CLI parameter is mandatory or not.
  DW.declareGlobalMap "${_moduleName}" MANDATORY_PARAMETERS
  # env: SINGLE_PARAMETERS: Whether each CLI parameter is single or not.
  DW.declareGlobalMap "${_moduleName}" SINGLE_PARAMETERS

  # env: HELP_FLAG_PROVIDED: Whether the help flag was provided.
  DW.declareGlobalInt "${_moduleName}" HELP_FLAG_PROVIDED ${FALSE}

  # env: SCRIPT_DESCRIPTION: The description of the script.
  DW.declareGlobalString "${_moduleName}" SCRIPT_DESCRIPTION
  # env: SCRIPT_COPYRIGHT: The copyright of the script.
  DW.declareGlobalString "${_moduleName}" SCRIPT_COPYRIGHT
  # env: SCRIPT_LICENSE_SUMMARY: The license of the script.
  DW.declareGlobalString "${_moduleName}" SCRIPT_LICENSE_SUMMARY

  setScriptUrl ""
}
# vim: syntax=sh ts=2 sw=2 sts=4 sr noet

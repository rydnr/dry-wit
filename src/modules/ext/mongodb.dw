# mod: mongodb
# api: public
# txt: MongoDB module.

DW.import process

# fun: enableMongodbCrAuthentication
# api: public
# txt: Enables MONGODB-CR authentication.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if MONGODB-CR gets enabled successfully; 1/FALSE otherwise.
# use: if enableMongodbCrAuthentication; then
# use:   echo "MONGODB-CR enabled successfully";
# use: fi
function enableMongodbCrAuthentication() {
  local _url="${1:-mongodb://localhost}"
  local _maybeTls="${2}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi
  local _database="${3:-admin}"

  local _output
  local -i _rescode

  if isTrue ${_useTls}; then
    _output="$(mongosh --tls --eval "var schema = db.system.version.findOne({'_id' : 'authSchema'}); if (schema != undefined) { schema.currentVersion = 3; db.system.version.save(schema); } else { db.system.version.insert({'_id' : 'authSchema', 'currentVersion' : 3 }); }" "${_url}/${_database}")"
    _rescode=$?
  else
    _output="$(mongosh --eval "var schema = db.system.version.findOne({'_id' : 'authSchema'}); if (schema != undefined) { schema.currentVersion = 3; db.system.version.save(schema); } else { db.system.version.insert({'_id' : 'authSchema', 'currentVersion' : 3 }); }" "${_url}/${_database}")"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: addMongodbAdminUser user password authenticationDatabase?
# api: public
# txt: Adds an admin user.
# opt: user: The user.
# opt: password: The password.
# opt: authenticationDatabase: The authentication database. Optional. Defaults to "admin".
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the user gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR contains error information.
# use: if addMongodbAdminUser "admin" "secret"; then
# use:   echo "User admin created successfully";
# use: fi
function addMongodbAdminUser() {
  local _user="${1}"
  checkNotEmpty user "${_user}" 1
  local _password="${2}"
  checkNotEmpty password "${_password}" 2
  local _authenticationDatabase="${3:-admin}"
  local _url="${4:-mongodb://localhost}"
  local _maybeTls="${5}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  createTempFile
  local _tmpFile="${RESULT}"

  cat <<EOF >"${_tmpFile}"
use ${_authenticationDatabase}
db.createRole(
  {
    role: "superRoot",
    privileges: [
      {
        "resource": { anyResource: true }, actions: ['anyAction']
      }
    ],
    roles: [ ]
  }
)
db.createUser(
  {
    user: "${_user}",
    pwd: "${_password}",
    roles: [
      { role: "superRoot", db: "${_authenticationDatabase}" }
    ]
  }
)
EOF
  local _output
  local -i _rescode
  if isTrue ${_useTls}; then
    _output="$(cat "${_tmpFile}" | mongosh --tls "${_url}/${_authenticationDatabase}" 2>&1)"
    _rescode=$?
  else
    _output="$(cat "${_tmpFile}" | mongosh "${_url}/${_authenticationDatabase}" 2>&1)"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: addMongodbBackupRole roleName root rootPassword authenticationDatabase? authenticationMechanism?
# api: public
# txt: Adds a backup role (includes both "backup" and "restore").
# opt: roleName: The role name. It must not match any of the built-in roles.
# opt: targetDatabase: The target database.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database. Optional. Defaults to admin.
# opt: authenticationMechanism: The authentication mechanism. Optional. Defaults to SCRAM-SHA-256
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the role gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR contains error information.
# use: if addMongodbBackupRole "backupRestore" myDb root "s3cr3t"; then
# use:   echo "Role backupRestore created successfully";
# use: fi
function addMongodbBackupRole() {
  local _roleName="${1}"
  checkNotEmpty roleName "${_roleName}" 1
  local _database="${2}"
  checkNotEmpty database "${_database}" 2
  local _root="${3}"
  checkNotEmpty root "${_root}" 3
  local _rootPassword="${4}"
  checkNotEmpty rootPassword "${_rootPassword}" 4
  local _authenticationDatabase="${5:-admin}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 5
  local _authenticationMechanism="${6}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 6
  local _url="${7:-mongodb://localhost}"
  local _maybeTls="${8}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  createTempFile
  local _tmpFile="${RESULT}"

  cat <<EOF >"${_tmpFile}"
db.createRole(
  {
    role: "${_roleName}",
    privileges: [],
    roles: [
      { role: "backup", db: "${_authenticationDatabase}" },
      { role: "restore", db: "${_authenticationDatabase}" },
      { role: "dbAdminAnyDatabase", db: "${_authenticationDatabase}" }
    ]
  }
)
EOF
  cp "${_tmpFile}" /tmp/addMongodbBackupRole.txt

  local _output
  local -i _rescode

  if isTrue ${_useTls}; then
    _output="$(cat "${_tmpFile}" | mongosh --tls -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" "${_url}/${_authenticationDatabase}" 2>&1)"
    _rescode=$?
  else
    _output="$(cat "${_tmpFile}" | mongosh -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" "${_url}/${_authenticationDatabase}" 2>&1)"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: mongodbRoleAlreadyExists roleName database root rootPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Checks if giwen role already exists.
# opt: roleName: The role name.
# opt: database: The target database.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the role exists already; 1/FALSE otherwise.
# use: if mongodbRoleAlreadyExists "EventSourcingEventView" myDb root "s3cr3t" admin SCRAM-SHA-256; then
# use:   echo "Role already exists";
# use: i
function mongodbRoleAlreadyExists() {
  local _roleName="${1}"
  checkNotEmpty roleName "${_roleName}" 1
  local _database="${2}"
  checkNotEmpty database "${_database}" 2
  local _root="${3}"
  checkNotEmpty root "${_root}" 3
  local _rootPassword="${4}"
  checkNotEmpty rootPassword "${_rootPassword}" 4
  local _authenticationDatabase="${5}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 5
  local _authenticationMechanism="${6}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 6
  local _url="${7:-mongodb://localhost}"
  local _maybeTls="${8}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  createTempFile
  local _tmpFile="${RESULT}"

  cat <<EOF >"${_tmpFile}"
db.getRole("${_roleName}")
EOF

  local _output
  local -i _rescode

  cp "${_tmpFile}" /tmp/mongodbRoleAlreadyExists.txt

  if isTrue ${_useTls}; then
    _output="$(cat "${_tmpFile}" | mongosh --tls -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" --quiet "${_url}/${_database}")"
    _rescode=$?
  else
    _output="$(cat "${_tmpFile}" | mongosh -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" --quiet "${_url}/${_database}")"
    _rescode=$?
  fi

  if isEmpty "${_output}" || areEqual "${_output}" "null"; then
    _rescode=${FALSE}
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: addMongodbRole roleName root rootPassword authenticationDatabase authenticationMechanism privilegeSpec? roleSpec? url? tls?
# api: public
# txt: Adds a role.
# opt: roleName: The role name. It must not match any of the built-in roles.
# opt: targetDatabase: The target database.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: privilegeSpec: The privilege spec.
# opt: roleSpec: the role spec.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the role gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR contains error information.
# use: if addMongodbRole "EventSourcingEventView" myDb root "s3cr3t" admin SCRAM-SHA-256 "[ { db: 'core', collection: 'eventSourcingEvent'}, actions: ['find'] } ]" '[]'; then
# use:   echo "Role created successfully";
# use: i
function addMongodbRole() {
  local _roleName="${1}"
  checkNotEmpty roleName "${_roleName}" 1
  local _database="${2}"
  checkNotEmpty database "${_database}" 2
  local _root="${3}"
  checkNotEmpty root "${_root}" 3
  local _rootPassword="${4}"
  checkNotEmpty rootPassword "${_rootPassword}" 4
  local _authenticationDatabase="${5}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 5
  local _authenticationMechanism="${6}"
  checkNotEmpty authMechanism "${_authenticationMechanism}" 6
  local _privilegeSpec="${7}"
  checkNotEmpty privilegeSpec "${_privilegeSpec}" 7
  local _roleSpec="${8}"
  checkNotEmpty roleSpec "${_roleSpec}" 8
  local _url="${9:-mongodb://localhost}"
  local _maybeTls="${10}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  createTempFile
  local _tmpFile="${RESULT}"

  cat <<EOF >"${_tmpFile}"
db.createRole(
  {
    role: "${_roleName}",
    privileges: ${_privilegeSpec},
    roles: ${_roleSpec}
  }
)
EOF
  cp "${_tmpFile}" /tmp/mongo-script.txt
  local _output
  local -i _rescode
  if isTrue ${_useTls}; then
    _output="$(cat "${_tmpFile}" | mongosh --tls -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" "${_url}/${_database}" 2>&1)"
    _rescode=$?
  else
    _output="$(cat "${_tmpFile}" | mongosh -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" "${_url}/${_database}" 2>&1)"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: addMongodbUser user password database root rootPassword authenticationDatabase authenticationMechanism roleSpec+ url? tls?
# api: public
# txt: Adds a new user.
# opt: user: The user.
# opt: password: The password.
# opt: database: The user database.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: roleSpec: The space-separated list of role names.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the user gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 1/TRUE, the variable ERROR contains some error information.
# use: if addMongodbUser "my-user" "secret" "myDb" "root" "s3cr3t" "admin" "SCRAM-SHA-256" "{ role: 'userAdmin', db: 'admin' }"; then
# use:   echo "User my-user created successfully";
# use: fi
function addMongodbUser() {
  local _user="${1}"
  checkNotEmpty user "${_user}" 1
  shift
  local _password="${1}"
  checkNotEmpty password "${_password}" 2
  shift
  local _database="${1}"
  checkNotEmpty database "${_database}" 3
  shift
  local _root="${1}"
  checkNotEmpty root "${_root}" 4
  shift
  local _rootPassword="${1}"
  checkNotEmpty rootPassword "${_rootPassword}" 5
  shift
  local _authenticationDatabase="${1}"
  checkNotEmpty authenticationaDtabase "${_authenticationDatabase}" 6
  shift
  local _authenticationMechanism="${1}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 7
  shift
  local _roleSpec="${1}"
  checkNotEmpty roleSpec "${_roleSpec}" 8
  shift
  local _url="${1:-mongodb://localhost}"
  shift
  local _maybeTls="${1}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  createTempFile
  local _tmpFile="${RESULT}"

  cat <<EOF >"${_tmpFile}"
db.createUser({ user: "${_user}", pwd: "${_password}", roles: ${_roleSpec} })
EOF

  local _output
  local -i _rescode
  if isTrue ${_useTls}; then
    _output="$(cat "${_tmpFile}" | mongosh --tls -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" "${_url}/${_database}" 2>&1)"
    _rescode=$?
  else
    _output="$(cat "${_tmpFile}" | mongosh -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" "${_url}/${_database}" 2>&1)"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: removeMongodbUser user database root rootPassword authenticationDatabase authenticationMechanism url? tls?
# api: public
# txt: Removes a new user.
# opt: user: The user.
# opt: database: The user database.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the user gets removed successfully; 1/FALSE otherwise.
# txt: If the function returns 1/TRUE, the variable ERROR contains some error information.
# use: if removeMongodbUser "my-user" "myDb" "root" "s3cr3t" "admin" "SCRAM-SHA-256"; then
# use:   echo "User my-user removed successfully";
# use: fi
function removeMongodbUser() {
  local _user="${1}"
  checkNotEmpty user "${_user}" 1
  shift
  local _database="${1}"
  checkNotEmpty database "${_database}" 2
  shift
  local _root="${1}"
  checkNotEmpty root "${_root}" 3
  shift
  local _rootPassword="${1}"
  checkNotEmpty rootPassword "${_rootPassword}" 4
  shift
  local _authenticationDatabase="${1}"
  checkNotEmpty authenticationaDtabase "${_authenticationDatabase}" 5
  shift
  local _authenticationMechanism="${1}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 6
  shift
  local _url="${1:-mongodb://localhost}"
  shift
  local _maybeTls="${1}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  createTempFile
  local _tmpFile="${RESULT}"

  cat <<EOF >"${_tmpFile}"
db.dropUser("${_user}", { j: true, w: "majority" })
EOF

  local _output
  local -i _rescode
  if isTrue ${_useTls}; then
    _output="$(cat "${_tmpFile}" | mongosh --tls -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" "${_url}/${_database}" 2>&1)"
    _rescode=$?
  else
    _output="$(cat "${_tmpFile}" | mongosh -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" "${_url}/${_database}" 2>&1)"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: mongodbFreeMonitoringAlreadyEnabled root rootPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Checks if free monitoring on the instance is already enabled.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the free monitoring is enabled; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the monitoring url; else, the variable ERROR contains some error information.
# use: if mongodbFreeMonitoringAlreadyEnabled "root" "s3cr3t" "admin" "SCRAM-SHA-256"; then
# use:   echo "Free monitoring enabled";
# use: fi
function mongodbFreeMonitoringAlreadyEnabled() {
  local _root="${1}"
  checkNotEmpty root "${_root}" 1
  local _rootPassword="${2}"
  checkNotEmpty rootPassword "${_rootPassword}" 2
  local _authenticationDatabase="${3}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 3
  local _authenticationMechanism="${4}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 4
  local _url="${5:-mongodb://localhost}"
  local _maybeTls="${7}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  local _output
  local -i _rescode

  if isTrue ${_useTls}; then
    _output="$(mongosh --tls -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" "${_authenticationDatabase}" --eval "EJSON.stringify(db.getFreeMonitoringStatus())" "${_url}/${_authenticationDatabase}" 2>&1)"
    _rescode=$?
  else
    _output="$(mongosh -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" "${_authenticationDatabase}" --eval "EJSON.stringify(db.getFreeMonitoringStatus())" "${_url}/${_authenticationDatabase}" 2>&1)"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    echo "${_output}" | grep -q '"url"' >/dev/null
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    _result="$(echo "${_output}" | grep '"url"' | awk -F'"' '{print $4;}')"
    export RESULT="${_result}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: enableMongodbFreeMonitoring root rootPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Enables free monitoring on the instance.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the free monitoring gets enabled; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the monitoring url; else, the variable ERROR contains some error information.
# use: if enableMongodbFreeMonitoring "root" "s3cr3t" "admin" "SCRAM-SHA-256"; then
# use:   echo "Free monitoring enabled";
# use: fi
function enableMongodbFreeMonitoring() {
  local _root="${1}"
  checkNotEmpty root "${_root}" 1
  local _rootPassword="${2}"
  checkNotEmpty rootPassword "${_rootPassword}" 2
  local _authenticationDatabase="${3}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 3
  local _authenticationMechanism="${4}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 4
  local _url="${5:-mongodb://localhost}"
  local _maybeTls="${7}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  local _result
  local _output
  local -i _rescode

  if isTrue ${_useTls}; then
    _output="$(mongosh --tls -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" --eval "EJSON.stringify(db.enableFreeMonitoring())" "${_url}/${_authenticationDatabase}" 2>&1)"
    _rescode=$?
  else
    _output="$(mongosh -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" --eval "EJSON.stringify(db.enableFreeMonitoring())" "${_url}/${_authenticationDatabase}" 2>&1)"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    echo "${_output}" | grep -q '"url"' >/dev/null
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    _result="$(echo "${_output}" | grep '"url"' | awk -F'"' '{print $4;}')"
    if isEmpty "${_result}"; then
      _rescode=${FALSE}
    fi
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: disableMongodbFreeMonitoring root rootPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Disables free monitoring on the instance.
# opt: root: The root user.
# opt: rootPassword: The root password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the free monitoring gets disabled; 1/FALSE otherwise.
# txt: If the function returns 1/TRUE, the variable ERROR contains some error information.
# use: if disableMongodbFreeMonitoring "root" "s3cr3t" "admin" "SCRAM-SHA-256"; then echo "Free monitoring enabled"; fi
function disableMongodbFreeMonitoring() {
  local _root="${1}"
  checkNotEmpty root "${_root}" 1
  local _rootPassword="${2}"
  checkNotEmpty rootPassword "${_rootPassword}" 2
  local _authenticationDatabase="${3}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 3
  local _authenticationMechanism="${4}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 4
  local _url="${5:-mongodb://localhost}"
  local _maybeTls="${6}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  local _output
  local -i _rescode

  if isTrue ${_useTls}; then
    _output="$(echo "db.disableFreeMonitoring()" | mongosh --tls -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_authenticationDatabase}" 2>&1)"
    _rescode=$?
  else
    _output="$(echo "db.disableFreeMonitoring()" | mongosh -u "${_root}" -p "${_rootPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_authenticationDatabase}" 2>&1)"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: waitUntilMongodIsRunning timeout checkInterval
# api: public
# txt: Waits until mongod is running.
# opt: timeout: The maximum number of seconds to wait.
# opt: checkInterval: How often to check.
# txt: Returns 0/TRUE if mongod is running; 1/FALSE if it didn't start after the timeout expired.
# use: if waitUntilMongodIsRunning 60 5; then
# use:   echo "Mongod is running";
# use: fi
function waitUntilMongodIsRunning() {
  local -i _timeout=${1}
  checkNumber timeout "${_timeout}" 1
  local -i _checkInterval=${2}
  checkNumber checkInterval "${_checkInterval}" 2

  local -i _rescode=${TRUE}
  local -i _attempts=0

  while ! isMongodRunning; do
    add ${_attempts} 1
    _attempts=${RESULT}
    multiply ${_attempts} ${_checkInterval}
    local -i _currentWait=${RESULT}
    if isLessThan ${_timeout} ${_currentWait}; then
      _rescode=${FALSE}
      break
    fi
    sleep ${_checkInterval}
  done

  return ${_rescode}
}

# fun: isMongodRunning
# api: public
# txt: Checks whether mongod is running.
# txt: Returns 0/TRUE if it's running; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE; the variable RESULT contains the mongod pid.
# use: if ! isMongodRunning; then
# use:   echo "mongod is not running";
# use: fi
function isMongodRunning() {
  DW.import process

  isRunning "$(which mongod)"
}

# fun: isMongodRunningWithNoAuthentication
# api: public
# txt: Checks mongod is running with no authentication.
# txt: Returns 0/TRUE if mongod is running with no authentication enabled; 1/FALSE otherwise.
# use: if isMongodRunningWithNoAuthentication; then
# use:   echo "Mongod is not running, or it's running with auth enabled";
# use: fi
function isMongodRunningWithNoAuthentication() {
  local -i _rescode=${FALSE}

  if isMongodRunning; then
    ps -ef | grep --color=none $(which mongod) | grep --color=none -v " --auth " | grep -v grep >/dev/null 2>&1
    _rescode=$?
  fi

  return ${_rescode}
}

# fun: killMongod
# api: public
# txt: Kills the current mongod process.
# txt: Returns 0/TRUE if the process is killed; 1/FALSE otherwise.
# use: if killMongod; then
# use:   echo "mongod process killed successfully";
# use: fi
function killMongod() {
  local _pids

  local -i _rescode=${TRUE}

  logInfo "Killing mongod process"
  if isMongodRunning; then
    _pids="${RESULT}"
    echo ${_pids} | xargs kill
    _rescode=$?
    logInfo -n "Killing mongod process"
    if isTrue ${_rescode}; then
      logInfoResult SUCCESS "done"
    else
      logInfoResult FAILURE "failed"
      if isNotEmpty "${ERROR}"; then
        logDebug "${ERROR}"
      fi
    fi
  else
    logInfoResult SUCCESS "not running"
  fi

  return ${_rescode}
}

# fun: mongoDump output host user? pass? authenticationDatabase? authenticationMechanism? tls?
# api: public
# txt: Performs a dump.
# opt: output: The output file.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: user: The user name. Optional.
# opt: pass: The password. Optional.
# opt: authenticationDatabase: The authentication database. Optional. Defaults to admin.
# opt: authenticationMechanism: The authentication mechanism. Optional. Defaults to SCRAM-SHA1.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the dump gets created successfully; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR would contain some information about the error.
# use: if mongoDump /tmp/dump-today.gz localhost root secret; then
# use:   echo "dump succeeded";
# use: fi
function mongoDump() {
  local _output="${1}"
  checkNotEmpty output "${_output}" 1
  local _db="${2}"
  local _url="${3:-mongodb://localhost}"
  local _user="${4}"
  local _pass="${5}"
  local _authenticationDatabase="${6:-admin}"
  local _authenticationMechanism="${7:-SCRAM-SHA1}"
  local _maybeTls="${8}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  local _output
  local -i _rescode

  checkReq mongodump

  if isEmpty "${_user}"; then
    if isTrue ${_useTls}; then
      _output="$(mongodump --ssl --uri="${_url}" --db="${_db}" --excludeCollectionsWithPrefix=system --out="${_output}" 2>&1)"
      _rescode=$?
    else
      _output="$(mongodump --uri="${_url}" --db="${_db}" --excludeCollectionsWithPrefix=system --out="${_output}" 2>&1)"
      _rescode=$?
    fi
  else
    if isTrue ${_useTls}; then
      _output="$(mongodump --ssl --uri="${_url}" --db="${_db}" --out="${_output}" --excludeCollectionsWithPrefix=system -u ${_user} -p ${_pass} --authenticationDatabase=${_authenticationDatabase} --authenticationMechanism=${_authenticationMechanism} 2>&1)"
      _rescode=$?
    else
      _output="$(mongodump --uri="${_url}" --db="${_db}" --out="${_output}" --excludeCollectionsWithPrefix=system -u ${_user} -p ${_pass} --authenticationDatabase=${_authenticationDatabase} --authenticationMechanism=${_authenticationMechanism} 2>&1)"
      _rescode=$?
    fi
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: mongoRestore file url? user? pass? authenticationDatabase? authenticationMechanism?
# api: public
# txt: Restores from backup.
# opt: file: The file to restore from.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: user: The user name. Optional.
# opt: password: The password. Optional.
# opt: authenticationDatabase: The authentication database. Optional. Defaults to admin.
# opt: authenticationMechanism: The authentication mechanism. Optional. Defaults to SCRAM-SHA-256.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the restore process succeeds; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR contains additional information.
# use: if mongoRestore "/tmp/dump.gz"; then
# use:   echo "Backup /tmp/dump.gz restored successfully";
# use: fi
function mongoRestore() {
  local _file="${1}"
  checkNotEmpty file "${_file}" 1

  local _url="${2:-mongodb://localhost}"
  local _user="${3}"
  local _pass="${4}"
  local _authenticationDatabase="${5:-admin}"
  local _authenticationMechanism="${6:-SCRAM-SHA-256}"
  local _maybeTls="${7}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  local _output
  local -i _rescode

  if isEmpty "${_user}"; then
    if isTrue ${_useTls}; then
      _output="$(mongorestore --ssl --uri "${_url}" "${_file}" 2>&1)"
      _rescode=$?
    else
      _output="$(mongorestore --uri "${_url}" "${_file}" 2>&1)"
      _rescode=$?
    fi
  else
    if isTrue ${_useTls}; then
      _output="$(mongorestore --ssl --uri ${_url} -u ${_user} -p ${_pass} --authenticationDatabase=${_authenticationDatabase} --authenticationMechanism=${_authenticationMechanism} "${_file}" 2>&1)"
      _rescode=$?
    else
      _output="$(mongorestore --uri ${_url} -u ${_user} -p ${_pass} --authenticationDatabase=${_authenticationDatabase} --authenticationMechanism=${_authenticationMechanism} "${_file}" 2>&1)"
      _rescode=$?
    fi
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: mongoImport file host? user? pass? authenticationDatabase? authenticationMechanism?
# api: public
# txt: Restores from backup.
# opt: file: The file to import.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: user: The user name. Optional.
# opt: password: The password. Optional.
# opt: authenticationDatabase: The authentication database. Optional. Defaults to admin.
# opt: authenticationMechanism: The authentication mechanism. Optional. Defaults to SCRAM-SHA-256.
# opt: database: The database to import. Optional.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the import process succeeds; 1/FALSE otherwise.
# txt: If the function returns 1/FALSE, the variable ERROR contains additional information.
# use: if mongoImport "/tmp/dump.gz"; then
# use:   echo "Backup /tmp/dump.gz imported successfully";
# use: fi
function mongoImport() {
  local _file="${1}"
  checkNotEmpty file "${_file}" 1
  local _url="${2:-mongodb://localhost}"
  local _user="${3}"
  local _pass="${4}"
  local _authenticationDatabase="${5:-admin}"
  local _authenticationMechanism="${6:-SCRAM-SHA-256}"
  local _database="${7}"
  local _maybeTls="${8}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  if isNotEmpty "${_database}"; then
    _database="-d ${_database}"
  fi

  local _output
  local -i _rescode

  if isEmpty "${_user}"; then
    if isTrue ${_useTls}; then
      _output="$(mongoimport --ssl --uri "${_url}" ${_database} "${_file}" 2>&1)"
      _rescode=$?
    else
      _output="$(mongoimport --uri "${_url}" ${_database} "${_file}" 2>&1)"
      _rescode=$?
    fi
  else
    if isTrue ${_useTls}; then
      _output="$(mongoimport --ssl --uri "${_url}" -u ${_user} -p ${_pass} --authenticationDatabase=${_authenticationDatabase} --authenticationMechanism=${_authenticationMechanism} ${_database} "${_file}" 2>&1)"
      _rescode=$?
    else
      _output="$(mongoimport --uri "${_url}" -u ${_user} -p ${_pass} --authenticationDatabase=${_authenticationDatabase} --authenticationMechanism=${_authenticationMechanism} ${_database} "${_file}" 2>&1)"
      _rescode=$?
    fi
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: startMongodWithAuthenticationDisabled user group permissionsFolder configFile
# api: public
# txt: Starts mongod with authentication enabled, using given user and group (and ensuring its permissions match the owners of given permissionsFolder parameter).
# opt: user: The owner of the process.
# opt: group: The group of the process.
# opt: permissionsFolder: The folder used to get the permissions from (the user and group will be adapted to match the folder's).
# opt: configFile: The mongod config file.
# txt: Returns 0/TRUE if the process could be started; 1/FALSE otherwise.
# use: startMongodbWithAuthenticationDisabled mongo mongo /var/lib/mongodb /etc/mongod.conf & disown;
function startMongodWithAuthenticationDisabled() {
  local _user="${1}"
  checkNotEmpty user "${_user}" 1
  local _group="${2}"
  checkNotEmpty group "${_group}" 2
  local _permissionsFolder="${3}"
  checkNotEmpty permissionsFolder "${_permissionsFolder}" 3
  local _configFile="${4}"
  checkNotEmpty configFile "${_configFile}" 4

  checkReq run-as.sh
  checkReq mongod

  resolveVerbosity
  local _verbosity="${RESULT}"

  chmod a+x "${_permissionsFolder}"

  $(which run-as.sh) ${_verbosity} -U ${_user} -G ${_group} -- "${_permissionsFolder}" mongod --config "${_configFile}"
  local -i _rescode=$?

  return ${_rescode}
}

# fun: startMongodWithAuthenticationEnabled user group permissionsFolder configFile authenticationMechanism
# api: public
# txt: Starts mongod with authentication enabled, using given user and group (and ensuring its permissions match the owners of given permissionsFolder parameter).
# opt: user: The owner of the process.
# opt: group: The group of the process.
# opt: permissionsFolder: The folder used to get the permissions from (the user and group will be adapted to match the folder's).
# opt: configFile: The mongod config file.
# opt: authenticationMechanism: The authentication mechanism.
# txt: Returns 0/TRUE if the process could be started; 1/FALSE otherwise.
# use: startMongodbWithAuthenticationEnabled mongo mongo /var/lib/mongodb /etc/mongod.conf SCRAM-SHA-256 & disown;
function startMongodWithAuthenticationEnabled() {
  local _user="${1}"
  checkNotEmpty user "${_user}" 1
  local _group="${2}"
  checkNotEmpty group "${_group}" 2
  local _permissionsFolder="${3}"
  checkNotEmpty permissionsFolder "${_permissionsFolder}" 3
  local _configFile="${4}"
  checkNotEmpty configFile "${_configFile}" 4
  local _authenticationMechanism="${5}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 5

  checkReq run-as.sh
  checkReq mongod

  resolveVerbosity
  local _verbosity="${RESULT}"

  chmod a+x "${_permissionsFolder}"

  $(which run-as.sh) ${_verbosity} -U ${_user} -G ${_group} -- "${_permissionsFolder}" mongod --config "${_configFile}" --auth --setParameter authenticationMechanisms=${_authenticationMechanism}
  local -i _rescode=$?

  return ${_rescode}
}

# fun: checkMongodbUserCanLogin user password authenticationDatabase authenticationMechanism
# api: public
# txt: Checks given MongoDB user can login.
# opt: user: The user name.
# opt: password: The password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if given user can log in; 1/FALSE otherwise.
# use: if mongodbUserCanLogIn root secret myDb SCRAM-SHA-256; then
# use:   echo "User can log in";
# use: fi
function mongodbUserCanLogIn() {
  local _user="${1}"
  checkNotEmpty user "${_user}" 1
  local _password="${2}"
  checkNotEmpty password "${_password}" 2
  local _authenticationDatabase="${3}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 3
  local _authenticationMechanism="${4}"
  checkNotEmpty authenticationMechanism "{_authenticationMechanism}" 4
  local _url="${5:-mongodb://localhost}"
  local _maybeTls="${6}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  local _output
  local -i _rescode
  if isTrue ${_useTls}; then
    _output="$(mongosh --tls -u "${_user}" -p "${_password}" --authenticationDatabase="${_database}" --authenticationMechanism="${_authenticationMechanism}" --eval "{ ping: 1 }" "${_url}/${_authenticationDatabase}" 2>&1)"
    _rescode=$?
  else
    _output="$(mongosh -u "${_user}" -p "${_password}" --authenticationDatabase="${_database}" --authenticationMechanism="${_authenticationMechanism}" --eval "{ ping: 1 }" "${_url}/${_authenticationDatabase}" 2>&1)"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: mongodbAdminUserAlreadyExists user database
# api: public
# txt: Checks given MongoDB user can login.
# opt: user: The user name.
# opt: database: The database.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if given user exists; 1/FALSE otherwise.
# use: if mongodbAdminUserAlreadyExists root myDb; then
# use:   echo "User root exists in myDb database";
# use: fi
function mongodbAdminUserAlreadyExists() {
  local _user="${1}"
  checkNotEmpty user "${_user}" 1
  local _database="${2}"
  checkNotEmpty database "${_database}" 2
  local _url="${3:-mongodb://localhost}"
  local _maybeTls="${4}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  local _output
  local -i _rescode

  if isTrue ${_useTls}; then
    _output="$(mongosh --tls --quiet --eval "EJSON.stringify(db.getUsers({filter: {'user': '${_user}'}}))" "${_url}/${_database}" 2>&1 | grep -v UUID)"
    _rescode=$?
  else
    _output="$(mongosh --quiet --eval "EJSON.stringify(db.getUsers({filter: {'user': '${_user}'}}))" "${_url}/${_database}" 2>&1 | grep -v UUID)"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    _output="$(echo "${_output}" | jq '. | length')"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    if areEqual "${_output}" 0; then
      _rescode=${FALSE}
    fi
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: mongodbUserAlreadyExists user database adminUserName adminUserPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Checks given MongoDB user exists in given database.
# opt: user: The user name.
# opt: database: The database.
# opt: adminUser: The user to access the MongoDB server.
# opt: adminPassword: The password to access the MongoDB server.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if given user exists; 1/FALSE otherwise.
# use: if mongodbUserAlreadyExists root myDb admin secret admin SCRAM-SHA-256; then
# use:   echo "User root exists in myDb database";
# use: fi
function mongodbUserAlreadyExists() {
  local _user="${1}"
  checkNotEmpty user "${_user}" 1
  local _database="${2}"
  checkNotEmpty database "${_database}" 2
  local _adminUserName="${3}"
  checkNotEmpty adminUserName "${_adminUserName}" 3
  local _adminUserPassword="${4}"
  checkNotEmpty adminUserPassword "${_adminUserPassword}" 4
  local _authenticationDatabase="${5}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 5
  local _authenticationMechanism="${6}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 6
  local _url="${7:-mongodb://localhost}"
  local _maybeTls="${8}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  createTempFile
  local _tmpFile="${RESULT}"

  cat <<EOF >"${_tmpFile}"
db.getUsers( { filter: { 'user': '${_user}' } } )
EOF

  local _output
  local -i _rescode
  if isTrue ${_useTls}; then
    _output="$(cat "${_tmpFile}" | mongosh --tls --quiet -u "${_adminUserName}" -p "${_adminUserPassword}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_database}" 2>&1 | grep -v "UUID")"
    _rescode=$?
  else
    _output="$(cat "${_tmpFile}" | mongosh --quiet -u "${_adminUserName}" -p "${_adminUserPassword}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_database}" 2>&1 | grep -v "UUID")"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    _output="$(echo "${_output}" | jq '. | length')"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    if areEqual "${_output}" 0; then
      _rescode=${FALSE}
    fi
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: createMongodbIndex user password authenticationDatabase authenticationMechanism database collection index options
# api: public
# txt: Creates a MongoDB index on given collection.
# opt: user: The user to log in.
# opt: password: The password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: database: The database of the collection.
# opt: collection: The collection.
# opt: index: The index.
# opt: options: The index options.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the index could be created; 1/FALSE otherwise.
# use: if createMongodbIndex root secret admin SCRAM-SHA-1 myDatabase myCollection '{ id: 1 }' '{ name: "myIndex" }'; then
# use:   echo "Index created successfully";
# use: fi
function createMongodbIndex() {
  local _user="${1}"
  checkNotEmpty user "${_user}" 1
  local _password="${2}"
  checkNotEmpty password "${_password}" 2
  local _authenticationDatabase="${3}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 3
  local _authenticationMechanism="${4}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 4
  local _database="${5}"
  checkNotEmpty collection "${_database}" 5
  local _collection="${6}"
  checkNotEmpty collection "${_collection}" 6
  local _index="${7}"
  checkNotEmpty index "${_index}" 7
  local _options="${8}"
  checkNotEmpty options "${_options}" 8
  local _url="${9:-mongodb://localhost}"
  local _maybeTls="${10}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  createTempFile
  local _tmpFile="${RESULT}"

  cat <<EOF >"${_tmpFile}"
use ${_database}

db.${_collection}.createIndex(${_index}, ${_options})
EOF

  local _output
  local -i _rescode
  if isTrue ${_useTls}; then
    _output="$(cat "${_tmpFile}" | mongosh --tls -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_database}" 2>&1 | grep 'ok' | grep '1')"
    _rescode=$?
  else
    _output="$(cat "${_tmpFile}" | mongosh -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_database}" 2>&1 | grep 'ok' | grep '1')"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: mongodbIndexAlreadyExists user password authenticationDatabase authenticationMechanism database collection index
# api: public
# txt: Checks a MongoDB index exists on given collection.
# opt: user: The user to log in.
# opt: password: The password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: database: The database.
# opt: collection: The collection.
# opt: index: The index.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the index exists; 1/FALSE otherwise.
# use: if mongodbIndexAlreadyExists root secret admin SCRAM-SHA-1 myDatabase myCollection '{ id: 1 }'; then
# use:   echo "Index exists";
# use: fi
function mongodbIndexAlreadyExists() {
  local _user="${1}"
  checkNotEmpty user "${_user}" 1
  local _password="${2}"
  checkNotEmpty password "${_password}" 2
  local _authenticationDatabase="${3}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 3
  local _authenticationMechanism="${4}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 4
  local _database="${5}"
  checkNotEmpty database "${_database}" 5
  local _collection="${6}"
  checkNotEmpty collection "${_collection}" 6
  local _index="${7}"
  checkNotEmpty index "${_index}" 7
  local _url="${8:-mongodb://localhost}"
  local _maybeTls="${9}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  createTempFile
  local _tmpFile="${RESULT}"

  cat <<EOF >${_tmpFile}
use ${_database}

var indexes = db.${_collection}.getIndexes();
var exists = false;
for (var i=0; i < indexes.length; i++) {
  if (indexes[i].name == "${_index}") {
    exists = true;
    break;
  }
};
print('**' + exists + '**');
EOF

  local _output
  local -i _rescode
  if isTrue ${_useTls}; then
    _output="$(cat "${_tmpFile}" | mongosh --tls -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_database}" 2>&1 | grep "**true**")"
    _rescode=$?
  else
    _output="$(cat "${_tmpFile}" | mongosh -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_database}" 2>&1 | grep "**true**")"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: createMongodbDatabase database temporaryCollection user password authenticationDatabase authenticationMechanism
# api: public
# txt: Creates a MongoDB database.
# opt: database: The database.
# opt: temporaryCollection: A temporary collection needed to ensure the database gets created.
# opt: user: The user to log in.
# opt: password: The password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the database could be created; 1/FALSE otherwise.
# use: if createMongodbDatabase myDatabase removeme root secret admin SCRAM-SHA-1; then
# use:   echo "Database created successfully";
# use: fi
function createMongodbDatabase() {
  local _database="${1}"
  checkNotEmpty database "${_database}" 1
  local _temporaryCollection="${2}"
  checkNotEmpty temporaryCollection "${_temporaryCollection}" 2
  local _user="${3}"
  checkNotEmpty user "${_user}" 3
  local _password="${4}"
  checkNotEmpty password "${_password}" 4
  local _authenticationDatabase="${5}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 5
  local _authenticationMechanism="${6}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 6
  local _url="${7:-mongodb://localhost}"
  local _maybeTls="${8}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  local _output
  local -i _rescode
  if isTrue ${_useTls}; then
    _output="$(echo "db.${_temporaryCollection}.insert({name: 'sample'})" | mongosh --tls -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_database}" 2>&1)"
    _rescode=$?
  else
    _output="$(echo "db.${_temporaryCollection}.insert({name: 'sample'})" | mongosh -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_database}" 2>&1)"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: mongodbDatabaseAlreadyExists database user password authenticationDatabase authenticationMechanism
# api: public
# txt: Checks a MongoDB database exists.
# opt: database: The database.
# opt: user: The user to log in.
# opt: password: The password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the database exists; 1/FALSE otherwise.
# use: if mongodbDatabaseAlreadyExists myDatabase root secret admin SCRAM-SHA-1; then
# use:   echo "Database exists";
# use: fi
function mongodbDatabaseAlreadyExists() {
  local _database="${1}"
  checkNotEmpty database "${_database}" 1
  local _user="${2}"
  checkNotEmpty user "${_user}" 2
  local _password="${3}"
  checkNotEmpty password "${_password}" 3
  local _authenticationDatabase="${4}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 4
  local _authenticationMechanism="${5}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 5
  local _url="${6:-mongodb://localhost}"
  local _maybeTls="${7}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  local _output
  local -i _rescode
  if isTrue ${_useTls}; then
    _output="$(echo "show dbs" | mongosh --tls -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_database}" 2>&1 | grep -q -e "^${_database}\W")"
    _rescode=$?
  else
    _output="$(echo "show dbs" | mongosh -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_database}" 2>&1 | grep -q -e "^${_database}\W")"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: createMongodbCollection database collection user password authenticationDatabase authenticationMechanism database options
# api: public
# txt: Creates a MongoDB collection on given database.
# opt: database: The database.
# opt: collection: The collection.
# opt: user: The user to log in.
# opt: password: The password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# opt: options: The collection options. Optional.
# txt: Returns 0/TRUE if the collection could be created; 1/FALSE otherwise.
# use: if createMongodbCollection myDatabase myCollection root secret admin SCRAM-SHA-1 myDatabase myCollection ; then
# use:   echo "Collection created successfully";
# use: fi
function createMongodbCollection() {
  local _database="${1}"
  checkNotEmpty database "${_database}" 1
  local _collection="${2}"
  checkNotEmpty collection "${_collection}" 2
  local _user="${3}"
  checkNotEmpty user "${_user}" 3
  local _password="${4}"
  checkNotEmpty password "${_password}" 4
  local _authenticationDatabase="${5}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 5
  local _authenticationMechanism="${6}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 6
  local _url="${7:-mongodb://localhost}"
  local _maybeTls="${8}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi
  local _options="${9}"
  if isNotEmpty "${_options}"; then
    _options=",${_options}"
  fi

  local _output
  local -i _rescode
  if isTrue ${_useTls}; then
    _output="$(mongosh --tls -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" --eval "db.createCollection('${_collection}'${_options})" "${_url}/${_database}" 2>&1)"
    _rescode=$?
  else
    _output="$(mongosh -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" --eval "db.createCollection('${_collection}'${_options})" "${_url}/${_database}" 2>&1)"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: mongodbCollectionAlreadyExists database collection user password authenticationDatabase authenticationMechanism
# api: public
# txt: Checks a MongoDB collection exists on given collection.
# opt: database: The database.
# opt: collection: The collection.
# opt: user: The user to log in.
# opt: password: The password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the collection exists; 1/FALSE otherwise.
# use: if mongodbCollectionAlreadyExists  myDatabase myCollection root secret admin SCRAM-SHA-1; then
# use:   echo "Collection exists";
# use: fi
function mongodbCollectionAlreadyExists() {
  local _database="${1}"
  checkNotEmpty database "${_database}" 1
  local _collection="${2}"
  checkNotEmpty collection "${_collection}" 2
  local _user="${3}"
  checkNotEmpty user "${_user}" 3
  local _password="${4}"
  checkNotEmpty password "${_password}" 4
  local _authenticationDatabase="${5}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 5
  local _authenticationMechanism="${6}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 6
  local _url="${7:-mongodb://localhost}"
  local _maybeTls="${8}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  local _output
  local -i _rescode
  if isTrue ${_useTls}; then
    _output="$(echo "show collections" | mongosh --tls -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_database}" 2>&1 | grep -e "^${_collection}$")"
    _rescode=$?
  else
    _output="$(echo "show collections" | mongosh -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_database}" 2>&1 | grep -e "^${_collection}$")"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: removeMongodbCollection database collection user password authenticationDatabase authenticationMechanism
# api: public
# txt: Removes a MongoDB collection on given database.
# opt: database: The database.
# opt: collection: The collection.
# opt: user: The user to log in.
# opt: password: The password.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE if the collection could be removed; 1/FALSE otherwise.
# use: if removeMongodbCollection myDatabase myCollection root secret admin SCRAM-SHA-1; then
# use:   echo "Collection removed successfully";
# use: fi
function removeMongodbCollection() {
  local _database="${1}"
  checkNotEmpty database "${_database}" 1
  local _collection="${2}"
  checkNotEmpty collection "${_collection}" 2
  local _user="${3}"
  checkNotEmpty user "${_user}" 3
  local _password="${4}"
  checkNotEmpty password "${_password}" 4
  local _authenticationDatabase="${5}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 5
  local _authenticationMechanism="${6}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 6
  local _url="${7:-mongodb://localhost}"
  local _maybeTls="${8}"
  local _useTls=${FALSE}
  if isNotEmpty "${_maybeTls}" && isTrue "${_maybeTls}"; then
    _useTls=${TRUE}
  fi

  local _output
  local -i _rescode
  if isTrue ${_useTls}; then
    _output="$(mongosh --tls -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_database}" --eval "db.${_collection}.drop()" 2>&1)"
    _rescode=$?
  else
    _output="$(mongosh -u "${_user}" -p "${_password}" --authenticationDatabase="${_authenticationDatabase}" --authenticationMechanism="${_authenticationMechanism}" "${_url}/${_database}" --eval "db.${_collection}.drop()" 2>&1)"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}

# fun: addMongodbRoleIfNecessary roleName privilegeSpec roleSpec cannotAddRoleErrorLabel roleDoesNotExistErrorLabel database adminUser adminPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Adds the EventSourcingEventFind role, if necessary.
# opt: roleName: The name of the role.
# opt: privilegeSpec: The privilege definition.
# opt: roleSpec: The role definition.
# opt: cannotAddRoleErrorLabel: The label of the error in case the role cannot be added.
# opt: roleDoesNotExistErrorLabel: The label of the error in case the role is missing after being supposedly created.
# opt: database: The target database.
# opt: adminUser: The user to access the MongoDB server.
# opt: adminPassword: The password to access the MongoDB server.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE always, but can exit if the role cannot be added.
# use: addMongodbRoleIfNecessary "MyRole" "[ { resource: { db: '${EVENTSTORE_DATABASE}', collection: '${EVENTSOURCINGEVENT_COLLECTION}' }, actions: [ 'find'  ] } ]" '[]' CANNOT_ADD_MYROLE MYROLE_STILL_DOES_NOT_EXIST admin admin secret admin SCRAM-SHA-256;
function addMongodbRoleIfNecessary() {
  local _roleName="${1}"
  checkNotEmpty roleName "${_roleName}" 1
  local _privilegeSpec="${2}"
  checkNotEmpty privilegeSpec "${_privilegeSpec}" 2
  local _roleSpec="${3}"
  checkNotEmpty roleSpec "${_roleSpec}" 3
  local _cannotAddRoleErrorLabel="${4}"
  checkNotEmpty cannotAddRoleErrorLabel "${_cannotAddRoleErrorLabel}" 4
  local _roleDoesNotExistErrorLabel="${5}"
  checkNotEmpty roleDoesNotExistErrorLabel "${_roleDoesNotExistErrorLabel}" 5
  local _database="${6}"
  checkNotEmpty database "${_database}" 6
  local _adminUserName="${7}"
  checkNotEmpty adminUserName "${_adminUserName}" 7
  local _adminUserPassword="${8}"
  checkNotEmpty adminUserPassword "${_adminUserPassword}" 8
  local _authenticationDatabase="${9}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 9
  local _authenticationMechanism="${10}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 10
  local _url="${11:-mongodb://localhost}"
  local _maybeTls="${12}"

  logDebug -n "Checking if ${_roleName} role already exists in ${_database} database"
  if mongodbRoleAlreadyExists "${_roleName}" "${_database}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
    logDebugResult SUCCESS "exists"
  else
    logDebugResult NEUTRAL "missing"
    logDebug -n "Adding ${_roleName} role"
    if addMongodbRole "${_roleName}" "${_database}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_privilegeSpec}" "${_roleSpec}" "${_url}" "${_maybeTls}"; then
      local _output="${RESULT}"
      logDebugResult SUCCESS "done"
      logTrace "${_output}"
    else
      local _error="${ERROR}"
      logDebugResult FAILURE "failed"
      if isNotEmpty "${_error}"; then
        logDebug "${_error}"
      fi
      exitWithErrorCode "${_cannotAddRoleErrorLabel}"
    fi

    logDebug -n "Double-checking ${_roleName} role already exists in ${_database} database"
    if mongodbRoleAlreadyExists "${_roleName}" "${_database}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
      logDebugResult SUCCESS "exists"
    else
      local _error="${ERROR}"
      logDebugResult FAILURE "missing"
      if isNotEmpty "${_error}"; then
        logDebug "${_error}"
      fi
      exitWithErrorCode "${_roleDoesNotExistErrorLabel}"
    fi
  fi
}

# fun: addMongodbUserIfNecessary userName userPassword database roleSpec cannotCreateUserErrorLabel cannotLogInErrorLabel adminUserName adminUserPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Adds the user able to access given database, if necessary.
# opt: userName: The user name.
# opt: userPassword: The user password.
# opt: database: The target database.
# opt: roleSpec: The role specification.
# opt: cannotCreateUserErrorLabel: The error label when the user cannot be created.
# opt: cannotLogInErrorLabel: The error label when the user cannot log in.
# opt: adminUserName: The user to access the MongoDB server.
# opt: adminUserPassword: The password to access the MongoDB server.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE always, but can exit if the user cannot be added.
# use: addMongodbUserIfNecessary core secret admin "[ { role: '${MyCollectionFindRole}', db: 'admin' },{ role: '${MyCollectionInsertRole}', db: 'admin' } ]" CANNOT_ADD_CORE_USER CORE_USER_CANNOT_LOG_IN admin secret admin SCRAM-SHA-256;
function addMongodbUserIfNecessary() {
  local _userName="${1}"
  checkNotEmpty userName "${_userName}" 1
  local _userPassword="${2}"
  checkNotEmpty userPassword "${_userPassword}" 2
  local _database="${3}"
  checkNotEmpty database "${_database}" 3
  local _roleSpec="${4}"
  checkNotEmpty roleSpec "${_roleSpec}" 4
  local _cannotCreateUserErrorLabel="${5}"
  checkNotEmpty cannotCreateUserErrorLabel "${_cannotCreateUserErrorLabel}" 5
  local _cannotLogInErrorLabel="${6}"
  checkNotEmpty cannotLogInErrorLabel "${_cannotLogInErrorLabel}" 6
  local _adminUserName="${7}"
  checkNotEmpty adminUserName "${_adminUserName}" 7
  local _adminUserPassword="${8}"
  checkNotEmpty adminUserPassword "${_adminUserPassword}" 8
  local _authenticationDatabase="${9}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 9
  local _authenticationMechanism="${10}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 10
  local _url="${11:-mongodb://localhost}"
  local _maybeTls="${12}"

  logDebug -n "Checking if user ${_userName} can log in, using database ${_database}"
  if mongodbUserCanLogIn "${_userName}" "${_userPassword}" "${_database}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
    logDebugResult SUCCESS "success"
  else
    logDebugResult NEUTRAL "failed"
    logDebug -n "Adding ${_userName} user"
    if addMongodbUser "${_userName}" "${_userPassword}" "${_database}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_roleSpec}" "${_url}" "${_maybeTls}"; then
      local _output="${RESULT}"
      logDebugResult SUCCESS "done"
      logTrace "${_output}"
    else
      local _error="${ERROR}"
      logDebugResult FAILURE "failed"
      if isNotEmpty "${_error}"; then
        logDebug "${_error}"
      fi
      exitWithErrorCode "${_cannotCreateUserErrorLabel}"
    fi

    logDebug -n "Double-checking if user ${_userName} can log in, using ${_database} database"
    if mongodbUserCanLogIn "${_userName}" "${_userPassword}" "${_database}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
      logDebugResult SUCCESS "success"
    else
      local _error="${ERROR}"
      logDebugResult FAILURE "failed"
      if isNotEmpty "${_error}"; then
        logDebug "${_error}"
      fi
      exitWithErrorCode "${_cannotLogInErrorLabel}"
    fi
  fi
}

# fun: removeMongodbUserIfNecessary userName database cannotCreateUserErrorLabel adminUserName adminUserPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Removes the user from given database, if necessary.
# opt: userName: The user name.
# opt: database: The database.
# opt: cannotRemoveUserErrorLabel: The error label when the user cannot be removed.
# opt: adminUserName: The user to access the MongoDB server.
# opt: adminUserPassword: The password to access the MongoDB server.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE always, but can exit if the user cannot be removed.
# use: removeMongodbUserIfNecessary core myDb CANNOT_REMOVE_CORE_USER admin secret admin SCRAM-SHA-256;
function removeMongodbUserIfNecessary() {
  local _userName="${1}"
  checkNotEmpty userName "${_userName}" 1
  local _database="${2}"
  checkNotEmpty database "${_database}" 2
  local _cannotRemoveUserErrorLabel="${3}"
  checkNotEmpty cannotRemoveUserErrorLabel "${_cannotRemoveUserErrorLabel}" 3
  local _adminUserName="${4}"
  checkNotEmpty adminUserName "${_adminUserName}" 4
  local _adminUserPassword="${5}"
  checkNotEmpty adminUserPassword "${_adminUserPassword}" 5
  local _authenticationDatabase="${6}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 6
  local _authenticationMechanism="${7}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 7
  local _url="${8:-mongodb://localhost}"
  local _maybeTls="${9}"

  logDebug -n "Checking if user ${_userName} already exists in database ${_database}"
  if mongodbUserAlreadyExists "${_userName}" "${_database}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
    logDebugResult SUCCESS "success"

    logDebug -n "Removing ${_userName} user"
    if removeMongodbUser "${_userName}" "${_database}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
      local _output="${RESULT}"
      logDebugResult SUCCESS "done"
      logTrace "${_output}"
    else
      local _error="${ERROR}"
      logDebugResult FAILURE "failed"
      if isNotEmpty "${_error}"; then
        logDebug "${_error}"
      fi
      exitWithErrorCode "${_cannotRemoveUserErrorLabel}"
    fi

    logDebug -n "Double-checking if user ${_userName} still exists in database ${_database}"
    if mongodbUserAlreadyExists "${_userName}" "${_database}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
      local _error="${ERROR}"
      logDebugResult FAILURE "failed"
      if isNotEmpty "${_error}"; then
        logDebug "${_error}"
      fi
      exitWithErrorCode "${_cannotRemoveUserErrorLabel}"
    else
      logDebugResult SUCCESS "success"
    fi
  else
    logDebugResult NEUTRAL "failed"
  fi
}

# fun: addMongodbIndexIfNecessary indexName roleSpec database collection cannotCreateIndexErrorLabel indexDoesNotExistErrorLabel adminUserName adminUserPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Adds an index, if necessary.
# opt: indexName: The index name.
# opt: roleSpec: The role specification.
# opt: database: The database.
# opt: collection: The collection.
# opt: cannotCreateIndexErrorLabel: The label of the error when the index cannot be created.
# opt: indexDoesNotExistErrorLabel: The label of the error when the index still doesn't exist after being created, supposedly.
# opt: adminUserName: The name of the admin user.
# opt: adminUserPassword: The password of the admin user.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE always, but can exit if the index cannot be created.
# use: addMongodbIndexIfNecessary id '{ id: 1 }' myDatabase myCollection CANNOT_CREATE_ID_INDEX ID_INDEX_DOES_NOT_EXIST admin secret admin SCRAM-SHA-256;
function addMongodbIndexIfNecessary() {
  local _indexName="${1}"
  checkNotEmpty indexName "${_indexName}" 1
  local _roleSpec="${2}"
  checkNotEmpty roleSpec "${_roleSpec}" 2
  local _database="${3}"
  checkNotEmpty database "${_database}" 3
  local _collection="${4}"
  checkNotEmpty collection "${_collection}" 4
  local _cannotCreateIndexErrorLabel="${5}"
  checkNotEmpty cannotCreateIndexErrorLabel "${_cannotCreateIndexErrorLabel}" 5
  local _indexDoesNotExistErrorLabel="${6}"
  checkNotEmpty indexDoesNotExistErrorLabel "${_indexDoesNotExistErrorLabel}" 6
  local _adminUserName="${7}"
  checkNotEmpty adminUserName "${_adminUserName}" 7
  local _adminUserPassword="${8}"
  checkNotEmpty adminUserPassword "${_adminUserPassword}" 8
  local _authenticationDatabase="${9}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 9
  local _authenticationMechanism="${10}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 10
  local _url="${11:-mongodb://localhost}"
  local _maybeTls="${12}"

  logDebug -n "Checking if ${_database}.${_collection}.${_indexName} index already exists"
  if mongodbIndexAlreadyExists "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_database}" "${_collection}" "${_indexName}" "${_url}" "${_maybeTls}"; then
    logDebugResult SUCCESS "exists"
  else
    logDebugResult NEUTRAL "missing"

    logDebug -n "Creating ${_database}.${_collection}.${_indexName} index"

    if createMongodbIndex "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_database}" "${_collection}" "${_roleSpec}" "{ name: '${_indexName}' }" "${_url}" "${_maybeTls}"; then
      local _output="${RESULT}"
      logDebugResult SUCCESS "done"
      logTrace "${_output}"
    else
      local _error="${ERROR}"
      logDebugResult FAILURE "failed"
      if isNotEmpty "${_error}"; then
        logDebug "${_error}"
      fi
      exitWithErrorCode "${_cannotCreateIndexErrorLabel}"
    fi

    logDebug -n "Double-checking ${_database}.${_collection}.${_indexName} index is actually created"
    if mongodbIndexAlreadyExists "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_database}" "${_collection}" "${_indexName}" "${_url}" "${_maybeTls}"; then
      logDebugResult SUCCESS "exists"
    else
      local _error="${ERROR}"
      logDebugResult FAILURE "missing"
      if isNotEmpty "${_error}"; then
        logDebug "${_error}"
      fi
      exitWithErrorCode "${_indexDoesNotExistErrorLabel}"
    fi
  fi
}

# fun: addMongodbDatabaseIfNecessary database temporaryCollection cannotCreateDatabaseErrorLabel databaseDoesNotExistErrorLabel adminUserName adminUserPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Adds a database, if necessary.
# opt: database: The database.
# opt: temporaryCollection: The name of a temporary collection, needed to ensure the database gets created.
# opt: cannotCreateDatabaseErrorLabel: The error label when the user cannot be created.
# opt: databaseDoesNotExistErrorLabel: The error label when the database still does not exist even after being supposedly created.
# opt: adminUserName: The name of the admin user.
# opt: adminUserPassword: The password of the admin user.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE always, but can exit if the database cannot be added.
# use: addMongodbDatabaseIfNecessary eventStore removeme CANNOT_ADD_EVENTSTORE_DATABASE EVENTSTORE_DATABASE_DOES_NOT_EXIST admin secret admin SCRAM-SHA-256;
function addMongodbDatabaseIfNecessary() {
  local _database="${1}"
  checkNotEmpty database "${_database}" 1
  local _temporaryCollection="${2}"
  checkNotEmpty temporaryCollection "${_temporaryCollection}" 2
  local _cannotCreateDatabaseErrorLabel="${3}"
  checkNotEmpty cannotCreateDatabaseErrorLabel "${_cannotCreateDatabaseErrorLabel}" 3
  local _databaseDoesNotExistErrorLabel="${4}"
  checkNotEmpty databaseDoesNotExistErrorLabel "${_databaseDoesNotExistErrorLabel}" 4
  local _adminUserName="${5}"
  checkNotEmpty adminUserName "${_adminUserName}" 5
  local _adminUserPassword="${6}"
  checkNotEmpty adminUserPassword "${_adminUserPassword}" 6
  local _authenticationDatabase="${7}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 7
  local _authenticationMechanism="${8}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 8
  local _url="${9:-mongodb://localhost}"
  local _maybeTls="${10}"

  logDebug -n "Checking if ${_database} database already exists"
  if mongodbDatabaseAlreadyExists "${_database}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
    logDebugResult SUCCESS "success"
  else
    logDebugResult NEUTRAL "failed"
    logDebug -n "Adding ${_database} database"
    if createMongodbDatabase "${_database}" "${_temporaryCollection}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
      local _output="${RESULT}"
      logDebugResult SUCCESS "done"
      if isNotEmpty "${_output}"; then
        logTrace "${_output}"
      fi
    else
      local _error="${ERROR}"
      logDebugResult FAILURE "failed"
      if isNotEmpty "${_error}"; then
        logDebug "${_error}"
      fi
      exitWithErrorCode "${_cannotCreateDatabaseErrorLabel}"
    fi

    logDebug -n "Double-checking if ${_database} database exists"
    if mongodbDatabaseAlreadyExists "${_database}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
      logDebugResult SUCCESS "success"
    else
      local _error="${ERROR}"
      logDebugResult FAILURE "failed"
      if isNotEmpty "${_error}"; then
        logDebug "${_error}"
      fi
      exitWithErrorCode "${_databaseDoesNotExistErrorLabel}"
    fi
  fi
}

# fun: addMongodbCollectionIfNecessary database collection cannotCreateCollectionErrorLabel collectionDoesNotExist adminUserName adminUserPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Adds a collection, if necessary.
# opt: database: The database.
# opt: collection: The collection.
# opt: cannotCreateCollectionErrorLabel: The error label when the collection cannot be created.
# opt: databaseDoesNotExistErrorLabel: The error label when the collection still does not exist even after being supposedly created.
# opt: adminUserName: The name of the admin user.
# opt: adminUserPassword: The password of the admin user.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE always, but can exit if the collection cannot be added.
# use: addMongodbCollectionIfNecessary EventSourcingEvent eventStore CANNOT_ADD_EVENTSOURCINGEVENT_COLLECTION EVENTSOURCINGEVENT_COLLECTION_DOES_NOT_EXIST admin secret admin SCRAM-SHA-256;
function addMongodbCollectionIfNecessary() {
  local _database="${1}"
  checkNotEmpty database "${_database}" 1
  local _collection="${2}"
  checkNotEmpty collection "${_collection}" 2
  local _cannotCreateCollectionErrorLabel="${3}"
  checkNotEmpty cannotCreateCollectionErrorLabel "${_cannotCreateCollectionErrorLabel}" 3
  local _collectionDoesNotExistErrorLabel="${4}"
  checkNotEmpty collectionDoesNotExistErrorLabel "${_collectionDoesNotExistErrorLabel}" 4
  local _adminUserName="${5}"
  checkNotEmpty adminUserName "${_adminUserName}" 5
  local _adminUserPassword="${6}"
  checkNotEmpty adminUserPassword "${_adminUserPassword}" 6
  local _authenticationDatabase="${7}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 7
  local _authenticationMechanism="${8}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 8
  local _url="${9:-mongodb://localhost}"
  local _maybeTls="${10}"

  logDebug -n "Checking if collection ${_collection} already exists in ${_database} database"
  if mongodbCollectionAlreadyExists "${_database}" "${_collection}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
    logDebugResult SUCCESS "success"
  else
    logDebugResult NEUTRAL "failed"
    logDebug -n "Adding ${_collection} collection in ${_database} database"
    if createMongodbCollection "${_database}" "${_collection}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
      local _output="${RESULT}"
      logDebugResult SUCCESS "done"
      if isNotEmpty "${_output}"; then
        logTrace "${_output}"
      fi
    else
      local _error="${ERROR}"
      logDebugResult FAILURE "failed"
      if isNotEmpty "${_error}"; then
        logDebug "${_error}"
      fi
      exitWithErrorCode "${_cannotCreateCollectionErrorLabel}"
    fi

    logDebug -n "Double-checking if collection ${_collection} exists in ${_database} database"
    if mongodbCollectionAlreadyExists "${_database}" "${_collection}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
      logDebugResult SUCCESS "success"
    else
      local _error="${ERROR}"
      logDebugResult FAILURE "failed"
      if isNotEmpty "${_error}"; then
        logDebug "${_error}"
      fi
      exitWithErrorCode "${_collectionDoesNotExistErrorLabel}"
    fi
  fi
}

# fun: removeMongodbCollectionIfNecessary database collection cannotRemoveCollectionErrorLabel collectionExistsErrorLabel adminUserName adminUserPassword authenticationDatabase authenticationMechanism
# api: public
# txt: Removes given collection, if necessary.
# opt: database: The database.
# opt: collection: The collection.
# opt: cannotRemoveCollectionErrorLabel: The error to use if the collection cannot be deleted.
# opt: collectionExistsErrorLabel: The error to use if the collection still exists after being supposedly removed.
# opt: adminUserName: The name of the admin user.
# opt: adminUserPassword: The password of the admin user.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE always, but can exit if the collection could not be removed.
# use: removeMongodbCollectionIfNecessary eventStore removeme CANNOT_DELETE_REMOVEME_COLLECTION REMOVEME_COLLECTION_EXISTS admin secret admin SCRAM-SHA-256;
function removeMongodbCollectionIfNecessary() {
  local _database="${1}"
  checkNotEmpty database "${_database}" 1
  local _collection="${2}"
  checkNotEmpty collection "${_collection}" 2
  local _cannotRemoveCollectionErrorLabel="${3}"
  checkNotEmpty cannotRemoveCollectionErrorLabel "${_cannotRemoveCollectionErrorLabel}" 3
  local _collectionExistsErrorLabel="${4}"
  checkNotEmpty collectionExistsErrorLabel "${_collectionExistsErrorLabel}" 4
  local _adminUserName="${5}"
  checkNotEmpty adminUserName "${_adminUserName}" 5
  local _adminUserPassword="${6}"
  checkNotEmpty adminUserPassword "${_adminUserPassword}" 6
  local _authenticationMechanism="${7}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 7
  local _authenticationDatabase="${8}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 8
  local _url="${9:-mongodb://localhost}"
  local _maybeTls="${10}"

  logDebug -n "Checking if collection ${_collection} actually exists in ${_database} database"
  if mongodbCollectionAlreadyExists "${_database}" "${_collection}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
    logDebugResult SUCCESS "true"
    logDebug -n "Removing ${_collection} collection in ${_database} database"
    if removeMongodbCollection "${_database}" "${_collection}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
      local _output="${RESULT}"
      logDebugResult SUCCESS "done"
      if isNotEmpty "${_output}"; then
        logTrace "${_output}"
      fi
    else
      local _error="${ERROR}"
      logDebugResult FAILURE "failed"
      if isNotEmpty "${_error}"; then
        logDebug "${_error}"
      fi
      exitWithErrorCode "${_cannotRemoveCollectionErrorLabel}"
    fi

    logDebug -n "Double-checking if collection ${_collection} is actually removed from ${_database} database"
    if mongodbCollectionAlreadyExists "${_database}" "${_collection}" "${_adminUserName}" "${_adminUserPassword}" "${_authenticationDatabase}" "${_authenticationMechanism}" "${_url}" "${_maybeTls}"; then
      local _error="${ERROR}"
      logDebugResult FAILURE "failed"
      if isNotEmpty "${_error}"; then
        logDebug "${_error}"
      fi
      exitWithErrorCode "${_collectionExistsErrorLabel}"
    else
      logDebugResult SUCCESS "success"
    fi
  else
    logDebugResult SUCCESS "false"
  fi
}

# fun: updateMongodbUserPassword userName userPassword database cannotUpdatePasswordErrorLabel adminUserName adminUserPassword authenticationDatabase authenticationMechanism url? tls?
# api: public
# txt: Updates the password of the user.
# opt: userName: The user name.
# opt: userPassword: The user password.
# opt: database: The target database.
# opt: cannotUpdatePasswordErrorLabel: The error label when the password cannot be updated for some reason.
# opt: adminUserName: The user to access the MongoDB server.
# opt: adminUserPassword: The password to access the MongoDB server.
# opt: authenticationDatabase: The authentication database.
# opt: authenticationMechanism: The authentication mechanism.
# opt: url: The MongoDB url. Defaults to mongodb://localhost.
# opt: tls: Whether to connect using TLS. Defaults to false.
# txt: Returns 0/TRUE always, but can exit if the password cannot be changed.
# use: updateMongodbUserPassword core secret admin CANNOT_CHANGE_PASSWORD admin secret admin SCRAM-SHA-256;
function updateMongodbUserPassword() {
  local _userName="${1}"
  checkNotEmpty userName "${_userName}" 1
  local _userPassword="${2}"
  checkNotEmpty userPassword "${_userPassword}" 2
  local _database="${3}"
  checkNotEmpty database "${_database}" 3
  local _adminUserName="${4}"
  checkNotEmpty adminUserName "${_adminUserName}" 4
  local _adminUserPassword="${5}"
  checkNotEmpty adminUserPassword "${_adminUserPassword}" 5
  local _authenticationDatabase="${6}"
  checkNotEmpty authenticationDatabase "${_authenticationDatabase}" 6
  local _authenticationMechanism="${7}"
  checkNotEmpty authenticationMechanism "${_authenticationMechanism}" 7
  local _url="${8:-mongodb://localhost}"
  local _maybeTls="${9}"

  createTempFile
  local _tmpFile="${RESULT}"

  cat <<EOF >"${_tmpFile}"
use ${_authenticationDatabase}
db.changeUserPassword("${_userName}", "${_userPassword}")
EOF
  local _output
  local -i _rescode
  if isTrue ${_useTls}; then
    _output="$(cat "${_tmpFile}" | mongosh --tls -u "${_adminUserName}" -p "${_adminUserPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" "${_url}/${_authenticationDatabase}" 2>&1)"
    _rescode=$?
  else
    _output="$(cat "${_tmpFile}" | mongosh -u "${_adminUserName}" -p "${_adminUserPassword}" --authenticationDatabase "${_authenticationDatabase}" --authenticationMechanism "${_authenticationMechanism}" "${_url}/${_authenticationDatabase}" 2>&1)"
    _rescode=$?
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_output}"
  else
    export ERROR="${_output}"
  fi

  return ${_rescode}
}
# vim: syntax=sh ts=2 sw=2 sts=4 sr noet

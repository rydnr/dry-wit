# mod: logging
# api: public
# txt: Logging functions

# set -o xtrace

# fun: LOGGING.getModuleName
# api: private
# txt: Retrieves the name of the module.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the module.
# use: LOGGING.getModuleName;
# use: echo "Module: ${RESULT}";
function LOGGING.getModuleName() {
  export RESULT="LOGGING"
  return ${TRUE}
}

# fun: LOGGING.retrieveCurrentLogLevel
# api: private
# txt: Retrieves the current log level.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the current log level.
# use: LOGGING.retrieveCurrentLogLevel;
# use: echo "log level: ${RESULT}";
function LOGGING.retrieveCurrentLogLevel() {
  export RESULT="INFO"
  return ${TRUE}
}

# fun: LOGGING.retrieveCurrentLogCategory
# api: private
# txt: Retrieves the current log category.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the current log category.
# use: LOGGING.retrieveCurrentLogCategory
# use: echo "log category: ${RESULT}";
function LOGGING.retrieveCurrentLogCategory() {
  LOGGING.peekLogCategory
  return ${TRUE}
}

# fun: LOGGING.buildDefaultLogCategory
# api: private
# txt: Builds the default log category.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the default log category.
# use: LOGGING.buildDefaultLogCategory;
# use: echo "Category: ${RESULT}";
function LOGGING.buildDefaultLogCategory() {
  local _result=""

  local -i _maxIndex
  _maxIndex==$((${#FUNCNAME[@]} - 1))
  local -i _upperLimit
  _upperLimit==$((_maxIndex - 1))

  local _oldIFS="${IFS}"
  IFS="${DWIFS}"
  local -i _index
  for _index in $(seq 1 1 ${_upperLimit}); do
    IFS="${_oldIFS}"
    local _functionName="${FUNCNAME[${_index}]}"
    if LOGGING.isValidAsLogCategory "${_functionName}"; then
      _result="${_functionName}"
      break
    fi
  done
  IFS="${_oldIFS}"

  if isEmpty "${_result}"; then
    _result="${FUNCNAME[${_maxIndex}]}"
  fi

  export RESULT="${_result}"

  return ${TRUE}
}

# fun: LOGGING.isValidAsLogCategory functionName
# api: private
# txt: Checks if given function name is valid as log category.
# opt: functionName: The name of the function.
# txt: Returns 0/TRUE if the function name is valid as log category; 1/FALSE otherwise.
# use: if LOGGING.isValidAsLogCategory "${FUNCNAME[1]}"; then
# use:   echo "valid log category";
# use: fi
function LOGGING.isValidAsLogCategory() {
  local _functionName="${1}"
  checkNotEmpty functionName "${_functionName}" 1

  local -i _rescode=${TRUE}
  local _i _skip=${FALSE}

  if startsWith "${_functionName}" "DRYWIT"; then
    _rescode=${FALSE}
    _skip=${TRUE}
  elif startsWith "${_functionName}" "LOGGING."; then
    _skip=${TRUE}
    if contains "${_functionName}" "_"; then
      # some tests include LOGGING. as part of their function names.
      _rescode=${TRUE}
    else
      _rescode=${FALSE}
    fi
  fi

  if isFalse ${_skip}; then
    LOGGING.getInvalidLogCategoriesVariableName
    local -n _invalidLogCategories="${RESULT}"

    if arrayContains "${_functionName}" ${_invalidLogCategories[@]}; then
      _rescode=${FALSE}
    fi
  fi

  return ${_rescode}
}

# fun: definedTag tag
# api: public
# txt: Checks whether given tag is defined.
# opt: tag: The tag to check.
# txt: 0/TRUE if the tag is defined; 1/FALSE otherwise.
# use: if definedTag SUCCESS; then
# use:   ...;
# use: fi
function definedTag() {
  local _tag="${1}"
  checkNotEmpty tag "${_tag}" 1

  local -i _rescode

  case "${_tag}" in
  "${SUCCESS}" | "${FAILURE}")
    _rescode=${TRUE}
    ;;
  *)
    _rescode=${FALSE}
    ;;
  esac

  return ${_rescode}
}

# fun: disableQuietMode
# api: public
# txt: Disables quiet mode.
# txt: Returns 0/TRUE always.
# use: disableQuietMode;
function disableQuietMode() {
  setQuietMode ${FALSE}
}

# fun: enableQuietMode
# api: public
# txt: Enables quiet mode.
# txt: Returns 0/TRUE always.
# use: enableQuietMode;
function enableQuietMode() {
  setQuietMode ${TRUE}
}

# fun: findOutKeyword text
# api: public
# txt: Guesses the type of keyword associated to given text.
# opt: text: The text of the keyword.
# txt: Returns SUCCESS, FAILURE, or UNDEFINED.
# use: findOutKeyword "done";
# use: local -i keyword=$?;
function findOutKeyword() {
  local _value="${1}"
  checkNotEmpty text "${_value}" 1

  local -i _rescode

  case "${_value}" in
  "${SUCCESS}" | "SUCCESS")
    _rescode=${SUCCESS}
    ;;
  "${FAILURE}" | "FAILURE")
    _rescode=${FAILURE}
    ;;
  *)
    if isSuccessKeyword "${_value}"; then
      _rescode=${SUCCESS}
    elif isFailureKeyword "${_value}"; then
      _rescode=${FAILURE}
    else
      _rescode=${UNDEFINED}
    fi
    ;;
  esac

  return ${_rescode}
}

# fun: LOGGING.keywordLabelFromCode code
# api: private
# txt: Converts given code to a keyword label.
# opt: code: The code of the keyword.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains "SUCCESS", "FAILURE", or "UNDEFINED".
# use: LOGGING.keywordLabelFromCode ${SUCCESS};
# use: echo "label: ${RESULT}";
function LOGGING.keywordLabelFromCode() {
  local _code="${1}"
  checkNotEmpty code "${_code}" 1

  local _result

  if areEqual "${_code}" "${SUCCESS}"; then
    _result=SUCCESS
  elif areEqual "${_code}" "${FAILURE}"; then
    _result=FAILURE
  else
    _result=UNDEFINED
  fi

  export RESULT="${_result}"

  return ${TRUE}
}

# fun: getLogCategory
# api: public
# txt: Retrieves the log category.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log category.
# use: getLogCategory;
# use: echo "Log category: ${RESULT}";
function getLogCategory() {
  LOGGING.peekLogCategory
}

# fun: getLogNamespace
# api: public
# txt: Retrieves the log namespace.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log namespace.
# use: getLogNamespace;
# use: echo "log namespace: ${RESULT}"
function getLogNamespace() {
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" LOG_NAMESPACE
}

# fun: LOGGING.getLogDebug
# api: private
# txt: Retrieves the LOG_DEBUG value.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the value of LOG_DEBUG.
# use: LOGGING.getLogDebug;
# use: local logDebug=${RESULT};
function LOGGING.getLogDebug() {
  LOGGING.getModuleName
  DW.getGlobalInt "${RESULT}" LOG_DEBUG
}

# fun: isDebugEnabled
# api: public
# txt: Checks whether the debug level is enabled.
# txt: Returns 0/TRUE if debug is allowed; 1/FALSE otherwise.
# use: if isDebugEnabled; then
# use:   ...;
# use: fi
function isDebugEnabled() {
  local -i _rescode=${FALSE}

  if isInfoEnabled; then
    LOGGING.getLogDebug
    _rescode=${RESULT}
  fi

  return ${_rescode}
}

# fun: LOGGING.getSuccessKeywordsVariableName
# api: private
# txt: Retrieves the name of the variable containing the success keywords.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the variable containing the success keywords.
# use: LOGGING.getSuccessKeywordsVariableName;
# use: local -n successKeywords=${RESULT}
function LOGGING.getSuccessKeywordsVariableName() {
  LOGGING.getModuleName
  DW.getGlobalVariableName "${RESULT}" SUCCESS_KEYWORDS
}

# fun: LOGGING.getFailureKeywordsVariableName
# api: private
# txt: Retrieves the name of the variable containing the failure keywords.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the variable containing the failure keywords.
# use: LOGGING.getFailureKeywordsVariableName;
# use: local -n failureKeywords=${RESULT}
function LOGGING.getFailureKeywordsVariableName() {
  LOGGING.getModuleName
  DW.getGlobalVariableName "${RESULT}" FAILURE_KEYWORDS
}

# fun: LOGGING.getBuiltinSuccessKeywordsVariableName
# api: private
# txt: Retrieves the name of the variable containing the built-in success keywords.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the variable containing the built-in success keywords.
# use: LOGGING.getBuiltinSuccessKeywordsVariableName;
# use: local -n builtinSuccessKeywords=${RESULT};
function LOGGING.getBuiltinSuccessKeywordsVariableName() {
  LOGGING.getModuleName
  DW.getGlobalVariableName "${RESULT}" BUILTIN_SUCCESS_KEYWORDS
}

# fun: LOGGING.getBuiltinFailureKeywordsVariableName
# api: private
# txt: Retrieves the name of the variable containing the built-in failure keywords.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the variable containing the built-in failure keywords.
# use: LOGGING.getBuiltinFailureKeywordsVariableName;
# use: local -n builtinFailureKeywords=${RESULT}
function LOGGING.getBuiltinFailureKeywordsVariableName() {
  LOGGING.getModuleName
  DW.getGlobalVariableName "${RESULT}" BUILTIN_FAILURE_KEYWORDS
}

# fun: isFailureKeyword keyword
# api: public
# txt: Checks whether given keyword represents a failure.
# opt: keyword: The keyword.
# txt: Returns 0/TRUE if the keyword is considered a failure; 1/FALSE otherwise.
# use: if isFailureKeyword "${keyword}"; then
# use: logInfoResult SUCCESS "done";
# use: fi
function isFailureKeyword() {
  local _keyword="${1}"
  checkNotEmpty keyword "${_keyword}" 1

  local -i _rescode=${FALSE}

  LOGGING.getFailureKeywordsVariableName
  local -n _failureKeywords=${RESULT}

  local _oldIFS="${IFS}"
  IFS="${DWIFS}"
  local _i
  for _i in ${_failureKeywords[@]}; do
    IFS="${_oldIFS}"
    if areEqual "${_i}" "${_keyword}" ||
      areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2>/dev/null)" \
        "$(echo \"${_i}\" | tr [:upper:] [:lower:] 2>/dev/null)"; then
      _rescode=${TRUE}
      break
    fi
  done
  IFS="${_oldIFS}"

  if isFalse ${_rescode}; then
    LOGGING.getBuiltinFailureKeywordsVariableName
    local -n _builtinFailureKeywords=${RESULT}

    for _i in ${_builtinFailureKeywords[@]}; do
      IFS="${_oldIFS}"
      if areEqual "${_i}" "${_keyword}" ||
        areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2>/dev/null)" \
          "$(echo \"${_i}\" | tr [:upper:] [:lower:] 2>/dev/null)"; then
        _rescode=${TRUE}
        break
      fi
    done
    IFS="${_oldIFS}"
  fi

  return ${_rescode}
}

# fun: LOGGING.getLogInfo
# api: private
# txt: Retrieves the LOG_INFO value.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the value of LOG_INFO.
# use: LOGGING.getLogInfo;
# use: local logInfo=${RESULT};
function LOGGING.getLogInfo() {
  LOGGING.getModuleName
  DW.getGlobalInt "${RESULT}" LOG_INFO ${TRUE}
}

# fun: isInfoEnabled
# api: public
# txt: Checks whether the "info" level is enabled.
# txt: Returns 0/TRUE in such case; 1/FALSE otherwise.
# use: if isInfoEnabled; then
# use:   ...;
# use: fi
function isInfoEnabled() {
  local -i _rescode

  if isQuietMode; then
    _rescode=${FALSE}
  else
    LOGGING.getLogInfo
    _rescode=${RESULT}
  fi

  return ${_rescode}
}

# fun: isLowerThanInfoEnabled
# api: public
# txt: Checks whether the enabled log level is lower than "info".
# txt: Returns 0/TRUE in such case; 1/FALSE otherwise.
# use: if isLowerThanInfoEnabled; then
# use:   ...;
# use: fi
function isLowerThanInfoEnabled() {
  if isDebugEnabled || isTraceEnabled; then
    return ${TRUE}
  else
    return ${FALSE}
  fi
}

# fun: LOGGING.getLogQuiet
# api: private
# txt: Retrieves the LOG_QUIET value.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the value of LOG_QUIET.
# use: LOGGING.getLogQuiet;
# use: local logQuiet=${RESULT};
function LOGGING.getLogQuiet() {
  LOGGING.getModuleName
  DW.getGlobalInt "${RESULT}" LOG_QUIET
}

# fun: isQuietMode
# api: public
# txt: Retrieves whether the quiet mode is on or off.
# txt: Returns 0/TRUE if the mode is enabled; 1/FALSE otherwise.
# use: if isQuietMode; then
# use:   ...;
# use: fi
function isQuietMode() {
  LOGGING.getLogQuiet
  local -i _rescode=${RESULT}

  return ${_rescode}
}

# fun: isSuccessKeyword keyword
# api: public
# txt: Checks whether given keyword represents a success.
# opt: keyword: The keyword.
# txt: Returns 0/TRUE if the keyword is considered a success; 1/FALSE otherwise.
# use: if isSuccessKeyword "${keyword}"; then
# use:   logInfoResult SUCCESS "done";
# use: fi
function isSuccessKeyword() {
  local _keyword="${1}"
  checkNotEmpty keyword "${_keyword}" 1

  local -i _rescode=${FALSE}

  LOGGING.getSuccessKeywordsVariableName
  local -n _successKeywords="${RESULT}"

  if isNotEmpty "${_successKeywords}" &&
    isNotEmpty "${_successKeywords[@]}"; then

    local _oldIFS="${IFS}"
    IFS="${DWIFS}"
    local _i
    for _i in ${_successKeywords[@]}; do
      IFS="${_oldIFS}"
      if areEqual "${_i}" "${_keyword}" ||
        areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2>/dev/null)" \
          "$(echo \"${_i}\" | tr [:upper:] [:lower:] 2>/dev/null)"; then
        _rescode=${TRUE}
        break
      fi
    done
    IFS="${_oldIFS}"
  fi

  LOGGING.getBuiltinSuccessKeywordsVariableName
  local -n _builtinSuccessKeywords=${RESULT}

  if isFalse ${_rescode} &&
    isNotEmpty "${_builtinSuccessKeywords}" &&
    isNotEmpty "${_builtinSuccessKeywords[@]}"; then
    IFS="${DWIFS}"
    local _i
    for _i in ${_builtinSuccessKeywords[@]}; do
      IFS="${_oldIFS}"
      if areEqual "${_i}" "${1}" ||
        areEqual "$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2>/dev/null)" \
          "$(echo \"${_i}\" | tr [:upper:] [:lower:] 2>/dev/null)"; then
        _rescode=${TRUE}
        break
      fi
    done
    IFS="${_oldIFS}"
  fi

  return ${_rescode}
}

# fun: logResult SUCCESS|FAILURE? message
# api: public
# txt: Logs given outcome.
# opt: SUCCESS|FAILURE: The keyword. Optional. If omitted, it'll be inferred from the message.
# opt: message: The outcome to log.
# txt: Returns 0/TRUE always.
# use: logResult SUCCESS "done";
function logResult() {
  local _outcome="${1}"
  shift
  local _message="${@}"

  if isEmpty "${_message}"; then
    _message="${_outcome}"
  fi

  findOutKeyword "${_outcome}"
  local -i _outcomeCode=$?

  LOGGING.keywordLabelFromCode ${_outcomeCode}
  local _outcomeLabel="${RESULT}"

  LOGGING.checkSuccessFailureOrNeutral "${_outcomeLabel}" 1
  checkNotEmpty message "${_message}" 2
  LOGGING.logStuffResult "${_outcomeLabel}" "${_message}"
}

# fun: LOGGING.getLogTrace
# api: private
# txt: Retrieves the LOG_TRACE value.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the value of LOG_TRACE.
# use: LOGGING.getLogTrace;
# use: local logTrace=${RESULT};
function LOGGING.getLogTrace() {
  LOGGING.getModuleName
  DW.getGlobalInt "${RESULT}" LOG_TRACE
}

# fun: isTraceEnabled
# api: public
# txt: Checks whether trace is enabled.
# txt: Returns 0/TRUE if trace is enabled; 1/FALSE otherwise.
# use: if isTraceEnabled; then
# use:   ...;
# use: fi
function isTraceEnabled() {
  local -i _rescode=${FALSE}

  if isDebugEnabled; then
    LOGGING.getLogTrace
    _rescode=${RESULT}
  fi

  return ${_rescode}
}

# fun: log message
# api: public
# txt: Logs a message as "info".
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: log "Operation in progress";
function log() {
  checkNotEmpty message "${1}" 1
  logInfo "$@"
}

# fun: logDebug message
# api: public
# txt: Logs given message under the "debug" level.
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logDebug "Operation in progress";
function logDebug() {
  if isDebugEnabled; then
    checkNotEmpty message "${1}" 1
    LOGGING.logStuff DEBUG "$@"
  fi
}

# fun: logDebugFromStdin
# api: public
# txt: Logs given message under the "debug" level.
# opt: [stdin]: The message to log.
# txt: Returns 0/TRUE always.
# use: logDebugFromStdin <<<"Operation in progress";
function logDebugFromStdin() {
  if isDebugEnabled; then
    local _line
    while read _line; do
      if isNotEmpty "${_line}"; then
        LOGGING.logStuff DEBUG "${_line}"
      fi
    done
  fi
}

# fun: logDebugFile file
# api: public
# txt: Logs the contents of given file, under the "debug" level.
# opt: file: The file to log.
# txt: Returns 0/TRUE always.
# use: logDebugFile '/tmp/my-log.txt';
function logDebugFile() {
  if isDebugEnabled; then
    local _file="${1}"
    checkNotEmpty file "${_file}" 1

    local _line
    cat "${_file}" | while IFS='' read -r _line; do
      LOGGING.logStuff DEBUG "${_line}"
    done
  fi
}

# fun: logDebugFileContents file
# api: public
# txt: Logs the contents of a file, using the DEBUG level.
# opt: file: The file.
# txt: Returns 0/TRUE always.
# use: logDebugFileContents /tmp/my-file.log
function logDebugFileContents() {
  if isDebugEnabled; then
    [ -f "$1" ] && sed 's ^\s+$  g' "$1" | awk '{printf("logDebug \"%s\"\n", $0);}' | sh
  fi
}

# fun: logDebugResult SUCCESS|FAILURE message
# api: public
# txt: Logs given outcome under the "debug" level.
# opt: SUCCESS|FAILURE: The keyword.
# opt: message: The outcome to log.
# txt: Returns 0/TRUE always.
# use: logDebugResult SUCCESS "done";
function logDebugResult() {
  local _outcome="${1}"
  shift
  local _message="${@}"

  if isDebugEnabled; then
    checkNotEmpty "SUCCESS|FAILURE|NEUTRAL" "${_outcome}" 1
    LOGGING.checkSuccessFailureOrNeutral "${_outcome}" 1
    checkNotEmpty message "${_message}" 2
    LOGGING.logStuffResult "${_outcome}" "${_message}"
  fi
}

# fun: logFile file
# api: public
# txt: Logs the contents of a file, as "info".
# opt: file: The file with the log messages.
# txt: Returns 0/TRUE always.
# use: logFile /tmp/my-log.txt;
function logFile() {
  local _file="${1}"
  checkNotEmpty file "${_file}" 1

  local _line
  cat "${_file}" | while IFS='' read -r _line; do
    LOGGING.logStuff INFO "${_line}"
  done
}

# fun: LOGGING.getLogOutcomeTokensVariableName
# api: private
# txt: Retrieves the name of the variable containing the log outcome tokens.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the variable containing the log outcome tokens.
# use: LOGGING.getLogOutcomeTokensVariableName; local -n logOutputTokens=${RESULT}
function LOGGING.getLogOutcomeTokensVariableName() {
  LOGGING.getModuleName
  DW.getGlobalVariableName "${RESULT}" LOG_OUTCOME_TOKENS
}

# fun: setLogOutcomeTokens tokens+
# api: public
# txt: Specifies the log outcome tokens.
# opt: tokens: The log outcome tokens.
# txt: Returns 0/TRUE always.
# use: setLogOutcomeTokens "[" "timestamp" "<" "category" ">" "logLevel" "]";
function setLogOutcomeTokens() {
  local _firstToken="${1}"
  checkNotEmpty tokens "${_firstToken}" 1

  LOGGING.getModuleName
  DW.declareGlobalArray "${RESULT}" LOG_OUTCOME_TOKENS "$@"
}

# fun: getLogOutcomeSeparator
# api: public
# txt: Retrieves the log outcome separator.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log outcome separator.
# use: getLogOutcomeSeparator; local logOutputSeparator="${RESULT}";
function getLogOutcomeSeparator() {
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" LOG_OUTCOME_SEPARATOR
}

# fun: setLogOutcomeSeparator
# api: public
# txt: Specifies the log outcome separator.
# opt: separator: The separator.
# txt: Returns 0/TRUE always.
# use: setLogOutcomeSeparator " ";
function setLogOutcomeSeparator() {
  local _separator="${1}"
  checkNotEmpty separator "${_separator}" 1

  LOGGING.getModuleName
  DW.declareGlobalString "${RESULT}" LOG_OUTCOME_SEPARATOR "${_separator}"
}

# fun: LOGGING.getErrorLogPrefixToken
# api: private
# txt: Retrieves the log prefix token for the ERROR log level.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log outcome separator.
# use: LOGGING.getErrorLogPrefixToken; local logPrefixToken="${RESULT}";
function LOGGING.getErrorLogPrefixToken() {
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" ERROR_LOG_PREFIX_TOKEN
}

# fun: setErrorLogPrefixToken token
# api: public
# txt: Specifies the log prefix token for the ERROR log level.
# opt: token: The token.
# txt: Returns 0/TRUE always.
# use: setErrorLogPrefixToken ".";
function setErrorLogPrefixToken() {
  local _token="${1}"
  checkNotEmpty token "${_token}" 1

  LOGGING.getModuleName
  DW.declareGlobalString "${RESULT}" ERROR_LOG_PREFIX_TOKEN "${_token}"
}

# fun: LOGGING.getWarnLogPrefixToken
# api: private
# txt: Retrieves the log prefix token for the WARN log level.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log outcome separator.
# use: LOGGING.getWarnLogPrefixToken; local logPrefixToken="${RESULT}";
function LOGGING.getWarnLogPrefixToken() {
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" WARN_LOG_PREFIX_TOKEN
}

# fun: setWarnLogPrefixToken token
# api: public
# txt: Specifies the log prefix token for the WARN log level.
# opt: token: The token.
# txt: Returns 0/TRUE always.
# use: setWarnLogPrefixToken ".";
function setWarnLogPrefixToken() {
  local _token="${1}"
  checkNotEmpty token "${_token}" 1

  LOGGING.getModuleName
  DW.declareGlobalString "${RESULT}" WARN_LOG_PREFIX_TOKEN "${_token}"
}

# fun: LOGGING.getInfoLogPrefixToken
# api: private
# txt: Retrieves the log prefix token for the INFO log level.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log outcome separator.
# use: LOGGING.getInfoLogPrefixToken; local logPrefixToken="${RESULT}";
function LOGGING.getInfoLogPrefixToken() {
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" INFO_LOG_PREFIX_TOKEN
}

# fun: setInfoLogPrefixToken token
# api: public
# txt: Specifies the log prefix token for the INFO log level.
# opt: token: The token.
# txt: Returns 0/TRUE always.
# use: setInfoLogPrefixToken ".";
function setInfoLogPrefixToken() {
  local _token="${1}"
  checkNotEmpty token "${_token}" 1

  LOGGING.getModuleName
  DW.declareGlobalString "${RESULT}" INFO_LOG_PREFIX_TOKEN "${_token}"
}

# fun: LOGGING.getDebugLogPrefixToken
# api: private
# txt: Retrieves the log prefix token for the DEBUG log level.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log outcome separator.
# use: LOGGING.getDebugLogPrefixToken; local logPrefixToken="${RESULT}";
function LOGGING.getDebugLogPrefixToken() {
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" DEBUG_LOG_PREFIX_TOKEN
}

# fun: setDebugLogPrefixToken token
# api: public
# txt: Specifies the log prefix token for the DEBUG log level.
# opt: token: The token.
# txt: Returns 0/TRUE always.
# use: setDebugLogPrefixToken "o";
function setDebugLogPrefixToken() {
  local _token="${1}"
  checkNotEmpty token "${_token}" 1

  LOGGING.getModuleName
  DW.declareGlobalString "${RESULT}" DEBUG_LOG_PREFIX_TOKEN "${_token}"
}

# fun: LOGGING.getTraceLogPrefixToken
# api: private
# txt: Retrieves the log prefix token for the TRACE log level.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log outcome separator.
# use: LOGGING.getTraceLogPrefixToken;
# use: local logPrefixToken="${RESULT}";
function LOGGING.getTraceLogPrefixToken() {
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" TRACE_LOG_PREFIX_TOKEN
}

# fun: setTraceLogPrefixToken token
# api: public
# txt: Specifies the log prefix token for the TRACE log level.
# opt: token: The token.
# txt: Returns 0/TRUE always.
# use: setTraceLogPrefixToken "O";
function setTraceLogPrefixToken() {
  local _token="${1}"
  checkNotEmpty token "${_token}" 1

  LOGGING.getModuleName
  DW.declareGlobalString "${RESULT}" TRACE_LOG_PREFIX_TOKEN "${_token}"
}

# fun: LOGGING.getInvalidLogCategoriesVariableName
# api: private
# txt: Retrieves the name of the variable containing the invalid log categories.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the variable containing the invalid log categories.
# use: LOGGING.getInvalidLogCategoriesVariableName;
# use: local -n invalidLogCategories=${RESULT}
function LOGGING.getInvalidLogCategoriesVariableName() {
  LOGGING.getModuleName
  DW.getGlobalVariableName "${RESULT}" INVALID_LOG_CATEGORIES
}

# fun: setInvalidLogCategories category+
# api: public
# txt: Specifies the invalid log categories.
# opt: category: The invalid log categories.
# txt: Returns 0/TRUE always.
# use: setInvalidLogCategories myLog logInfo;
function setInvalidLogCategories() {
  local _firstCategory="${1}"
  checkNotEmpty category "${_firstCategory}" 1

  LOGGING.getModuleName
  DW.declareGlobalArray "${RESULT}" INVALID_LOG_CATEGORIES "$@"
}

# fun: addInvalidLogCategory category
# api: public
# txt: Adds a new invalid log category.
# opt: category: The log category to hide in prefix tokens.
# txt: Returns 0/TRUE always.
# use: addInvalidLogCategory myLog;
function addInvalidLogCategory() {
  local _category="${1}"
  checkNotEmpty category "${_category}" 1

  LOGGING.getInvalidLogCategoriesVariableName
  local -n _logCategories="${RESULT}"

  _logCategories[${#_logCategories[@]}]="${_category}"
}

# fun: LOGGING.alignRight message outcome
# api: private
# txt: Writes spaces until the next message to print is aligned to the right.
# opt: message: The log-line message.
# opt: outcome: The log outcome message.
# txt: Returns 0/TRUE always.
# use: LOGGING.alignRight "Finishing work" "done";
function LOGGING.alignRight() {
  local _logLineMessage="${1}"
  checkNotEmpty message "${_logLineMessage}" 1
  local _outcome="${2}"
  checkNotEmpty outcome "${_outcome}" 2

  if getTermWidth; then
    local -i _termWidth=${RESULT}

    if LOGGING.alignRightForWidth "${_logLineMessage}" "${_termWidth}"; then
      local -i _offset=${RESULT}

      getLogOutcomeSeparator
      local _logOutcomeSeparator="${RESULT}"

      local _oldIFS="${IFS}"
      IFS="${DWIFS}"
      local -i _index=0
      local _separatorSpace=""
      while isGreaterThan $((${_offset} - ${_index} + 1)) 0; do
        IFS="${_oldIFS}"
        _index=$((${_index} + 1))
        _separatorSpace="${_separatorSpace}${_logOutcomeSeparator}"
      done
      IFS="${_oldIFS}"
      echo -n "${_separatorSpace}"
    fi
  fi
}

# fun: LOGGING.logOutcomeTokensLength
# api: private
# txt: Returns the length of the string composed of the log outcome tokens.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the length.
# use: LOGGING.logOutcomeTokensLength;
# use: echo "length: ${RESULT}";
function LOGGING.logOutcomeTokensLength() {
  local _result=""

  LOGGING.getLogOutcomeTokensVariableName
  local -n _logOutcomeTokens=${RESULT}

  local _oldIFS="${IFS}"
  IFS="${DWIFS}"
  local _token
  for _token in "${_logOutcomeTokens[@]}"; do
    IFS="${_oldIFS}"
    _result="${_result}${_token}"
  done
  IFS="${_oldIFS}"

  export RESULT=${#_result}

  return ${TRUE}
}

# fun: LOGGING.alignRightForWidth message termWidth
# api: private
# txt: Writes spaces until the next message to print is aligned to the right.
# opt: message: The log-line message.
# opt: termWidth: The term width.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the number of times the separator needs to be printed to get the outcome aligned to the right.
# use: LOGGING.alignRightForWidth "Finishing work" 80;
# use: echo "offset: ${RESULT}";
function LOGGING.alignRightForWidth() {
  local _logMessage="${1}"
  checkNotEmpty message "${_logMessage}" 1
  local _termWidth="${2}"
  checkNumber termWidth "${_termWidth}" 2

  LOGGING.logOutcomeTokensLength
  local -i _logOutcomeTokensLength=${RESULT}

  local -i _result=$((${_termWidth} - (${#_logMessage} + ${_logOutcomeTokensLength}) % ${_termWidth} + 1))

  export RESULT=${_result}

  return ${TRUE}
}

# fun: LOGGING.closeLogLine
# api: private
# txt: Closes the log line.
# txt: Returns 0/TRUE always.
# use: LOGGING.closeLogLine;
function LOGGING.closeLogLine() {
  LOGGING.getModuleName
  DW.setGlobalInt "${RESULT}" LOG_LINE_OPEN ${FALSE}
}

# fun: LOGGING.getLogPrefixTokensVariableName
# api: private
# txt: Retrieves the name of the variable containing the log prefix tokens.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the name of the variable containing the log prefix tokens.
# use: LOGGING.getLogPrefixTokensVariableName;
# use: local -n logPrefixTokens=${RESULT};
function LOGGING.getLogPrefixTokensVariableName() {
  LOGGING.getModuleName
  DW.getGlobalVariableName "${RESULT}" LOG_PREFIX_TOKENS
}

# fun: setLogPrefixTokens tokens+
# api: public
# txt: Specifies the log prefix tokens.
# opt: tokens: The log prefix tokens.
# txt: Returns 0/TRUE always.
# use: setLogPrefixTokens "[" "timestamp" "<" "category" ">" "logLevel" "]";
function setLogPrefixTokens() {
  local _firstToken="${1}"
  checkNotEmpty tokens "${_firstToken}" 1

  LOGGING.getModuleName
  DW.declareGlobalArray "${RESULT}" LOG_PREFIX_TOKENS "$@"
}

# fun: LOGGING.getLogPrefixColorsVariableName
# api: private
# txt: Retrieves the name of the variable containing the log prefix colors.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the name of the variable containing the log prefix colors.
# use: LOGGING.getLogPrefixColorsVariableName;
# use: local -n logPrefixColors=${RESULT};
function LOGGING.getLogPrefixColorsVariableName() {
  LOGGING.getModuleName
  DW.getGlobalVariableName "${RESULT}" LOG_PREFIX_COLORS
}

# fun: setLogPrefixColors colors+
# api: public
# txt: Specifies the log prefix colors.
# opt: colors: The colors, in the same order as log prefixes.
# txt: Returns 0/TRUE always.
# use: setLogPrefixColors BLUE CYAN YELLOW MAGENTA YELLOW RED BLUE;
function setLogPrefixColors() {
  local _firstColor="${1}"
  checkNotEmpty colors "${_firstColor}" 1

  LOGGING.getModuleName
  DW.declareGlobalArray "${RESULT}" LOG_PREFIX_COLORS "$@"
}

# fun: LOGGING.getLogOutcomeColorsVariableName
# api: private
# txt: Retrieves the name of the variable containing the log outcome colors.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the variable name containing the log outcome colors.
# use: LOGGING.getLogOutcomeColorsVariableName;
# use: local -n outcomeColors=${RESULT};
function LOGGING.getLogOutcomeColorsVariableName() {
  LOGGING.getModuleName
  DW.getGlobalVariableName "${RESULT}" LOG_OUTCOME_COLORS
}

# fun: setLogOutcomeColors colors+
# api: public
# txt: Specifies the log outcome colors.
# opt: colors: The log outcome colors.
# txt: Returns 0/TRUE always.
# use: setLogOutcomeColors CYAN WHITE CYAN;
function setLogOutcomeColors() {
  local _firstColor="${1}"
  checkNotEmpty colors "${_firstColor}" 1

  LOGGING.getModuleName
  DW.declareGlobalArray "${RESULT}" LOG_OUTCOME_COLORS "$@"
}

# fun: LOGGING.buildLogPrefix inColor
# api: private
# txt: Builds the log prefix, for color and non-color terminals.
# opt: inColor: Whether to use ANSI colors or not.
# txt: Returns 0/TRUE always.
# use: LOGGING.buildLogPrefix ${FALSE};
# use: echo -n "${RESULT}";
function LOGGING.buildLogPrefix() {
  local -i _allowsColors=${FALSE}
  if isGreaterThan $# 0; then
    _allowsColors=${1}
    checkBoolean inColor "${_allowsColors}" 1
  fi

  local _result=""
  LOGGING.processLogPrefixTokens
  LOGGING.getLogPrefixTokensVariableName
  local -n _logPrefixTokens="${RESULT}"

  local -n _logPrefixColors
  if isTrue ${_allowsColors}; then
    LOGGING.getLogPrefixColorsVariableName
    _logPrefixColors="${RESULT}"
  fi

  local -i _len=$((${#_logPrefixTokens[@]} - 1))

  local _oldIFS="${IFS}"
  IFS="${DWIFS}"
  local -i _i
  for _i in $(seq 0 1 ${_len}); do
    IFS="${_oldIFS}"
    local _token="${_logPrefixTokens[${_i}]}"
    if isTrue ${_allowsColors}; then
      _result="${_result}$(echoInColor -n "${_logPrefixColors[${_i}]}" "${_token}")"
    else
      _result="${_result}${_token}"
    fi
  done
  IFS="${_oldIFS}"

  if isTrue ${_allowsColors}; then
    resetColor
  fi
  _result="${_result} "

  export RESULT="${_result}"

  return ${TRUE}
}

# fun: LOGGING.echoLogPrefix
# api: private
# txt: Prints the log prefix, for color and non-color terminals.
# txt: Returns 0/TRUE always.
# use: LOGGING.echoLogPrefix;
function LOGGING.echoLogPrefix() {
  allowsColors
  local -i _allowsColors=$?

  LOGGING.buildLogPrefix ${_allowsColors}
  local _result="${RESULT}"
  echo -n "${_result}"
  LOGGING.logToFiles "${_result}"
}

# fun: rightJustificationEnabled
# api: public
# txt: Checks if the logging outcomes should be justified to the right or not.
# txt: Returns 0/TRUE in that case; 1/FALSE otherwise.
# use: if rightJustificationEnabled; then
# use:   echo "Justification is enabled";
# use: fi
function rightJustificationEnabled() {
  local -i _rescode=${FALSE}

  if isNotEmpty "${ENABLE_RIGHT_JUSTIFIED_LOGGING}" && isTrue "${ENABLE_RIGHT_JUSTIFIED_LOGGING}"; then
    _rescode=${TRUE}
  fi

  return ${_rescode}
}

# fun: LOGGING.echoLogOutcome SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS text
# api: private
# txt: Prints the log outcome.
# opt: SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS: The keyword (SUCCESS, FAILURE, NEUTRAL, IN_PROGRESS).
# opt: text: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.echoLogOutcome SUCCESS "sample";
function LOGGING.echoLogOutcome() {
  local _keyword="${1}"
  checkNotEmpty keyword "${_keyword}" 1
  LOGGING.checkSuccessFailureNeutralOrInProgress "${_keyword}" 1
  shift
  local _text="${@}"
  checkNotEmpty text "${_text}" 2

  local -n _logOutcomeColors
  allowsColors
  local -i _allowsColors=$?

  if isTrue ${_allowsColors}; then
    LOGGING.processLogOutcomeColors "${_keyword}"
    LOGGING.getLogOutcomeColorsVariableName
    _logOutcomeColors=${RESULT}
  fi

  LOGGING.peekLog
  local _inProgressMessage="${RESULT}"

  LOGGING.buildLogPrefix ${FALSE}
  local _logPrefix="${RESULT}"

  LOGGING.processLogOutcomeTokens "${_text}"
  LOGGING.getLogOutcomeTokensVariableName
  local -n _logOutcomeTokens=${RESULT}

  if rightJustificationEnabled; then
    LOGGING.alignRight "${_logPrefix}${_inProgressMessage}" "${_text}"
  else
    echo -n " ... "
  fi

  local -i _len=$((${#_logOutcomeTokens[@]} - 1))

  local _oldIFS="${IFS}"
  IFS="${DWIFS}"
  local -i _i

  if isTrue ${_allowsColors}; then

    IFS="${DWIFS}"
    for _i in $(seq 0 1 ${_len}); do
      IFS="${_oldIFS}"
      local _token="${_logOutcomeTokens[${_i}]}"
      if isNotEmpty "${_logOutcomeColors[${_i}]}"; then
        #      evalConstant "${_logOutcomeColors[${_i}]}";
        #      local _outcomeColor="${RESULT}";
        echoInColor -n "${_logOutcomeColors[${_i}]}" "${_token}"
      fi
    done
    IFS="${_oldIFS}"

    resetColor
  else

    IFS="${DWIFS}"
    for _i in $(seq 0 1 ${_len}); do
      IFS="${_oldIFS}"
      local _token="${_logOutcomeTokens[${_i}]}"
      if isEmpty "${_token}"; then
        cat <<EOF >/tmp/dwbugs.txt
logOutcomeTokens[${i}] is empty
* -> _logOutcomeTokens[$*]
@ -> _logOutcomeTokens[$@]
EOF
      else
        echo -n "${_token}"
        LOGGING.logToFiles "${_token}"
      fi
    done
    IFS="${_oldIFS}"
  fi
}

# fun: getLogNestedIndentation
# api: public
# txt: Retrieves the indentation used when logging nested tasks.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the nested indentation.
# use: getLogNestedIndentation;
# use: echo "indentation: ${RESULT}";
function getLogNestedIndentation() {
  LOGGING.getModuleName
  DW.getGlobalVariableName "${RESULT}" LOG_NESTED_INDENTATION
}

# fun: setLogNestedIndentation
# api: public
# txt: Specifies the indentation text used when logging nested tasks.
# opt: text: The text to use.
# txt: Returns 0/TRUE always.
# use: setLogNestedIndentation "  ";
function setLogNestedIndentation() {
  local _text="${1}"

  LOGGING.getModuleName
  DW.declareGlobalString "${RESULT}" LOG_NESTED_INDENTATION "${_text}"
}

# fun: LOGGING.echoLogOutcomeNested TRACE|DEBUG|INFO|WARN|ERROR SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS text
# api: private
# txt: Prints the log outcome, used when nesting log calls.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS: The keyword (SUCCESS, FAILURE, NEUTRAL, IN_PROGRESS).
# opt: text: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.echoLogOutcome DEBUG SUCCESS "sample"
function LOGGING.echoLogOutcomeNested() {
  local _level="${1}"
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1
  shift
  local _keyword="${1}"
  checkNotEmpty "SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS" "${_keyword}" 2
  LOGGING.checkSuccessFailureNeutralOrInProgress "${_keyword}" 2
  shift
  local _text="${@}"
  checkNotEmpty text "${_text}" 3

  LOGGING.popLog
  local _inProgressMessage="${RESULT}"

  LOGGING.echoLogOutcome "${_keyword}" "${_text}"

  LOGGING.numberOfNestedInProgressTasks
  local _nestedTasks=$?
  getLogNestedIndentation
  local -n _logNestedIndentation=${RESULT}

  local _indentation=""

  local _oldIFS="${IFS}"
  IFS="${DWIFS}"
  local -i _i
  for _i in $(seq 1 1 ${_nestedTasks}); do
    IFS="${_oldIFS}"
    _indentation="${_indentation}${_logNestedIndentation}"
  done
  IFS="${_oldIFS}"

  LOGGING.pushLog "${_indentation}${_inProgressMessage}"
}

# fun: LOGGING.getLastLog
# api: private
# txt: Retrieves the last log message.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the last log message.
# use: LOGGING.getLastLog;
# use: echo "Last log: ${RESULT}";
function LOGGING.getLastLog() {
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" LAST_LOG
}

# fun: isLogLineOpen
# api: public
# txt: Checks whether the log line is currently opened.
# txt: Returns 0/TRUE if it's open; 1/FALSE otherwise.
# use: if isLogLineOpen; then
# use:   ...;
# use: fi
function isLogLineOpen() {
  LOGGING.getModuleName
  DW.getGlobalInt "${RESULT}" LOG_LINE_OPEN
  local _open=${RESULT}

  local -i _rescode=${FALSE}

  if isTrue ${_open}; then
    _rescode=${TRUE}
  fi

  return ${_rescode}
}

# fun: LOGGING.logCompleted SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS outcome
# api: private
# txt: Prints the result of a task.
# opt: SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, NEUTRAL, IN_PROGRESS).
# opt: outcome: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.logCompleted SUCCESS "done";
function LOGGING.logCompleted() {
  local _keyword="${1}"
  checkNotEmpty "SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS" "${_keyword}" 1
  LOGGING.checkSuccessFailureNeutralOrInProgress "${_keyword}" 1
  shift
  local _text="${@}"
  checkNotEmpty text "${_text}" 2

  LOGGING.numberOfNestedInProgressTasks
  local -i _nestedTasks=$?
  if isGreaterThan ${_nestedTasks} 1; then
    LOGGING.logCompletedNested "${_keyword}" "${_text}"
  else
    LOGGING.logCompletedNoNested "${_keyword}" "${_text}"
  fi
}

# fun: getDefaultLogResumingTaskColor
# api: public
# txt: Retrieves the default color used when logging a resuming task.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the text.
# use: getDefaultLogResumingTaskColor;
# use: echo "Default log resuming task color: ${RESULT}";
function getDefaultLogResumingTaskColor() {
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" DEFAULT_LOG_RESUMING_TASK_COLOR
}

# fun: setDefaultLogResumingTaskColor
# api: public
# txt: Specifies the default color used when logging a resuming task.
# opt: color: The color to use.
# txt: Returns 0/TRUE always.
# use: setDefaultLogResumingTaskColor GREEN;
function setDefaultLogResumingTaskColor() {
  local _color="${1}"
  checkNotEmpty color "${_color}" 1

  LOGGING.getModuleName
  DW.declareGlobalString "${RESULT}" DEFAULT_LOG_RESUMING_TASK_COLOR "${_color}"
}

# fun: LOGGING.logCompletedNested SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS outcome
# api: private
# txt: Prints the result of a task, when there're nested tasks.
# opt: SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, NEUTRAL, IN_PROGRESS).
# opt: outcome: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.logCompletedNested SUCCESS "done";
function LOGGING.logCompletedNested() {
  local _keyword="${1}"
  checkNotEmpty "SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS" "${_keyword}" 2
  LOGGING.checkSuccessFailureNeutralOrInProgress "${_keyword}" 2
  shift
  local _message="$@"
  checkNotEmpty outcome "${_message}" 3

  local _logPrefix
  LOGGING.echoLogOutcome "${_keyword}" "${_message}"
  echo
  LOGGING.popLog
  local _nestedTask="${RESULT}"
  LOGGING.echoLogPrefix
  getDefaultLogResumingTaskColor
  local _defaultLogResumingTaskColor="${RESULT}"
  #  LOGGING.setLastLogLevel "${_level}";
  echoColorizedText "${_nestedTask}" "" "${_defaultLogResumingTaskColor}"
  LOGGING.logToFiles "-${_nestedTask}-"
  LOGGING.logToFilesAnEmptyLine
  LOGGING.popLogLevel
}

# fun: LOGGING.checkTraceDebugInfoWarnOrError TRACE|DEBUG|INFO|WARN|ERROR index
# api: private
# txt: Checks whether given parameter is either TRACE, DEBUG, INFO, WARN or ERROR.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: index: The parameter index.
# txt: Returns 0/TRUE always, but exits if the condition is not met.
# use: LOGGING.checkTraceDebugInfoWarnOrError logLevel "${logLevel}" 1;
function LOGGING.checkTraceDebugInfoWarnOrError() {
  local _logLevel="${1}"
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_logLevel}" 1
  local _index="${2}"
  checkNotEmpty index "${_index}" 2

  CHECK.checkOneOf 2 "TRACE|DEBUG|INFO|WARN|ERROR" "${_logLevel}" "TRACE DEBUG INFO WARN ERROR" "${_index}"
}

# fun: LOGGING.checkSuccessFailureOrNeutral paramValue paramIndex
# api: private
# txt: Performs a precondition check on given parameter to ensure it's either SUCCESS or FAILURE.
# opt: paramValue: The parameter value.
# opt: paramIndex: The parameter index.
# txt: Exits if the check fails; otherwise returns 0/TRUE.
# use: LOGGING.checkSuccessFailureOrNeutral "${successFailureOrNeutral}" 1 # -> throws an error if the first (1) parameter ("paramValue") is neither SUCCESS or FAILURE.
function LOGGING.checkSuccessFailureOrNeutral() {
  local _value="${1}"
  checkNotEmpty paramValue "${_value}" 1
  local _index="${2}"
  checkNotEmpty paramIndex "${_index}" 2

  CHECK.checkOneOf 1 "SUCCESS|FAILURE|NEUTRAL" "${_value}" "SUCCESS FAILURE NEUTRAL" "${_index}"
}

# fun: LOGGING.checkSuccessFailureNeutralOrInProgress paramValue paramIndex
# api: private
# txt: Performs a precondition check on given parameter to ensure it's either SUCCESS, FAILURE, NEUTRAL or IN_PROGRESS.
# opt: paramValue: The parameter value.
# opt: paramIndex: The parameter index.
# txt: Exits if the check fails; otherwise returns 0/TRUE.
# use: LOGGING.checkSuccessFailureNeutralOrInProgress "${successFailureNeutralOrInProgress}" 1 # -> throws an error if the first (1) parameter ("paramValue") is neither SUCCESS, nor FAILURE, nor NEUTRAL, nor IN_PROGRESS.
function LOGGING.checkSuccessFailureNeutralOrInProgress() {
  local _value="${1}"
  checkNotEmpty paramValue "${_value}" 1
  local _index="${2}"
  checkNotEmpty paramIndex "${_index}" 2

  CHECK.checkOneOf 1 "SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS" "${_value}" "SUCCESS FAILURE NEUTRAL IN_PROGRESS" "${_index}"
}

# fun: LOGGING.logCompletedNestedNoPop TRACE|DEBUG|INFO|WARN|ERROR SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS outcome
# api: private
# txt: Prints the result of a task, when there're nested tasks.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, NEUTRAL, IN_PROGRESS);
# opt: outcome: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.logCompletedNestedNoPop SUCCESS "done";
function LOGGING.logCompletedNestedNoPop() {
  local _level="${1}"
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1
  shift
  local _keyword="${1}"
  checkNotEmpty "SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS" "${_keyword}" 2
  LOGGING.checkSuccessFailureNeutralOrInProgress "${_keyword}" 2
  shift
  local _message="$@"
  checkNotEmpty message "${_message}" 3

  LOGGING.echoLogOutcomeNested "${_level}" "${_keyword}" "${_message}"
}

# fun: LOGGING.logCompletedNoNested SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS outcome
# api: private
# txt: Prints the result of a task.
# opt: SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS: The outcome keyword (SUCCESS, FAILURE, NEUTRAL, IN_PROGRESS).
# opt: outcome: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.logCompletedNoNested SUCCESS "done";
function LOGGING.logCompletedNoNested() {
  local _keyword="${1}"
  checkNotEmpty keyword "${_keyword}" 1
  LOGGING.checkSuccessFailureNeutralOrInProgress "${_keyword}" 1
  shift

  local _text
  _text="${@}"
  checkNotEmpty outcome "${_text}" 2

  LOGGING.echoLogOutcome "${_keyword}" "${_text}"
  LOGGING.popLog
  LOGGING.popLogLevel
  echo
  LOGGING.logToFilesAnEmptyLine
}

# fun: LOGGING.logInProgress TRACE|DEBUG|INFO|WARN|ERROR message
# api: private
# txt: Prints a log message, indicating some uncompleted task.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.logInProgress INFO "Calculating ...";
function LOGGING.logInProgress() {
  local _level="${1}"
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1
  shift

  local _message="$@"
  checkNotEmpty message "${_message}" 2

  LOGGING.setLastLogLevel "${_level}"
  LOGGING.saveLogLevel

  LOGGING.numberOfNestedInProgressTasks
  local -i _nestedTasks=$?
  if isGreaterThan ${_nestedTasks} 0; then
    LOGGING.logInProgressNested "${_message}"
  else
    LOGGING.logInProgressNoNested "${_message}"
  fi
}

# fun: LOGGING.getNestedTaskInProgressMarker
# api: private
# txt: Retrieves the text used to represent a nested task is in progress.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the text.
# use: LOGGING.getNestedTaskInProgressMarker; echo "Nested task in progress: ${RESULT}";
function LOGGING.getNestedTaskInProgressMarker() {
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" NESTED_TASK_IN_PROGRESS_MARKER
}

# fun: setNestedTaskInProgressMarker
# api: public
# txt: Specifies the text used to represent a nested task is in progress.
# opt: text: The text used as marker.
# txt: Returns 0/TRUE always.
# use: setNestedTaskInProgressMarker "....";
function setNestedTaskInProgressMarker() {
  local _text="${1}"
  checkNotEmpty text "${_text}" 1

  LOGGING.getModuleName
  DW.declareGlobalString "${RESULT}" NESTED_TASK_IN_PROGRESS_MARKER "${_text}"
}

# fun: LOGGING.logInProgressNested message
# api: private
# txt: Prints a log message, indicating some uncompleted task, when there're nested tasks.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.logInProgressNested "Calculating ...";
function LOGGING.logInProgressNested() {
  local _message="$@"
  checkNotEmpty message "${_message}" 1

  LOGGING.pushLog "${_message}"
  LOGGING.peekLogLevel
  local _level="${RESULT}"
  if isEmpty "${_level}"; then
    getLastLogLevel
    _level="${RESULT}"
  fi
  LOGGING.pushLogLevel "${_level}"
  LOGGING.getNestedTaskInProgressMarker
  local _nestedTaskInProgressMarker="${RESULT}"
  LOGGING.logCompletedNestedNoPop "${_level}" IN_PROGRESS "${_nestedTaskInProgressMarker}"
  echo
  LOGGING.logToFilesAnEmptyLine

  LOGGING.echoLogPrefix
  LOGGING.peekLog
  local _actualMessage="${RESULT}"
  getDefaultLogPrefixColor
  local _defaultLogPrefixColor="${RESULT}"
  LOGGING.setLastLogLevel "${_level}"
  echoColorizedText "${_actualMessage}" "" "${_defaultLogPrefixColor}"
  LOGGING.logToFiles "${_actualMessage}"
  LOGGING.logToFilesAnEmptyLine
}

# fun: getDefaultLogPrefixColor
# api: public
# txt: Retrieves the log prefix color by default.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the log prefix color by default.
# use: getDefaultLogPrefixColor; echo "default log prefix color: ${RESULT}";
function getDefaultLogPrefixColor() {
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" DEFAULT_LOG_PREFIX_COLOR
}

# fun: setDefaultLogPrefixColor
# api: public
# txt: Specifies the log prefix color by default.
# opt: color: The color to use by default.
# txt: Returns 0/TRUE always.
# use: setDefaultLogPrefixColor GRAY;
function setDefaultLogPrefixColor() {
  local _color="${1}"
  checkNotEmpty color "${_color}" 1

  LOGGING.getModuleName
  DW.declareGlobalString "${RESULT}" DEFAULT_LOG_PREFIX_COLOR "${_color}"
}

# fun: getDefaultLogOutcomeColor
# api: public
# txt: Retrieves the log outcome color by default.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the log outcome color by default.
# use: getDefaultLogOutcomeColor; echo "default log outcome color: ${RESULT}";
function getDefaultLogOutcomeColor() {
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" DEFAULT_LOG_OUTCOME_COLOR
}

# fun: setDefaultLogOutcomeColor
# api: public
# txt: Specifies the log outcome color by default.
# opt: color: The color to use by default.
# txt: Returns 0/TRUE always.
# use: setDefaultLogOutcomeColor GRAY;
function setDefaultLogOutcomeColor() {
  local _color="${1}"
  checkNotEmpty color "${_color}" 1

  LOGGING.getModuleName
  DW.declareGlobalString "${RESULT}" DEFAULT_LOG_OUTCOME_COLOR "${_color}"
}

# fun: LOGGING.logInProgressNoNested message
# api: private
# txt: Prints a log message, indicating some uncompleted task, when there're no nested tasks.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.logProgressNoNested "Calculating ...";
function LOGGING.logInProgressNoNested() {
  local _message="$@"
  checkNotEmpty message "${_message}" 1

  LOGGING.pushLog "${_message}"
  LOGGING.buildLogPrefix
  LOGGING.echoLogPrefix

  getDefaultLogPrefixColor
  local _defaultLogPrefixColor="${RESULT}"

  echoColorizedText "${_message}" "" "${_defaultLogPrefixColor}"
  LOGGING.logToFiles "${_message}"
  LOGGING.logToFilesAnEmptyLine
}

# fun: LOGGING.logMessage TRACE|DEBUG|INFO|WARN|ERROR message
# api: private
# txt: Prints a log message.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.logMessage INFO "A message to log";
function LOGGING.logMessage() {
  local _level="${1}"
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1
  shift
  local _message="$@"
  checkNotEmpty "message" "${_message}" 2

  LOGGING.logInProgress "${_level}" "${_message}"
  echo
  LOGGING.logToFilesAnEmptyLine
}

# fun: LOGGING.logStuff TRACE|DEBUG|INFO|WARN|ERROR [-n]? message
# api: private
# txt: Main logging logic.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# opt: -n: Whether to use a new line character at the end or not.
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: LOGGING.logStuff INFO -n "Operation in progress";
function LOGGING.logStuff() {
  local _level="${1}"
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1
  shift
  local _secondArg="${1}"
  local -i _minusN=${FALSE}
  if areEqual "-n" "${_secondArg}"; then
    _minusN=${TRUE}
    shift
  fi
  LOGGING.setLastLog "${@}"
  LOGGING.setLastLogLevel "${_level}"
  if ! isEmpty "$@"; then
    LOGGING.logInProgress "${_level}" "$@"
  fi

  if isFalse ${_minusN}; then
    echo
    LOGGING.logToFilesAnEmptyLine
    LOGGING.popLog
  fi
}

# fun: LOGGING.saveLogLevel
# api: private
# txt: Saves the log level in the stack.
# txt: Returns 0/TRUE always.
# use: LOGGING.saveLogLevel;
function LOGGING.saveLogLevel() {
  getLastLogLevel
  local _level="${RESULT}"
  LOGGING.pushLogLevel "${_level}"
  LOGGING.setLastLogLevel "${_level}"
}

# fun: LOGGING.isEmptyLogCategory category
# api: private
# txt: Checks whether given category is empty or matches LOGGING.EMPTY_CATEGORY.
# txt: Returns 0/TRUE in such case; 1/FALSE otherwise.
# use: if LOGGING.isEmptyLogCategory "${category}"; then
# use:   echo "empty log category";
# use: fi
function LOGGING.isEmptyLogCategory() {
  local _category="${1}"
  local -i _rescode=${FALSE}

  if isEmpty "${_category}" ||
    areEqual "${_category}" "${DW_LOGGING_EMPTY_LOG_CATEGORY}"; then
    _rescode=${TRUE}
  fi

  return ${_rescode}
}

# fun: LOGGING.setLastLogLevel TRACE|DEBUG|INFO|WARN|ERROR
# api: private
# txt: Annotates the level of the last logged message.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# txt: Returns 0/TRUE always.
# use: LOGGING.setLastLogLevel INFO;
function LOGGING.setLastLogLevel() {
  local _level="${1}"
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1

  LOGGING.getModuleName
  DW.setGlobalString "${RESULT}" LAST_LOG_LEVEL "${_level}"
}

# fun: getLastLogLevel
# txt: Retrieves the level of the last logged message.
# txt: Returns 0/TRUE always.
# txt: RESULT contains the log level.
# use: getLastLogLevel;
# use: echo "Last log level: ${RESULT}";
function getLastLogLevel() {
  local _result
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" LAST_LOG_LEVEL
  _result="${RESULT}"
  if isEmpty "${_result}"; then
    LOGGING.peekLogLevel
  fi
}

# fun: LOGGING.logStuffResult SUCCESS|FAILURE message
# api: private
# txt: Logs the outcome of an operation.
# opt: SUCCESS|FAILURE: The outcome.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: LOGGING.logStuffResult SUCCESS "done";
function LOGGING.logStuffResult() {
  local _outcome="${1}"
  checkNotEmpty outcome "${_outcome}" 1
  LOGGING.checkSuccessFailureOrNeutral "${_outcome}" 1
  shift
  checkNotEmpty text "${@}" 2

  LOGGING.numberOfNestedInProgressTasks
  local -i _nestedTasks=$?
  if isZero ${_nestedTasks}; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "No ongoing process to print the outcome for. Review ${FUNCNAME[2]}"
  fi
  LOGGING.logCompleted "${_outcome}" "$@"
}

# fun: LOGGING.getLogStackVariableName
# api: private
# txt: Retrieves the name of the variable containing the log stack.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the name of the variable containing the log stack.
# use: LOGGING.getLogStackVariableName; local -n logStack=${RESULT}
function LOGGING.getLogStackVariableName() {
  LOGGING.getModuleName
  DW.getGlobalVariableName "${RESULT}" LOG_STACK
}

# fun: LOGGING.numberOfNestedInProgressTasks
# api: private
# txt: Retrieves the number of "in-progress" tasks pending.
# txt: Returns such count.
# use: LOGGING.numberOfNestedInProgressTasks;
# use: local count=$?;
function LOGGING.numberOfNestedInProgressTasks() {
  LOGGING.getLogStackVariableName
  local -n _logStack=${RESULT}

  local -i _rescode=${#_logStack[@]}

  return ${_rescode}
}

# fun: LOGGING.openLogLine
# api: private
# txt: Opens the log line.
# txt: Returns 0/TRUE always.
# use: LOGGING.openLogLine;
function LOGGING.openLogLine() {
  LOGGING.getModuleName
  DW.setGlobalInt "${RESULT}" LOG_LINE_OPEN ${TRUE}
}

# fun: LOGGING.peekLog
# api: private
# txt: Peeks given message from top of the log stack.
# txt: Returns 0/TRUE if the stack contains at least the returned item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the message.
# use: if LOGGING.peekLog; then
# use:   echo "Last log: ${RESULT}";
# use: fi
function LOGGING.peekLog() {
  local -i _rescode
  local _result=""

  LOGGING.getLogStackVariableName
  local -n _logStack=${RESULT}

  local -i _len=${#_logStack[@]}
  local -i _newLen
  if isGreaterThan ${_len} 0; then
    _newLen=$((${_len} - 1))
    _result="${_logStack[${_newLen}]}"
    _rescode=$?
  else
    _rescode=${FALSE}
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}"
  fi

  return ${_rescode}
}

# fun: setLogPrefixCategorySeparator separator
# api: public
# txt: Specifies what to use to separate log categories in the log prefix.
# opt: separator: The separator.
# txt: Returns 0/TRUE always.
# use: setLogPrefixCategorySeparator ":";
function setLogPrefixCategorySeparator() {
  local _separator="${1}"
  checkNotEmpty separator "${_separator}" 1

  LOGGING.getModuleName
  DW.declareGlobalString "${RESULT}" LOG_PREFIX_CATEGORY_SEPARATOR "${_separator}"
}

# fun: LOGGING.getLogPrefixCategorySeparator separator
# api: private
# txt: Retrieves the category separator in the log prefix.
# txt: Returns 0/TRUE always.
# use: LOGGING.getLogPrefixCategorySeparator;
# use: echo "Separator: ${RESULT}";
function LOGGING.getLogPrefixCategorySeparator() {
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" LOG_PREFIX_CATEGORY_SEPARATOR
  local _result="${RESULT}"

  if isEmpty "${_result}"; then
    export RESULT=":"
  fi

  return ${TRUE}
}

# fun: LOGGING.peekLogCategory
# api: private
# txt: Peeks given category from the log category stack.
# txt: Returns 0/TRUE if the stack contained at least the returned item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the category.
# use: if LOGGING.peekLogCategory; then
# use:   echo "Last log category: ${RESULT}";
# use: fi
function LOGGING.peekLogCategory() {
  local -i _rescode
  local _result=""

  local -i _len=${#FUNCNAME[@]}

  if isGreaterThan ${_len} 0; then
    local -i _newLen=$((${_len} - 1))
    _result="${FUNCNAME[${_newLen}]}"
    _rescode=$?
  else
    _rescode=${FALSE}
  fi

  if areEqual "${_result}" "${DW_LOGGING_EMPTY_LOG_CATEGORY}"; then
    _result=""
  fi

  if isEmpty "${_result}"; then
    _rescode=${FALSE}
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}"
  else
    export RESULT=""
  fi

  return ${_rescode}
}

# fun: LOGGING.getLogLevelStackVariableName
# api: private
# txt: Retrieves the log level stack variable name.
# txt: Returns 0/TRUE always.
# use: LOGGING.getLogLevelStackVariableName;
# use: local -n logLevelStack=${RESULT};
function LOGGING.getLogLevelStackVariableName() {
  LOGGING.getModuleName
  DW.getGlobalVariableName "${RESULT}" LOG_LEVEL_STACK
}

# fun: LOGGING.peekLogLevel
# api: private
# txt: Peeks given level from the log level stack.
# txt: Returns 0/TRUE if the stack contained at least the returned item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the level.
# use: if LOGGING.peekLogLevel; then
# use:   echo "Last log level: ${RESULT}";
# use: fi
function LOGGING.peekLogLevel() {
  local -i _rescode
  local _result=""

  LOGGING.getLogLevelStackVariableName
  local -n _logLevelStack=${RESULT}

  local -i _len=${#_logLevelStack[@]}

  if [ ${_len} -gt 0 ]; then
    local -i _newLen=$((${_len} - 1))
    _result="${_logLevelStack[${_newLen}]}"
    _rescode=$?
  else
    _rescode=${FALSE}
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}"
  fi

  return ${_rescode}
}

# fun: LOGGING.popLog
# api: private
# txt: Pops given message from the log stack.
# txt: Returns 0/TRUE if the stack contained at least the popped item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the popped message.
# use: if LOGGING.popLog; then
# use:   echo "Last log: ${RESULT}";
# use: fi
function LOGGING.popLog() {
  local -i _rescode
  local _result=""

  LOGGING.getLogStackVariableName
  local -n _logStack=${RESULT}

  local -i _len=${#_logStack[@]}

  if [ ${_len} -gt 0 ]; then
    local -i _newLen=$((_len - 1))
    _result="${_logStack[${_newLen}]}"
    LOGGING.setLastLog "${_result}"
    eval "unset _logStack[${_newLen}]"
    _rescode=$?
  else
    _rescode=${FALSE}
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}"
  fi

  return ${_rescode}
}

# fun: LOGGING.popLogLevel
# api: private
# txt: Pops given level from the log level stack.
# txt: Returns 0/TRUE if the stack contained at least the popped item; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the popped level.
# use: if LOGGING.popLogLevel; then
# use:   echo "Last log level: ${RESULT}";
# use: fi
function LOGGING.popLogLevel() {
  local -i _rescode

  LOGGING.getLogLevelStackVariableName
  local -n _logLevelStack=${RESULT}
  local -i _len=${#_logLevelStack[@]}

  if isGreaterThan ${_len} 0; then
    local -i _newLen=$((${_len} - 1))
    export RESULT="${_logLevelStack[${_newLen}]}"
    eval "unset _logLevelStack[${_newLen}]"
    _rescode=$?
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: LOGGING.pushLog message
# api: private
# txt: Pushes given message to the log stack.
# opt: message: The message to push.
# txt: Returns 0/TRUE always.
# use: LOGGING.pushLog "Operation in progress";
function LOGGING.pushLog() {
  checkNotEmpty message "$*" 1

  LOGGING.getLogStackVariableName
  local -n _logStack=${RESULT}
  _logStack[${#_logStack[@]}]="$*"
}

# fun: LOGGING.pushLogLevel TRACE|DEBUG|INFO|WARN|ERROR
# api: private
# txt: Pushes given level to the log level stack.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The level to push.
# txt: Returns 0/TRUE always.
# use: LOGGING.pushLogLevel INFO;
function LOGGING.pushLogLevel() {
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${1}" 1
  LOGGING.getLogLevelStackVariableName
  local -n _logLevelStack=${RESULT}
  _logLevelStack[${#_logLevelStack[@]}]="$*"
}

# fun: LOGGING.retrieveKeywordColor SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS defaultColor
# api: private
# txt: Retrieves the color for a given keyword.
# opt: SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS: The keyword (SUCCESS, FAILURE, NEUTRAL, IN_PROGRESS).
# opt: defaultColor: The default color. Optional.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the associated color.
# use: LOGGING.retrieveKeywordColor SUCCESS GREEN;
# use: echo "Color -> ${RESULT}";
function LOGGING.retrieveKeywordColor() {
  local _keyword="${1}"
  checkNotEmpty keyword "${_keyword}" 1
  LOGGING.checkSuccessFailureNeutralOrInProgress "${_keyword}" 2

  getNoColor
  local _noColor="${RESULT}"
  local _defaultColor="${2:-${_noColor}}"

  local _result

  getSuccessColor
  local _successColor="${RESULT}"
  getFailureColor
  local _failureColor="${RESULT}"
  getNeutralColor
  local _neutralColor="${RESULT}"
  getInProgressColor
  local _inProgressColor="${RESULT}"

  case ${_keyword} in
  SUCCESS | "${SUCCESS}")
    _result="${_successColor}"
    ;;
  FAILURE | "${FAILURE}" | "${FAILED}" | "FAILED" | "failed" | "FAIL" | "fail" | "${KO}")
    _result="${_failureColor}"
    ;;
  NEUTRAL | "${NEUTRAL}")
    _result="${_neutralColor}"
    ;;
  IN_PROGRESS | "${IN_PROGRESS}")
    _result="${_inProgressColor}"
    ;;
  *)
    _result="${_defaultColor}"
    ;;
  esac

  export RESULT="${_result}"
}

# fun: LOGGING.retrieveLogNamespace
# api: private
# txt: Retrieves the log namespace.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the log namespace.
# use: LOGGING.retrieveLogNamespace;
# use: echo "namespace: ${RESULT}";
function LOGGING.retrieveLogNamespace() {
  getLogNamespace
  local _namespace="${RESULT}"
  DW.getScriptName
  local _scriptName="${RESULT}"

  local _result

  if isEmpty "${_namespace}"; then
    if isEmpty "${_scriptName}"; then
      _result="?"
    else
      _result="$(basename ${_scriptName} .sh)"
    fi
  fi

  export RESULT="${_result}"
}

# fun: LOGGING.processLogOutcomeColors SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS
# api: private
# txt: Processes the log outcome colors based on given outcome and text.
#      Call LOGGING.getLogOutcomeColorsVariableName afterwards to use them.
# opt: SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS: The keyword (SUCCESS, FAILURE, NEUTRAL, IN_PROGRESS).
# txt: Returns 0/TRUE always.
# use: LOGGING.processLogOutcomeColors SUCCESS "done";
function LOGGING.processLogOutcomeColors() {
  local _keyword="${1}"
  checkNotEmpty "SUCCESS|FAILURE|NEUTRAL|IN_PROGRESS" "${_keyword}" 1
  LOGGING.checkSuccessFailureNeutralOrInProgress "${_keyword}" 1

  LOGGING.retrieveKeywordColor "${_keyword}"
  local _keywordColor="${RESULT}"

  LOGGING.getLogOutcomeColorsVariableName
  local -n _logOutcomeColors=${RESULT}
  local -i _len=$((${#_logOutcomeColors[@]} - 1))

  local _oldIFS="${IFS}"
  IFS="${DWIFS}"
  local -i _i
  for _i in $(seq 0 1 ${_len}); do
    IFS="${_oldIFS}"
    _logOutcomeColors[${_i}]="${_logOutcomeColors[${_i}]}"
  done
  IFS="${_oldIFS}"

  LOGGING.getOutcomeTextPositionInLogOutcome
  local -i _outcomeTextPosition=${RESULT}
  _logOutcomeColors[${_outcomeTextPosition}]="${_keywordColor}"
}

# fun: LOGGING.processLogOutcomeTokens text
# api: private
# txt: Processes the tokens composing the log outcome.
# opt: text: The outcome text.
# txt: Returns 0/TRUE always.
# use: LOGGING.processLogOutcomeTokens "done";
function LOGGING.processLogOutcomeTokens() {
  local _text="${1}"
  checkNotEmpty text "${_text}" 1

  LOGGING.getLogOutcomeTokensVariableName
  local -n _logOutcomeTokens=${RESULT}
  local -i _len=$((${#_logOutcomeTokens[@]} - 1))

  local _oldIFS="${IFS}"
  IFS="${DWIFS}"
  local -i _i
  for _i in $(seq 0 1 ${_len}); do
    IFS="${_oldIFS}"
    _logOutcomeTokens[${_i}]="${_logOutcomeTokens[${_i}]}"
  done
  IFS="${_oldIFS}"

  LOGGING.getOutcomeTextPositionInLogOutcome
  local -i _outcomeTextPosition=${RESULT}
  _logOutcomeTokens[${_outcomeTextPosition}]="${_text}"
}

# fun: LOGGING.retrieveLogPrefixLevelToken TRACE|DEBUG|INFO|WARN|ERROR
# api: private
# txt: Retrieves the log prefix token, depending on the given log level.
# opt: TRACE|DEBUG|INFO|WARN|ERROR: The log level.
# txt: Returns 0/TRUE if the token is defined; 1/FALSE otherwise.
# txt: if the function returns 0/TRUE, The variable RESULT contains the log prefix token.
# use: if LOGGING.retrieveLogPrefixLevelToken TRACE; then
# use:   echo "Log prefix token: ${RESULT}";
# use: fi
function LOGGING.retrieveLogPrefixLevelToken() {
  local _level="${1}"
  checkNotEmpty "TRACE|DEBUG|INFO|WARN|ERROR" "${_level}" 1
  LOGGING.checkTraceDebugInfoWarnOrError "${_level}" 1

  local _result
  local -i _rescode=${TRUE}

  case ${_level} in
  "TRACE")
    LOGGING.getTraceLogPrefixToken
    _result="${RESULT}"
    ;;
  "DEBUG")
    LOGGING.getDebugLogPrefixToken
    _result="${RESULT}"
    ;;
  "INFO")
    LOGGING.getInfoLogPrefixToken
    _result="${RESULT}"
    ;;
  "WARN")
    LOGGING.getWarnLogPrefixToken
    _result="${RESULT}"
    ;;
  "ERROR")
    LOGGING.getErrorLogPrefixToken
    _result="${RESULT}"
    ;;
  *)
    LOGGING.getInfoLogPrefixToken
    _result="${RESULT}"
    _rescode=${FALSE}
    ;;
  esac

  if isTrue ${_rescode}; then
    export RESULT="${_result}"
  fi

  return ${_rescode}
}

# fun: LOGGING.isInternal category
# api: private
# txt: Checks whether given category is internal or not.
# opt: category: The category.
# txt: Returns 0/TRUE if the category is internal; 1/FALSE otherwise.
# use: if LOGGING.isInternal "${category}"; then
# use:   echo "internal category";
# use: fi
function LOGGING.isInternal() {
  local _category="${1}"
  checkNotEmpty category "${_category}" 1

  local _rescode=${FALSE}

  if areEqual "${_category}" "${DW_LOGGING_EMPTY_LOG_CATEGORY}" ||
    startsWith "${_category}" "LOGGING." ||
    startsWith "${_category}" "DRYWIT." ||
    areEqual "${_category}" "logInfo" ||
    areEqual "${_category}" "logDebug"; then
    _rescode=${TRUE}
  fi

  if isFalse ${_rescode}; then
    LOGGING.getInvalidLogCategoriesVariableName
    local -n _invalidLogCategories="${RESULT}"

    if arrayContains "${_category}" "${_invalidLogCategories[@]}"; then
      _rescode=${TRUE}
    fi
  fi

  return ${_rescode}

}
# fun: LOGGING.buildLogCategoryPrefix separator
# api: private
# txt: Builds the category part of the log category prefix.
# opt: separator: The category separator.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the category part of the log prefix.
# use: LOGGING.buildLogCategoryPrefix ":";
# use: echo "log categories: ${RESULT}";
function LOGGING.buildLogCategoryPrefix() {
  local _separator="${1}"
  checkNotEmpty separator "${_separator}" 1

  local _result=""
  local _oldIFS="${IFS}"

  local -i _len=${#FUNCNAME[@]}
  local _i _maxIndex=$((_len - 2))

  IFS="${DWIFS}"
  local -i _i
  for _i in $(seq ${_maxIndex} -1 0); do
    IFS="${_oldIFS}"
    local _category="${FUNCNAME[${_i}]}"
    if isNotEmpty "${_category}" &&
      ! LOGGING.isInternal "${_category}"; then
      if isNotEmpty "${_result}"; then
        _result="${_result}${_separator}"
      fi
      _result="${_result}${_category}"
    fi
  done
  IFS="${_oldIFS}"

  if isEmpty "${_result}"; then
    LOGGING.buildDefaultLogCategory
    _result="${RESULT}"
  fi

  export RESULT="${_result}"

  return ${TRUE}
}

# fun: LOGGING.processLogPrefixTokens
# api: private
# txt: Processes the tokens composing the log prefix.
# txt: Returns 0/TRUE always.
# use: LOGGING.processLogPrefixTokens;
function LOGGING.processLogPrefixTokens() {
  LOGGING.retrieveLogTimestamp
  local _timestamp="${RESULT}"

  LOGGING.retrieveLogNamespace
  local _namespace="${RESULT}"

  LOGGING.getLogPrefixCategorySeparator
  LOGGING.buildLogCategoryPrefix "${RESULT}"
  local _categoryPrefix="${RESULT}"

  LOGGING.retrieveCurrentLogLevel
  local _level="${RESULT}"
  LOGGING.retrieveLogPrefixLevelToken "${_level}"
  local _levelPrefix="${RESULT}"

  if isEmpty "${_levelPrefix}"; then
    _levelPrefix="-"
  fi

  LOGGING.processLogPrefixTokensWithValues "${_timestamp}" "${_namespace}" "${_categoryPrefix}" "${_levelPrefix}"
}

# fun: LOGGING.processLogPrefixTokensWithValues timestamp namespace
# api: private
# txt: Processes the tokens composing the log prefix.
# opt: timestamp: The timestamp.
# opt: namespace: The namespace.
# opt: categoryPrefix: The category prefix.
# opt: levelPrefix: The level prefix.
# txt: Returns 0/TRUE always.
# use: LOGGING.processLogPrefixTokensWithValues "2020/06/10 10:15:53" "my-script" "func1:func2" "O";
function LOGGING.processLogPrefixTokensWithValues() {
  local _timestamp="${1}"
  checkNotEmpty timestamp "${_timestamp}" 1
  local _namespace="${2}"
  checkNotEmpty namespace "${_namespace}" 2
  local _categoryPrefix="${3}"
  checkNotEmpty categoryPrefix "${_categoryPrefix}" 3
  local _levelPrefix="${4}"
  checkNotEmpty levelPrefix "${_levelPrefix}" 4

  LOGGING.getLogPrefixTokensVariableName
  local -n _logPrefixTokens=${RESULT}

  local -i _lastIndex=$((${#_logPrefixTokens[@]} - 1))

  local _oldIFS="${IFS}"
  IFS="${DWIFS}"
  local -i _i
  for _i in $(seq 0 1 ${_lastIndex}); do
    IFS="${_oldIFS}"
    _logPrefixTokens[${_i}]="${_logPrefixTokens[${_i}]}"
  done
  IFS="${_oldIFS}"

  LOGGING.getTimestampPositionInLogPrefix
  local -i _timestampPosition=${RESULT}
  _logPrefixTokens[${_timestampPosition}]="${_timestamp}"

  LOGGING.getNamespacePositionInLogPrefix
  local -i _namespacePosition=${RESULT}
  _logPrefixTokens[${_namespacePosition}]="${_namespace}"

  LOGGING.getCategoryPositionInLogPrefix
  local -i _categoryPosition=${RESULT}
  _logPrefixTokens[${_categoryPosition}]="${_categoryPrefix}"

  LOGGING.getLevelPositionInLogPrefix
  local -i _levelPosition=${RESULT}
  _logPrefixTokens[${_levelPosition}]="${_levelPrefix}"
}

# fun: getLogTimestampFormat
# api: public
# txt: Retrieves the timestamp format used for logging.
# txt: Use setLogTimestampFormat to modify the timestamp format.
# txt: Returns 0/TRUE always.
# use: LOGGING.getLogTimestampFormat;
# use: echo "The log timestamp format is ${RESULT}";
function getLogTimestampFormat() {
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" LOG_TIMESTAMP_FORMAT
}

# fun: setLogTimestampFormat
# api: public
# txt: Retrieves the timestamp format used for logging.
# txt: Use setLogTimestampFormat to modify the timestamp format.
# txt: Returns 0/TRUE always.
# use: LOGGING.getLogTimestampFormat;
# use: echo "The log timestamp format is ${RESULT}";
function setLogTimestampFormat() {
  local _format="${1}"
  checkNotEmpty format "${_format}" 1

  LOGGING.getModuleName
  DW.declareGlobalString "${RESULT}" LOG_TIMESTAMP_FORMAT "${_format}"
}

# fun: LOGGING.retrieveLogTimestamp
# api: private
# txt: Retrieves the timestamp used for logging.
# txt: Override LOG_TIMESTAMP to modify the timestamp format.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the timestamp.
# use: LOGGING.retrieveLogTimestamp;
# use: echo "The log timestamp is ${RESULT}";
function LOGGING.retrieveLogTimestamp() {
  getLogTimestampFormat
  local _format="${RESULT}"
  if isEmpty "${_format}"; then
    _format="+%Y/%m/%d %H:%M:%S"
  fi
  export RESULT="$(date "${_format}")"
}

# fun: LOGGING.getOutcomeTextPositionInLogOutcome
# api: private
# txt: Retrieves the position of the outcome token in the log outcome colors array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the outcome text position.
# use: LOGGING.getOutcomeTextPositionInLogOutcome;
# use: echo "outcome text -> ${RESULT}";
function LOGGING.getOutcomeTextPositionInLogOutcome() {
  LOGGING.getModuleName
  DW.getGlobalInt "${RESULT}" LOG_OUTCOME_TEXT_POSITION
}

# fun: setOutcomeTextPositionInLogOutcome position
# api: public
# txt: Specifies the position of the outcome token in the log outcome colors array.
# opt: position: The position of the outcome token.
# txt: Returns 0/TRUE always.
# use: setOutcomeTextPositionInLogOutcome 1;
function setOutcomeTextPositionInLogOutcome() {
  local -i _position="${1}"
  checkNotEmpty position "${_position}" 1

  LOGGING.getModuleName
  DW.declareGlobalInt "${RESULT}" LOG_OUTCOME_TEXT_POSITION ${_position}
}

# fun: LOGGING.getTimestampPositionInLogPrefix
# api: private
# txt: Retrieves the position of the timestamp in the log prefix tokens array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the timestamp position.
# use: LOGGING.getTimestampPositionInLogPrefix;
# use: echo "timestamp -> ${RESULT}";
function LOGGING.getTimestampPositionInLogPrefix() {
  LOGGING.getModuleName
  DW.getGlobalInt "${RESULT}" LOG_PREFIX_TIMESTAMP_POSITION
}

# fun: setTimestampPositionInLogPrefix position
# api: public
# txt: Specifies the position of the timestamp token in the log prefix colors array.
# opt: position: The position of the timestamp token.
# txt: Returns 0/TRUE always.
# use: setTimestampPositionInLogPrefix 1;
function setTimestampPositionInLogPrefix() {
  local -i _position="${1}"
  checkNotEmpty position "${_position}" 1

  LOGGING.getModuleName
  DW.declareGlobalInt "${RESULT}" LOG_PREFIX_TIMESTAMP_POSITION ${_position}
}

# fun: LOGGING.getNamespacePositionInLogPrefix
# api: private
# txt: Retrieves the position of the namespace in the log prefix tokens array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the namespace position.
# use: LOGGING.getNamespacePositionInLogPrefix;
# use: echo "namespace -> ${RESULT}";
function LOGGING.getNamespacePositionInLogPrefix() {
  LOGGING.getModuleName
  DW.getGlobalInt "${RESULT}" LOG_PREFIX_NAMESPACE_POSITION
}

# fun: setNamespacePositionInLogPrefix position
# api: public
# txt: Specifies the position of the namespace token in the log prefix colors array.
# opt: position: The position of the namespace token.
# txt: Returns 0/TRUE always.
# use: setNamespacePositionInLogPrefix 1;
function setNamespacePositionInLogPrefix() {
  local _position="${1}"
  checkNumber position "${_position}" 1

  LOGGING.getModuleName
  DW.declareGlobalInt "${RESULT}" LOG_PREFIX_NAMESPACE_POSITION ${_position}
}

# fun: LOGGING.getCategoryPositionInLogPrefix
# api: private
# txt: Retrieves the position of the category in the log prefix tokens array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the category position.
# use: LOGGING.getCategoryPositionInLogPrefix;
# use: echo "category -> ${RESULT}";
function LOGGING.getCategoryPositionInLogPrefix() {
  LOGGING.getModuleName
  DW.getGlobalInt "${RESULT}" LOG_PREFIX_CATEGORY_POSITION
}

# fun: setCategoryPositionInLogPrefix position
# api: public
# txt: Specifies the position of the category token in the log prefix colors array.
# opt: position: The position of the category token.
# txt: Returns 0/TRUE always.
# use: setCategoryPositionInLogPrefix 1;
function setCategoryPositionInLogPrefix() {
  local _position="${1}"
  checkNumber position "${_position}" 1

  LOGGING.getModuleName
  DW.declareGlobalInt "${RESULT}" LOG_PREFIX_CATEGORY_POSITION ${_position}
}

# fun: LOGGING.getLevelPositionInLogPrefix
# api: private
# txt: Retrieves the position of the level in the log prefix tokens array.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the level position.
# use: LOGGING.getLevelPositionInLogPrefix;
# use: echo "level -> ${RESULT}";
function LOGGING.getLevelPositionInLogPrefix() {
  LOGGING.getModuleName
  DW.getGlobalInt "${RESULT}" LOG_PREFIX_LEVEL_POSITION
}

# fun: setLevelPositionInLogPrefix position
# api: public
# txt: Specifies the position of the level token in the log prefix colors array.
# opt: position: The position of the level token.
# txt: Returns 0/TRUE always.
# use: setLevelPositionInLogPrefix 1;
function setLevelPositionInLogPrefix() {
  local -i _position="${1}"
  checkNumber position "${_position}" 1

  LOGGING.getModuleName
  DW.declareGlobalInt "${RESULT}" LOG_PREFIX_LEVEL_POSITION ${_position}
}

# fun: LOGGING.setLastLog message?
# api: private
# txt: Annotates the last log message.
# opt: message: The message. Optional.
# txt: Returns 0/TRUE always.
# use: LOGGING.setLastLog "Operation in progress";
function LOGGING.setLastLog() {
  LOGGING.getModuleName
  DW.setGlobalString "${RESULT}" LAST_LOG "${@}"
}

# fun: LOGGING.getLastLog
# api: private
# txt: Retrieves the last log message.
# txt: Returns 0/TRUE always.
# txt: RESULT contains the last log.
# use: LOGGING.getLastLog;
# use: echo "Last log: ${RESULT}";
function LOGGING.getLastLog() {
  LOGGING.getModuleName
  DW.getGlobalString "${RESULT}" LAST_LOG
}

# fun: logInfo message
# api: public
# txt: Logs a message as "info".
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logInfo "Operation in progress";
function logInfo() {
  if isInfoEnabled; then
    checkNotEmpty message "${1}" 1
    LOGGING.logStuff INFO "$@"
  fi
}

# fun: logInfoFromStdin
# api: public
# txt: Logs given message under the "debug" level.
# opt: [stdin]: The message to log.
# txt: Returns 0/TRUE always.
# use: logInfoFromStdin <<<"Operation in progress";
function logInfoFromStdin() {
  if isInfoEnabled; then
    local _line
    while read _line; do
      if isNotEmpty "${_line}"; then
        LOGGING.logStuff INFO "${_line}"
      fi
    done
  fi
}

# fun: logInfoFile file
# api: public
# txt: Logs the contents of a file as "info".
# opt: file: The file containing the text to log.
# txt: Returns 0/TRUE always.
# use: logInfoFile /tmp/my-log.txt;
function logInfoFile() {
  if isInfoEnabled; then
    checkNotEmpty file "${1}" 1
    local line
    cat "${1}" | while IFS='' read -r line; do
      LOGGING.logStuff INFO "${line}"
    done
  fi
}

# fun: logInfoResult SUCCESS|FAILURE message
# api: public
# txt: Logs the outcome of an operation as "info".
# opt: SUCCESS|FAILURE: The outcome.
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logInfoResult SUCCESS "done";
function logInfoResult() {
  local _outcome="${1}"
  shift
  local _message="${@}"

  if isInfoEnabled; then
    checkNotEmpty "SUCCESS|FAILURE" "${_outcome}" 1
    LOGGING.checkSuccessFailureOrNeutral "${_outcome}" 1
    checkNotEmpty message "${_message}" 2

    LOGGING.logStuffResult "${_outcome}" "${_message}"
  fi
}

# fun: logTrace message
# api: public
# txt: Logs given message under the "trace" level.
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logTrace "Operation in progress";
function logTrace() {
  if isTraceEnabled; then
    checkNotEmpty message "${1}" 1
    LOGGING.logStuff TRACE "$@"
  fi
}

# fun: logTraceFromStdin
# api: public
# txt: Logs given message under the "debug" level.
# opt: [stdin]: The message to log.
# txt: Returns 0/TRUE always.
# use: logTraceFromStdin <<<"Operation in progress";
function logTraceFromStdin() {
  if isTraceEnabled; then
    local _line
    while read _line; do
      if isNotEmpty "${_line}"; then
        LOGGING.logStuff TRACE "${_line}"
      fi
    done
  fi
}

# fun: logTraceFile file
# api: public
# txt: Logs the contents of given file, under the "trace" level.
# opt: file: The file to log.
# txt: Returns 0/TRUE always.
# use: logTraceFile /tmp/my-log.txt;
function logTraceFile() {
  if isTraceEnabled; then
    local _file="${1}"
    checkNotEmpty file "${_file}" 1
    local line
    cat "${_file}" 2>/dev/null | while IFS='' read -r line; do
      LOGGING.logStuff TRACE "${line}"
    done
  fi
}

# fun: logTraceResult SUCCESS|FAILURE message
# api: public
# txt: Logs given text as a log result, under the "trace" level.
# opt: SUCCESS|FAILURE: The keyword.
# opt: message: The result message to log.
# txt: Returns 0/TRUE always.
# use: logTraceResult SUCCESS "Operation completed";
function logTraceResult() {
  local _outcome="${1}"
  shift
  local _message="${@}"

  if isTraceEnabled; then
    checkNotEmpty outcome "${_outcome}" 1
    LOGGING.checkSuccessFailureOrNeutral "${_outcome}" 1
    checkNotEmpty message "${_message}" 2
    LOGGING.logStuffResult "${_outcome}" "${_message}"
  fi
}

# fun: resolveVerbosity
# api: public
# txt: Retrieves the verbosity flag.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains '-vv' if trace is enabled; '-v' if debug is enabled; empty string otherwise.
# use: resolveVerbosity;
function resolveVerbosity() {
  local result=""

  if isTraceEnabled; then
    result="-vv"
  elif isDebugEnabled; then
    result="-v"
  elif isInfoEnabled; then
    result=""
  fi

  export RESULT="${result}"
}

# fun: setDebugEnabled
# api: public
# txt: Enables the "debug" level.
# txt: Returns 0/TRUE always.
# use: setDebugEnabled
function setDebugEnabled() {
  LOGGING.getModuleName
  DW.setGlobalInt "${RESULT}" LOG_DEBUG ${TRUE}
  setInfoEnabled
}

# fun: setInfoEnabled
# api: public
# txt: Enables the "info" level.
# txt: Returns 0/TRUE always.
# use: setInfoEnabled;
function setInfoEnabled() {
  setQuietMode ${FALSE}
  LOGGING.getModuleName
  DW.setGlobalInt "${RESULT}" LOG_INFO ${TRUE}
}

# fun: setLogNamespace namespace
# api: public
# txt: Sets the log namespace.
# opt: namespace: The namespace.
# txt: Returns 0/TRUE always.
# use: setLogNamespace "processing";
function setLogNamespace() {
  local _namespace="${1}"
  checkNotEmpty namespace "${_namespace}" 1

  LOGGING.getModuleName
  DW.setGlobalString "${RESULT}" LOG_NAMESPACE "${_namespace}"
}

# fun: setQuietMode mode
# api: public
# txt: Sets the quiet mode on or off.
# opt: mode: The mode (0/TRUE or 1/FALSE).
# txt: Returns 0/TRUE always.
# use: setQuietMode ${TRUE};
function setQuietMode() {
  local _mode="${1}"
  checkNotEmpty mode "${_mode}" 1

  LOGGING.getModuleName
  DW.setGlobalInt "${RESULT}" LOG_QUIET ${_mode}
}

# fun: setTraceEnabled
# api: public
# txt: Enables the trace level.
# txt: Returns 0/TRUE always.
# use: setTraceEnabled;
function setTraceEnabled() {
  LOGGING.getModuleName
  DW.setGlobalInt "${RESULT}" LOG_TRACE ${TRUE}
  setDebugEnabled
}

# fun: logToFile file
# api: public
# txt: Appends all logging to given file.
# opt: file: The file.
# txt: Returns 0/TRUE if the file exists and is readable; 1/FALSE otherwise.
# use: if logToFile "/tmp/logging"; then
# use:   echo "Logging in /tmp/logging";
# use: fi
function logToFile() {
  local _file="${1}"
  checkNotEmpty file "${_file}" 1

  local -i _rescode=${FALSE}

  logInfo -n "Adding log file ${_file}"
  if fileExists "${_file}" && fileIsReadable "${_file}"; then
    _rescode=${TRUE}
    LOGGING.getLogFilesVariableName
    local -n _logFiles="${RESULT}"

    _logFiles[${#_logFiles[@]}]="${_file}"
    logInfoResult SUCCESS "done"
  else
    logInfoResult FAILURE "failed"
  fi

  return ${_rescode}
}

# fun: LOGGING.getLogFilesVariableName
# api: private
# txt: Retrieves the name of the variable containing the log files.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the variable containing the log files.
# use: LOGGING.getLogFilesVariableName; local -n logFiles=${RESULT}
function LOGGING.getLogFilesVariableName() {
  LOGGING.getModuleName
  DW.getGlobalVariableName "${RESULT}" LOG_FILES
}

# fun: LOGGING.logToFiles msg+
# api: private
# txt: Appends a log message to all defined logging files.
# opt: msg: The message to log.
# txt: Returns 0/TRUE always.
# use: LOGGING.logToFiles "Logging sample";
function LOGGING.logToFiles() {
  local _msg="${@}"
  checkNotEmpty msg "${_msg}" 1

  if isLogToFilesEnabled; then
    LOGGING.getLogFilesVariableName
    local -n _logFiles
    _logFiles="${RESULT}"

    local _oldIFS="${IFS}"
    IFS="${DWIFS}"
    local _file
    for _file in ${_logFiles[@]}; do
      IFS="${_oldIFS}"
      echo -n "${_msg}" >>"${_file}" 2>/dev/null
    done
    IFS="${_oldIFS}"
  fi

  return ${TRUE}
}

# fun: LOGGING.logToFilesAnEmptyLine
# api: private
# txt: Appends an empty line to all defined logging files.
# txt: Returns 0/TRUE always.
# use: LOGGING.logToFilesAnEmptyLine;
function LOGGING.logToFilesAnEmptyLine() {

  if isLogToFilesEnabled; then
    LOGGING.getLogFilesVariableName
    local -n _logFiles="${RESULT}"

    local _oldIFS="${IFS}"
    IFS="${DWIFS}"
    local _file
    for _file in ${_logFiles[@]}; do
      IFS="${_oldIFS}"
      echo >>"${_file}" 2>/dev/null
    done
    IFS="${_oldIFS}"
  fi

  return ${TRUE}
}

# fun: isLogToFilesEnabled
# api: public
# txt: Checks if logging to files is enabled or not.
# txt: Returns 0/TRUE if it's enabled; 1/FALSE otherwise.
# use: if isLogToFilesEnabled; then
# use:   echo "log to files is enabled";
# use: fi
function isLogToFilesEnabled() {
  #  LOGGING.getModuleName;
  #  DW.getGlobalInt "${RESULT}" LOG_TO_FILES;
  return ${FALSE}
}

# fun: LOGGING.getLogWarn
# api: private
# txt: Retrieves the LOG_WARN value.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the value of LOG_WARN.
# use: LOGGING.getLogWarn;
# use: local logWarn=${RESULT};
function LOGGING.getLogWarn() {
  LOGGING.getModuleName
  DW.getGlobalInt "${RESULT}" LOG_WARN ${TRUE}
}

# fun: isWarnEnabled
# api: public
# txt: Checks whether the "warn" level is enabled.
# txt: Returns 0/TRUE in such case; 1/FALSE otherwise.
# use: if isWarnEnabled; then
# use:   ...;
# use: fi
function isWarnEnabled() {
  local -i _rescode

  if isQuietMode; then
    _rescode=${FALSE}
  else
    LOGGING.getLogWarn
    _rescode=${RESULT}
  fi

  return ${_rescode}
}

# fun: isLowerThanWarnEnabled
# api: public
# txt: Checks whether the enabled log level is lower than "warn".
# txt: Returns 0/TRUE in such case; 1/FALSE otherwise.
# use: if isLowerThanWarnEnabled; then
# use:   ...;
# use: fi
function isLowerThanWarnEnabled() {
  if isInfoEnabled || isDebugEnabled || isTraceEnabled; then
    return ${TRUE}
  else
    return ${FALSE}
  fi
}

# fun: logWarn message
# api: public
# txt: Logs a message as "warn".
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logWarn "Operation in progress";
function logWarn() {
  if isWarnEnabled; then
    checkNotEmpty message "${1}" 1
    LOGGING.logStuff WARN "$@"
  fi
}

# fun: logWarnFromStdin
# api: public
# txt: Logs given message under the "debug" level.
# opt: [stdin]: The message to log.
# txt: Returns 0/TRUE always.
# use: logWarnFromStdin <<<"Operation in progress";
function logWarnFromStdin() {
  if isWarnEnabled; then
    local _line
    while read _line; do
      if isNotEmpty "${_line}"; then
        LOGGING.logStuff WARN "${_line}"
      fi
    done
  fi
}

# fun: logWarnFile file
# api: public
# txt: Logs the contents of a file as "warn".
# opt: file: The file containing the text to log.
# txt: Returns 0/TRUE always.
# use: logWarnFile /tmp/my-log.txt;
function logWarnFile() {
  if isWarnEnabled; then
    checkNotEmpty file "${1}" 1
    local line
    cat "${1}" | while IFS='' read -r line; do
      LOGGING.logStuff WARN "${line}"
    done
  fi
}

# fun: logWarnResult SUCCESS|FAILURE message
# api: public
# txt: Logs the outcome of an operation as "warn".
# opt: SUCCESS|FAILURE: The outcome.
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logWarnResult SUCCESS "done";
function logWarnResult() {
  local _outcome="${1}"
  shift
  local _message="${@}"

  if isWarnEnabled; then
    checkNotEmpty "SUCCESS|FAILURE" "${_outcome}" 1
    LOGGING.checkSuccessFailureOrNeutral "${_outcome}" 1
    checkNotEmpty message "${_message}" 2

    LOGGING.logStuffResult "${_outcome}" "${_message}"
  fi
}

# fun: LOGGING.getLogError
# api: private
# txt: Retrieves the LOG_ERROR value.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the value of LOG_ERROR.
# use: LOGGING.getLogError;
# use: local logError=${RESULT};
function LOGGING.getLogError() {
  LOGGING.getModuleName
  DW.getGlobalInt "${RESULT}" LOG_ERROR ${TRUE}
}

# fun: isErrorEnabled
# api: public
# txt: Checks whether the "error" level is enabled.
# txt: Returns 0/TRUE in such case; 1/FALSE otherwise.
# use: if isErrorEnabled; then
# use:   ...;
# use: fi
function isErrorEnabled() {
  local -i _rescode

  if isQuietMode; then
    _rescode=${FALSE}
  else
    LOGGING.getLogError
    _rescode=${RESULT}
  fi

  return ${_rescode}
}

# fun: isLowerThanErrorEnabled
# api: public
# txt: Checks whether the enabled log level is lower than "error".
# txt: Returns 0/TRUE in such case; 1/FALSE otherwise.
# use: if isLowerThanErrorEnabled; then
# use:   ...;
# use: fi
function isLowerThanErrorEnabled() {
  if isWarnEnabled || isInfoEnabled || isDebugEnabled || isTraceEnabled; then
    return ${TRUE}
  else
    return ${FALSE}
  fi
}

# fun: logError message
# api: public
# txt: Logs a message as "error".
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logError "Operation in progress";
function logError() {
  if isErrorEnabled; then
    checkNotEmpty message "${1}" 1
    LOGGING.logStuff ERROR "$@"
  fi
}

# fun: logErrorFromStdin
# api: public
# txt: Logs given message under the "debug" level.
# opt: [stdin]: The message to log.
# txt: Returns 0/TRUE always.
# use: logErrorFromStdin <<<"Operation in progress";
function logErrorFromStdin() {
  if isErrorEnabled; then
    local _line
    while read _line; do
      if isNotEmpty "${_line}"; then
        LOGGING.logStuff ERROR "${_line}"
      fi
    done
  fi
}

# fun: logErrorFile file
# api: public
# txt: Logs the contents of a file as "error".
# opt: file: The file containing the text to log.
# txt: Returns 0/TRUE always.
# use: logErrorFile /tmp/my-log.txt;
function logErrorFile() {
  if isErrorEnabled; then
    checkNotEmpty file "${1}" 1
    local line
    cat "${1}" | while IFS='' read -r line; do
      LOGGING.logStuff ERROR "${line}"
    done
  fi
}

# fun: logErrorResult SUCCESS|FAILURE message
# api: public
# txt: Logs the outcome of an operation as "error".
# opt: SUCCESS|FAILURE: The outcome.
# opt: message: The message to log.
# txt: Returns 0/TRUE always.
# use: logErrorResult SUCCESS "done";
function logErrorResult() {
  local _outcome="${1}"
  shift
  local _message="${@}"

  if isErrorEnabled; then
    checkNotEmpty "SUCCESS|FAILURE" "${_outcome}" 1
    LOGGING.checkSuccessFailureOrNeutral "${_outcome}" 1
    checkNotEmpty message "${_message}" 2

    LOGGING.logStuffResult "${_outcome}" "${_message}"
  fi
}

# fun: applyThemeIfPresent
# api: public
# txt: Applies a theme if present.
# txt: Returns 0/TRUE if a theme is applied; 1/FALSE otherwise.
# use: if applyThemeIfPresent; then
# use:   echo "Theme applied";
# use: fi
function applyThemeIfPresent() {
  getModulePath
  local _modulePath="${RESULT}"
  if fileExists "${_modulePath}/../../themes/current.dwt"; then
    sourceFileIfExists "${_modulePath}/../../themes/current.dwt"
  else
    sourceFileIfExists "${_modulePath}/../../themes/default.dwt"
  fi
}

# State
# env: UNDEFINED: Indicates the operation outcome is undefined.
declare -igx UNDEFINED=255
# env: SUCCESS: The 'Success' literal.
declare -gx SUCCESS="Success"
# env: DONE: The 'done' literal.
declare -gx DONE="done"
# env: OK: The 'ok' literal.
declare -gx OK="ok"
# env: FAILURE: The 'Failure' literal.
declare -gx FAILURE="Failure"
# env: FAILED: The 'failed' literal.
declare -gx FAILED="failed"
# env: KO: The 'ko' literal.
declare -gx KO="ko"
# env: NEUTRAL: The 'Neutral' literal.
declare -gx NEUTRAL="Neutral"
# env: IN_PROGRESS: Indicates the operation is in progress.
declare -gx IN_PROGRESS="In progress"
# env: DW_LOGGING_EMPTY_LOG_CATEGORY: A marker for empty log categories.
declare -gx DW_LOGGING_EMPTY_LOG_CATEGORY="DW_LOGGING_EMPTY_LOG_CATEGORY"

# fun: LOGGING.defaultState
# api: private
# txt: Restores the default state of the module.
# txt: Returns 0/TRUE always.
# use: LOGGING.defaultState
function LOGGING.defaultState() {
  LOGGING.getBuiltinSuccessKeywordsVariableName
  local -n _successKeywordsVariableName=${RESULT}
  _successKeywordsVariableName[${#_successKeywordsVariableName[@]}]="${SUCCESS}"
  _successKeywordsVariableName[${#_successKeywordsVariableName[@]}]="${DONE}"
  _successKeywordsVariableName[${#_successKeywordsVariableName[@]}]="${OK}"

  LOGGING.getBuiltinFailureKeywordsVariableName
  local -n _failureKeywordsVariableName=${RESULT}
  _failureKeywordsVariableName[${#_failureKeywordsVariableName[@]}]="${ERROR}"
  _failureKeywordsVariableName[${#_failureKeywordsVariableName[@]}]="${FAILURE}"
  _failureKeywordsVariableName[${#_failureKeywordsVariableName[@]}]="${FAILED}"
  _failureKeywordsVariableName[${#_failureKeywordsVariableName[@]}]="${KO}"
}

# fun: LOGGING.resetState
# api: private
# txt: Initializes the module state.
# txt: Returns 0/TRUE always.
# use: LOGGING.resetState
function LOGGING.resetState() {
  LOGGING.getModuleName
  local _moduleName="${RESULT}"

  # env: The built-in success keywords.
  DW.declareGlobalArray "${_moduleName}" BUILTIN_SUCCESS_KEYWORDS

  # env: The built-in failure keywords.
  DW.declareGlobalArray "${_moduleName}" BUILTIN_FAILURE_KEYWORDS

  # env: LOG_STACK: The stack used to manage logging.
  DW.declareGlobalArray "${_moduleName}" LOG_STACK

  # env: LOG_CATEGORY_STACK: The stack of log categories.
  DW.declareGlobalArray "${_moduleName}" LOG_CATEGORY_STACK

  # env: LOG_PREFIX_CATEGORY_SEPARATOR: The category separator in the log prefix.
  DW.declareGlobalString "${_moduleName}" LOG_PREFIX_CATEGORY_SEPARATOR ":"

  # env: LOG_NAMESPACE: The namespace of the log namespace.
  DW.declareGlobalString "${_moduleName}" LOG_NAMESPACE

  # env: LOG_LEVEL_STACK: The stack of log levels.
  DW.declareGlobalArray "${_moduleName}" LOG_LEVEL_STACK

  # env: LOG_TO_FILES: Whether logging to files is enabled.
  DW.declareGlobalInt "${_moduleName}" LOG_TO_FILES ${FALSE}

  # env: LOG_TRACE: Whether to print TRACE messages.
  DW.declareGlobalInt "${_moduleName}" LOG_TRACE ${FALSE}

  # env: LOG_DEBUG: Whether to print DEBUG messages.
  DW.declareGlobalInt "${_moduleName}" LOG_DEBUG ${FALSE}

  # env: LOG_INFO: Whether to print INFO messages.
  DW.declareGlobalInt "${_moduleName}" LOG_INFO ${TRUE}

  # env: LOG_QUIET: Whether to disable logging messages.
  DW.declareGlobalInt "${_moduleName}" LOG_QUIET ${FALSE}

  # env: LOG_LINE_OPEN: Whether the current log line is open.
  DW.declareGlobalInt "${_moduleName}" LOG_LINE_OPEN ${FALSE}

  # env: LAST_LOG: The last log message.
  DW.declareGlobalString "${_moduleName}" LAST_LOG

  # env: LAST_LOG_LEVEL: The last log level.
  DW.declareGlobalInt "${_moduleName}" LAST_LOG_LEVEL

  # env: LOG_FILES: The files to write logging to.
  DW.declareGlobalArray "${_moduleName}" LOG_FILES

  # env: NESTED_TASK_IN_PROGRESS_MARKER: The symbols used to represent nested tasks in progress.
  setNestedTaskInProgressMarker "...."

  # env: LOG_TIMESTAMP_FORMAT: The date format.
  setLogTimestampFormat "+%Y/%m/%d %H:%M:%S"

  # env: LOG_OUTCOME_SEPARATOR: The separator used when printing log outcomes.
  setLogOutcomeSeparator " "

  # env: LOG_NESTED_INDENTATION: The indentation used for nested logs.
  setLogNestedIndentation "  "

  # env: DEFAULT_LOG_PREFIX_COLOR: The default color used for log prefixes.
  setDefaultLogPrefixColor GRAY

  # env: DEFAULT_LOG_OUTCOME_COLOR: The default color used for outcomes.
  setDefaultLogOutcomeColor GRAY

  # env: DEFAULT_LOG_RESUMING_TASK_COLOR: The default color used when resuming tasks.
  setDefaultLogResumingTaskColor GRAY

  # env: LOG_PFEFIX_COLORS: The colors used in log prefixes.
  setLogPrefixColors BLUE CYAN GRAY YELLOW GRAY MAGENTA GRAY RED BLUE

  # env: LOG_PREFIX_TOKENS: The tokens used in log prefixes.
  setLogPrefixTokens "[" "timestamp" "<" "namespace" "|" "category" ">" "logLevel" "]"

  # env: LOG_PREFIX_TIMESTAMP_POSITION: The position of the timestamp in LOG_PREFIX_TOKENS.
  setTimestampPositionInLogPrefix 1

  # env: LOG_PREFIX_NAMESPACE_POSITION: The position of the namespace in LOG_PREFIX_TOKENS.
  setNamespacePositionInLogPrefix 3

  # env: LOG_PREFIX_CATEGORY_POSITION: The position of the category in LOG_PREFIX_TOKENS.
  setCategoryPositionInLogPrefix 5

  # env: LOG_PREFIX_LEVEL_POSITION: The position of the level in LOG_PREFIX_TOKENS.
  setLevelPositionInLogPrefix 7

  # env: ERROR_LOG_PREFIX_TOKEN: The symbol used to represent ERROR level.
  setErrorLogPrefixToken "X"

  # env: WARN_LOG_PREFIX_TOKEN: The symbol used to represent WARN level.
  setWarnLogPrefixToken "x"

  # env: INFO_LOG_PREFIX_TOKEN: The symbol used to represent INFO level.
  setInfoLogPrefixToken "."

  # env: DEBUG_LOG_PREFIX_TOKEN: The symbol used to represent DEBUG level.
  setDebugLogPrefixToken "o"

  # env: TRACE_LOG_PREFIX_TOKEN: The symbol used to represent TRACE level.
  setTraceLogPrefixToken "O"

  # env: LOG_OUTCOME_COLORS: The colors used when printing the operation outcome.
  setLogOutcomeColors CYAN WHITE CYAN

  # env: LOG_OUTCOME_TOKENS: The tokens used when printing the operation outcome.
  setLogOutcomeTokens "[" "done" "]"

  # env: LOG_OUTCOME_TEXT_POSITION: The position of the text in LOG_OUTCOME_TOKENS.
  setOutcomeTextPositionInLogOutcome 1

  # env: INVALID_LOG_CATEGORIES: A list of log categories to hide in log prefixes.
  DW.declareGlobalArray "${_moduleName}" INVALID_LOG_CATEGORIES
  setInvalidLogCategories logResult \
    logInfo \
    logInfoResult \
    logInfoFromStdin \
    BOOTSTRAP.logInfo \
    logDebug logDebugResult \
    logDebugFromStdin \
    BOOTSTRAP.logDebug \
    logTrace \
    logTraceResult \
    logTraceFromStdin \
    BOOTSTRAP.logTrace \
    runCommandLongOutput \
    runCommandLongOutput.logDebugFromStdin \
    overrideEnvVar \
    source
}
# env: ENABLE_RIGHT_JUSTIFIED_LOGGING: Whether to justify text to the right when printing outcomes in log messages. Defaults to ${FALSE};
defineEnvVar ENABLE_RIGHT_JUSTIFIED_LOGGING MANDATORY "Whether to justify text to the right when printing outcomes in log messages" ${FALSE}
# vim: syntax=sh ts=2 sw=2 sts=4 sr noet

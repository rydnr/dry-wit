# mod: number
# api: public
# txt: Standard, general-purpose numeric functions.

# fun: isNumber input
# api: public
# txt: Checks whether given value is a number
# opt: input: The input.
# txt: Returns 0/TRUE if the input is a number; 1/FALSE otherwise.
# use: if isNumber "${value}"; then
# use:   echo "${value} is a number";
# use: fi
function isNumber() {
  local _input="${1}";
  checkNotEmpty input "${_input}" 1;

  local -i _rescode;

  local -i _value=$(expr "${_input}" + 0 2>/dev/null);

  if areEqual "${_value}" "${_input}"; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

# fun: mod dividend divisor
# api: public
# txt: Calculates the modulus.
# opt: dividend: The dividend.
# opt: divisor: The divisor.
# txt: Returns 0/TRUE unless any operation is not numeric; 1/FALSE otherwise.
# use: if mod ${value} 100; then
# use:   echo "${value} mod 100 -> ${RESULT}";
# use: fi
function mod() {
  local _dividend="${1}";
  checkNotEmpty dividend "${_dividend}" 1;
  local _divisor="${2}";
  checkNotEmpty divisor "${_divisor}" 2;

  local -i _rescode;
  local _result;

  if isNumber "${_dividend}" && isNumber "${_divisor}"; then
    _result=$((${_dividend} % ${_divisor}));
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: isGreaterThan first second
# api: public
# txt: Checks whether the first number is greater than the second number.
# opt: first: The first number.
# opt: second: The second number.
# txt: Returns 0/TRUE if the first number is greater than the second; 1/FALSE if is less or equal than the second; 255 if any of them is not a number.
# use: if isGreaterThan ${value} 0; then
# use:   echo "${value} is positive";
# use: fi
function isGreaterThan() {
  local _first="${1}";
  checkNotEmpty first "${_first}" 1;
  local _second="${2}";
  checkNotEmpty second "${_second}" 2;
  local -i _rescode;

  if isNumber "${_first}" && isNumber "${_second}"; then
    if [[ ${_first} -gt ${_second} ]]; then
      _rescode=${TRUE};
    else
      _rescode=${FALSE};
    fi
  else
    _rescode=255;
  fi

  return ${_rescode};
}

# fun: isGreaterOrEqualTo first second
# api: public
# txt: Checks whether the first number is greater or equal to the second number.
# opt: first: The first number.
# opt: second: The second number.
# txt: Returns 0/TRUE if the first number is equal to or greater than the second; 1/FALSE if is less than the second; 255 if any of them is not a number.
# use: if isGreaterOrEqualTo ${value} 1; then
# use:   echo "${value} is positive";
# use: fi
function isGreaterOrEqualTo() {
  local _first="${1}";
  checkNotEmpty first "${_first}" 1;
  local _second="${2}";
  checkNotEmpty second "${_second}" 2;
  local -i _rescode;

  if isNumber "${_first}" && isNumber "${_second}"; then
    if [[ ${_first} -ge ${_second} ]]; then
      _rescode=${TRUE};
    else
      _rescode=${FALSE};
    fi
  else
    _rescode=255;
  fi

  return ${_rescode};
}

# fun: isLessThan first second
# api: public
# txt: Checks whether the first number is less than the second number.
# opt: first: The first number.
# opt: second: The second number.
# txt: Returns 0/TRUE if the first number is less than the second; 1/FALSE if is greater or equal than the second; 255 if any of them is not a number.
# use: if isLessThan ${value} 0; then
# use:   echo "${value} is negative";
# use: fi
function isLessThan() {
  local _first="${1}";
  checkNotEmpty first "${_first}" 1;
  local _second="${2}";
  checkNotEmpty second "${_second}" 2;
  local -i _rescode;

  if isNumber "${_first}" && isNumber "${_second}"; then
    if [[ ${_first} -lt ${_second} ]]; then
      _rescode=${TRUE};
    else
      _rescode=${FALSE};
    fi
  else
    _rescode=255;
  fi

  return ${_rescode};
}

# fun: isLessOrEqualTo first second
# api: public
# txt: Checks whether the first number is less or equal to than the second number.
# opt: first: The first number.
# opt: second: The second number.
# txt: Returns 0/TRUE if the first number is less or equal to the second; 1/FALSE if is greater than the second; 255 if any of them is not a number.
# use: if isLessOrEqualTo ${value} -1; then
# use:   echo "${value} is negative";
# use: fi
function isLessOrEqualTo() {
  local _first="${1}";
  checkNotEmpty first "${_first}" 1;
  local _second="${2}";
  checkNotEmpty second "${_second}" 2;
  local -i _rescode;

  if isNumber "${_first}" && isNumber "${_second}"; then
    if [[ ${_first} -le ${_second} ]]; then
      _rescode=${TRUE};
    else
      _rescode=${FALSE};
    fi
  else
    _rescode=255;
  fi

  return ${_rescode};
}

# fun: toOrdinal input
# api: public
# txt: Converts a number to its ordinal representation.
# opt: input: The input number.
# txt: Returns 0/TRUE if the number could be converted; 1/FALSE otherwise.
# txt: The variable RESULT contains the ordinal.
# use: if toOrdinal "${index}"; then
# use:   echo "${RESULT} item";
# use: fi
function toOrdinal() {
  local _number="${1}";
  checkNotEmpty input "${_number}" 1;
  local -i _rescode=${FALSE};
  local _result="";

  if isNumber "${_number}" && [ "${_number}" != "0" ]; then

    if lastCharacter "${_number}"; then
      local _lastCharacter="${RESULT}";
      _rescode=${TRUE};

      case "${_lastCharacter}" in
        "1") _result="${_number}st";
             ;;
        "2") _result="${_number}nd";
             ;;
        "3") _result="${_number}rd";
             ;;
        *) _result="${_number}th";
           ;;
      esac
    fi
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: lastDigit number
# api: public
# txt: Retrieves the last digit of given number.
# opt: number: The input number.
# txt: Returns 0/TRUE if the input is a number; 1/FALSE otherwise.
# use: if lastDigit "335"; then
# use:   echo "Last digit: ${RESULT}";
# use: fi
function lastDigit() {
  local _number="${1}";
  checkNotEmpty number "${_number}" 1;

  local -i _rescode=${FALSE};
  local _result="";

  if isNumber "${_number}" && lastCharacter "${_number}"; then
    _rescode=${TRUE};
    _result="${RESULT}";
  fi

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

# fun: add first second
# api: public
# txt: Adds given numbers.
# opt: first: The first number.
# opt: second: The second number.
# txt: Returns 0/TRUE if the numbers could be added; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the sum.
# use: if add 3 9; then
# use:   echo "3+9=${RESULT}";
# use: fi
function add() {
  local first="${1}";
  checkNumber first "${first}" 1;
  local second="${2}";
  checkNumber second "${second}" 2;

  local -i _result=$((first+second));
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT=${_result};
  else
    export RESULT="";
  fi

  return ${_rescode};
}

# fun: subtract first second
# api: public
# txt: Substracts the second number from the first one.
# opt: first: The first number.
# opt: second: The second number.
# txt: Returns 0/TRUE if the subtraction was possible; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the subtraction.
# use: if subtract 9 3; then
# use:   echo "9-3=${RESULT}";
# use: fi
function subtract() {
  local first="${1}";
  checkNumber first "${first}" 1;
  local second="${2}";
  checkNumber second "${second}" 2;

  local -i _result=$((first-second));
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT=${_result};
  else
    export RESULT="";
  fi

  return ${_rescode};
}

# fun: multiply first second
# api: public
# txt: Multiplies given numbers.
# opt: first: The first number.
# opt: second: The second number.
# txt: Returns 0/TRUE if the numbers could be multiplied; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the product.
# use: if multiply 3 9; then
# use:   echo "3*9=${RESULT}";
# use: fi
function multiply() {
  local first="${1}";
  checkNumber first "${first}" 1;
  local second="${2}";
  checkNumber second "${second}" 2;

  local -i _result=$((first*second));
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT=${_result};
  else
    export RESULT="";
  fi

  return ${_rescode};
}

# fun: divide first second
# api: public
# txt: Multiplies given numbers.
# opt: first: The first number.
# opt: second: The second number.
# txt: Returns 0/TRUE if the numbers could be divided; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the division.
# use: if divide 9 3; then
# use:   echo "9/3=${RESULT}";
# use: fi
function divide() {
  local first="${1}";
  checkNumber first "${first}" 1;
  local second="${2}";
  checkNumber second "${second}" 2;

  local -i _result=$((first/second));
  local -i _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT=${_result};
  else
    export RESULT="";
  fi

  return ${_rescode};
}
# vim: syntax=sh ts=2 sw=2 sts=4 sr noet

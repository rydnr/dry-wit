#!/bin/bash
# (c) 2008-today Automated Computing Machinery, S.L.
#
#    This file is part of dry-wit.
#
#    dry-wit is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    dry-wit is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with dry-wit.  If not, see <http://www.gnu.org/licenses/>.

#set -o errexit  # terminate on any unhandled error
## TODO: fix color stuff
#set -o nounset  # terminate on any unset variable
set -o pipefail # In a pipe, the exit status of the last command that threw a non-zero exit code is returned.
#set -o xtrace   # trace what gets executed

export TRUE=0;
export FALSE=1;

_dryWitDevLogFile=${TEMP:-/tmp}/.drywit.log;

# IFS stuff
_OLD_IFS="${IFS}";
export IFS=$'\n\t\040';

export _CLEANUP_FILES=();

export BUILTIN_SUCCESS_KEYWORDS=(\
  "Success" \
  "Done" \
  "Ok" \
  );

export BUILTIN_FAILURE_KEYWORDS=(\
  "Error" \
  "Failure" \
  "Ko" \
  );

declare -a BUILTIN_ERRORS;
declare -a ENV_VARIABLES;
declare -a ERROR_MESSAGES;

#export SUCCESS_KEYWORDS;
#export FAILURE_KEYWORDS;

export SUCCESS=0;
export FAILURE=1;
export IN_PROGRESS=2;
export UNDEFINED=255;

export _DRY_WIT_LOG_STACK=();
export _DRY_WIT_LOG_CATEGORY_STACK=();
export LOG_CATEGORY_NAMESPACE="";
export _DRY_WIT_LOG_LEVEL_STACK=();
export _DRY_WIT_LOG_TRACE=${FALSE};
export _DRY_WIT_LOG_DEBUG=${FALSE};
export _DRY_WIT_LOG_INFO=${TRUE};
export _DRY_WIT_LOG_OUTCOME_TOKENS=();
export _DRY_WIT_LOG_OUTCOME_COLORS=();
export _DRY_WIT_DEFAULT_TERM_WIDTH=80;
export _DRY_WIT_LOG_LINE_OPEN=${FALSE};
export NESTED_TASK_IN_PROGRESS="....";

export LOG_TIMESTAMP="+%Y/%m/%d %H:%M:%S";
export LOG_OUTCOME_SEPARATOR=" ";
export LOG_NESTED_INDENTATION="  ";

# Bash: Passing variables by reference
# Copyright (C) 2010 Freddy Vulto
# Version: upvars-0.9.dev
# See: http://fvue.nl/wiki/Bash:_Passing_variables_by_reference
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Assign variable one scope above the caller
# Usage: local "$1" && upvar $1 "value(s)"
# Param: $1  Variable name to assign value to
# Param: $*  Value(s) to assign.  If multiple values, an array is
#            assigned, otherwise a single value is assigned.
# NOTE: For assigning multiple variables, use 'upvars'.  Do NOT
#       use multiple 'upvar' calls, since one 'upvar' call might
#       reassign a variable to be used by another 'upvar' call.
# Example:
#
#    f() { local b; g b; echo $b; }
#    g() { local "$1" && upvar $1 bar; }
#    f  # Ok: b=bar
#
function upvar() {
    if unset -v "$1"; then           # Unset & validate varname
        if (( $# == 2 )); then
            eval $1=\"\$2\"          # Return single value
        else
            eval $1=\(\"\${@:2}\"\)  # Return array
        fi
    fi
}


# Assign variables one scope above the caller
# Usage: local varname [varname ...] &&
#        upvars [-v varname value] | [-aN varname [value ...]] ...
# Available OPTIONS:
#     -aN  Assign next N values to varname as array
#     -v   Assign single value to varname
# Return: 1 if error occurs
# Example:
#
#    f() { local a b; g a b; declare -p a b; }
#    g() {
#        local c=( foo bar )
#        local "$1" "$2" && upvars -v $1 A -a${#c[@]} $2 "${c[@]}"
#    }
#    f  # Ok: a=A, b=(foo bar)
#
function upvars() {
  local _flag="${1}";

  if isEmpty "${_flag}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'name' (1) is mandatory in '${FUNCNAME[0]}'. Review ${FUNCNAME[1]}";
  fi

  while (( $# )); do
    case $1 in
      -a*)
        # Error checking
        [[ ${1#-a} ]] || { echo "bash: ${FUNCNAME[0]}: \`$1': missing"\
                                "number specifier" 1>&2; return 1; }
        printf %d "${1#-a}" &> /dev/null || { echo "bash:"\
                                                   "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2
                                              return 1; }
        # Assign array of -aN elements
        [[ "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && \
          shift $((${1#-a} + 2)) || { exitWithErrorCode UNACCEPTABLE_API_CALL "\`$1${2+ }$2': missing argument(s) to ${FUNCNAME[0]}. Review ${FUNCNAME[1]}"; }
        ;;
      -v)
        # Assign single value
        [[ "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && \
          shift 3 || { exitWithErrorCode UNACCEPTABLE_API_CALL "$1: missing argument(s) to ${FUNCNAME[0]}. Review ${FUNCNAME[1]}"; }
        ;;
      --help) echo "\
Usage: local varname [varname ...] &&
   ${FUNCNAME[0]} [-v varname value] | [-aN varname [value ...]] ...
Available OPTIONS:
-aN VARNAME [value ...]   assign next N values to varname as array
-v VARNAME value          assign single value to varname
--help                    display this help and exit
--version                 output version information and exit"
              return 0 ;;
      --version) echo "\
${FUNCNAME[0]}-0.9.dev
Copyright (C) 2010 Freddy Vulto
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law."
                 return 0 ;;
      *)
        exitWithErrorCode UNACCEPTABLE_API_CALL "$1: invalid option to ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
    esac
  done
}

## PRIVATE
## Traces the API call to the default log file using in development.
## Example:
##   traceApiCall;
function _traceApiCall() {
  echo -n "${FUNCNAME[0]}" >> ${_dryWitDevLogFile};
  local _i=0;
  while caller $i >> ${_dryWitDevLogFile}; do
    i=$((i+1))
  done
}

## PRIVATE
## Echoes a line to stdout. Useful for locating them easily when debugging.
## -> 1: The message to print.
## Example:
##   debugEcho "message";
function _debugEcho() {
  echo $* >> ${_dryWitDevLogFile};
}

## PUBLIC
## Checks whether given value is empty.
## -> 1: The value to check.
## <- 0: if the value is empty; 1 otherwise.
## Example:
##   if isEmpty "${MYVAR}"; then echo "MYVAR is empty"; fi
function isEmpty() {
  local _rescode;
  if [ -z "${1}" ]; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi
  return ${_rescode};
}

## PUBLIC
## Checks whether given value is defined.
## -> 1: The value to check.
## <- 0: if the value is empty; 1 otherwise.
## Example:
##   if isDefined "${MYVAR}"; then echo "MYVAR is defined"; fi
function isDefined() {
  local _rescode;
  if [ -z ${1+x} ]; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi
  return ${_rescode};
}

## PUBLIC
## Checks whether given variable is defined.
## -> 1: The value to check.
## <- 0: if the value is empty; 1 otherwise.
## Example:
##   if isDefined "${MYVAR}"; then echo "MYVAR is defined"; fi
function isVariableDefined() {
  local _var="${1}";
  local _rescode;
#  set +o nounset  # allow unset variables
#  eval "[ -v \${$1} ] 2> /dev/null"
  #  eval "[ -v ${1} ] 2> /dev/null"
  if isEmpty "${_var}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'var' (1) cannot be empty when calling 'isVariableDefined'. Review ${FUNCNAME[1]}";
  fi
  if [ -v "${_var}" ]; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi
#  set -o nounset  # terminate on any unset variable

  return ${_rescode};
}

## PRIVATE/DEBUG
## Prints the contents of given array.
## -> 1: The name of the array.
## Example:
##   A=( "1" "2" "3" );
##   _dwDebugArray "${A}"
function __dwDebugArray() {
  flattenArray "${1}" " + ";
  echo "${RESULT}";
}

## PUBLIC
## Checks whether given value is true.
## -> 1: The value.
## <- 0: if the value is true; 1 otherwise.
function isTrue() {
  local _value="${1}";
  local _rescode;
  if [ "${_value}" == "${TRUE}" ]; then
    _rescode=${TRUE};
  elif [ "${_value}" == TRUE ]; then
    _rescode=${TRUE};
  elif [ "${_value}" == "true" ]; then
    _rescode=${TRUE};
  else
    _rescode=${FALSE};
  fi
  return ${_rescode};
}

## PUBLIC
## Checks whether given value is false.
## -> 1: The value.
## <- 0: if the value is false; 1 otherwise.
function isFalse() {
  local _rescode;
  if isTrue $*; then
    _rescode=${FALSE};
  else
    _rescode=${TRUE};
  fi
  return ${_rescode};
}

# PRIVATE
# Retrieves the value of given variable.
# -> 1: The variable name.
# <- RESULT: The variable value.
function _evalVar() {
  local _varName="${1}";
  local _result="$(set noglob; export DOLLAR='$'; export DQUOTE="\""; echo "echo ${DQUOTE}${DOLLAR}{$(echo "${_varName}")}${DQUOTE}" | sh)";
  export RESULT="${_result}";
}

# PUBLIC
# Declares a new environment variable.
# -> 1: The variable name.
# -> 2: The variable description.
# -> 3: The default value (optional).
# -> 4: The command to retrieve the actual value (optional).
function defineEnvVar() {
  local _varName="${1}";
  local _varDescription="${2}";
  local _varDefault="${3}";
  local _varCommand="${4:-}";
  local _upcasedVarName;
  local _defaultValue;
  local _description;
  local _command;

  if isEmpty "${_varName}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'name' (1) cannot be empty when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  elif isEmpty "${_varDescription}" && [ "${FUNCNAME[1]}" != "overrideEnvVar" ]; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'description' (2) for '${_varName}' cannot be empty when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  toUpper "${_varName}";
  _upcasedVarName="${RESULT}";

  _evalVar "${_varName}"
  local _varValue="${RESULT}";
  export ${_upcasedVarName}="${_varValue}";

  if ! isEmpty "${_varDescription}"; then
    _evalVar "${_upcasedVarName}_DESCRIPTION";
    _description="${RESULT}";

    if isEmpty "${_description}"; then
      export ${_varName}_DESCRIPTION="${_varDescription}";
    fi
  fi

  if isEmpty "${_varDefault}"; then
    _evalVar "${_upcasedVarName}_DEFAULT";
    _defaultValue="${RESULT}";
  else
    _defaultValue="${_varDefault}";
  fi

  if ! isEmpty ${_defaultValue}; then
    export ${_upcasedVarName}_DEFAULT="${_defaultValue}";
    _evalVar "${_upcasedVarName}_DEFAULT";
    _defaultValue="${RESULT}";
  fi

  _addEnvVar "${_upcasedVarName}" "${_varValue}";

  if ! isEmpty "${_varCommand}"; then
    _evalVar "${_upcasedVarName}_DEFAULT_COMMAND";
    _command="${RESULT}";
    if isEmpty "${_command}"; then
      export ${_upcasedVarName}_DEFAULT_COMMAND="${_varCommand}";
    fi
    _evalVar "${_upcasedVarName}_DEFAULT_COMMAND";
    local _command="${RESULT}";
  fi
}

# PUBLIC
# Overrides the value of an environment variable.
# -> 1: The variable name.
# -> 2: The variable value.
function overrideEnvVar() {
  local _varName="${1}";
  local _varDefault="${2}";

  defineEnvVar "${_varName}" "" "${_varDefault}" "";
  _evalEnvVar ${_varName};
}

# PRIVATE
# Annotates given environment variable.
# -> 1: The variable name.
# -> 2: The value.
function _addEnvVar() {
  local _varName="${1}";
  local _varValue="${2:-}";

  if isEmpty "${_varName}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'name' (1) cannot be empty when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  if ! isEnvVarDefined "${_varName}"; then
    appendEnvVariable ${_varName} ENV_VARIABLES;
  fi
  upvar "${_varName}" "${_varValue}";
  export "${_varName}"="${_varValue}";
}

# Checks whether giver variable is defined.
# -> 1: The variable name.
# <- 0/${TRUE} if the variable is defined; 1/${FALSE} otherwise.
function isEnvVarDefined() {
  local _varName="${1}";
  local e;
  local _rescode=${FALSE};

  if isEmpty "${_varName}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'name' (1) cannot be empty when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  local _oldIFS="${IFS}";
  IFS=$' \t\n';
#  set +o nounset
  for e in ${#ENV_VARIABLES[@]}; do
    if [[ "${e}" == "${_varName}" ]]; then
      _rescode=${TRUE};
      break;
    fi
  done
  # TODO set -o nounset
  IFS="${_oldIFS}";
  return ${_rescode};
}

# Evaluates given environment variable.
# -> 1: the variable name.
function _evalEnvVar() {
  local _varName="${1}";

  if isEmpty "${_varName}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'name' (1) cannot be empty when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  _evalVar "${_varName}_DEFAULT";
  local _defaultValue="${RESULT}";
  _evalVar "${_varName}";
  local _varValue="${RESULT}";

  if [[ ! -n ${_varValue} ]]; then
    if [[ -n "${DRY_WIT_EVAL_DEFAULTS_FLAG:-}" ]]; then
#      echo -n "Evaluating ${_varName}_DEFAULT_COMMAND -> ";
      _evalVar "${_varName}_DEFAULT_COMMAND";
      local _defaultCommand="${RESULT}";
#      echo "${_defaultCommand}";
      if [[ -n ${_defaultCommand} ]]; then
        logTrace -n "Resolving ${_varName}_DEFAULT via ${_varName}_DEFAULT_COMMAND"
        local _aux="$(set noglob; echo "${_defaultCommand}" | sh)";
        if [[ -n ${_aux} ]]; then
          _defaultValue="${_aux}";
          logTraceResult SUCCESS "${_aux}"
        else
          logTraceResult FAILURE "failed"
        fi
      fi
    fi
    _varValue="${_defaultValue}";
  fi

  if [[ -n ${_varValue} ]] && [[ -z "${DRY_WIT_EVAL_DEFAULTS_FLAG:-}" ]]; then
    while [[ "${_varValue}" =~ .*'$'.* ]]; do
      _varValue="$(set noglob; echo "echo ${_varValue}" | sh)";
    done
  fi

  if [[ -n ${_varValue} ]]; then
    export ${_varName}="${_varValue}";
  fi
}

function evalEnvVars() {
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for var in "${ENV_VARIABLES[@]}"; do
    _evalEnvVar ${var};
  done
  IFS="${_oldIFS}";
}

## PUBLIC
## Retrieves the value of a constant.
## -> 1: The constant name.
## <- RESULT: The constant value.
## Example:
##  _OTHERVAR="works"
##  _MYVAR="OTHERVAR";
##  evalConstant "${_MYVAR}";
##  echo "${_MYVAR}->${RESULT}" # _OTHERVAR->works
function evalConstant() {
  cache _uncachedEvalConstant $*;
}

# PRIVATE
# See evalConstant()
function _uncachedEvalConstant() {
  local _constant="${1}";

  local _result=$(echo | awk -v c="${_constant}" -v p1="{" -v p2="}" '{printf("echo %s%s%s%s\n", "$", p1, c, p2);}' | sh 2> /dev/null);

  if isEmpty "${_result}" ; then
    _result="${2}";
  fi

  if isEmpty "${_result}" ; then
    _result="${_constant}";
  fi
  #  if [ "${DEBUG}" == "1" ]; then
  #    echo "";
  #    echo "${_constant} converts to ${_result}";
  #  fi

  export RESULT="${_result}";
}

## PUBLIC
## Flattens an array, using given separator.
## -> 1: The name of the array variable.
## -> 2: The separator to use.
## <- RESULT: The resulting string.
## Example:
##   A=(a b c);
##   _flattenArray A "x";
##   echo "A->${RESULT}" # axbxc
function flattenArray() {
  local _arrayName="${1}";
  local _separator="${2}";
  local _result="";

  local _aux="$(echo "\${#${_arrayName}[@]}")";
  local _len=$((-1+$(eval echo "${_aux}")));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    _aux="$(echo "\${${_arrayName}[${_i}]}")";
    _item=$(eval echo "${_aux}");
    _result="${_result}${_separator}${_item}";
  done
  IFS="${_oldIFS}";
  _result="${_result#${_separator}}";
  export RESULT="${_result}";
}

# Checks whether a given flag is enabled
# -> 1: the name of the flag variable
# <- 0 if the flag is enabled, 1 otherwise.
# Example:
# function parseInput() {
# [..]
#   -my | --myFlag) export MY_FLAG=${TRUE};
#                   ;;
# [..]
# if _flagEnabled MY_FLAG; then
#    ..
function _flagEnabled() {
  local _flagVar="${1}";
  local _flagVal;
  local _result;
  _evalVar "${_flagVar}";
  _flagVal="${RESULT}";
  if    [ "x${_flagVal}" == "x${TRUE}" ] \
     || [ "x${_flagVal}" == "xTRUE" ]; then
    _result=${TRUE};
  else
    _result=${FALSE};
  fi
  return ${_result};
}

# AUXILIARY GENERAL-PURPOSE FUNCTIONS

function cleanup() {
  if [ "${#_CLEANUP_FILES}" != "0" ]; then
    setLogCategory "post-process";

    logDebug -n "Cleaning up temporary files";

    local _oldIFS="${IFS}";
    IFS=$' \t\n';
    for i in ${_CLEANUP_FILES[*]}; do
      logTrace -n "Deleting $i";
      rm -rf $i > /dev/null;
      if [ $? -eq 0 ]; then
        logTraceResult SUCCESS "done";
      else
        logTraceResult FAILURE "failed";
      fi
    done
    IFS="${_oldIFS}";

    logDebugResult SUCCESS "done";
  fi
}

function createTempFile() {
  local _prefix="$(echo \"${SCRIPT_NAME}\" | awk -F"/" '{print $NF;}' | sed 's/^"//g' | sed 's/"$//g')";
  local _dirname="$(dirname \"${SCRIPT_NAME}\")";
#  local _prefix="$(echo "${SCRIPT_NAME}" | awk -F"/" '{print $NF;}')";
#  local _dirname="$(dirname "${SCRIPT_NAME}")";
  if [ "${_dirname#\.\.}" == "${_dirname}" ]; then
    _dirname="$PWD/${_dirname#\.}";
  else
    _dirname="$PWD/../${_dirname#\.\.}";
  fi
  local _result="$(mktemp -p "${_dirname}"  -t ".${_prefix}.XXXXXXXXXX")";
  local _aux=$?;
  rm -f ${_result} > /dev/null
  if isFalse ${_aux} ; then
     _result="$(mktemp -t ".${_prefix}.XXXXXXXXXX")";
     _aux=$?;
  fi
  if [ $_aux -ne 0 ]; then
     exitWithErrorCode $1;
  fi
  addFileToCleanup "${_result}";

  export RESULT="${_result}";
}

## Checks if given file is writeable
## -> 1: the file to check.
## <- 0: the file is writeable; 1 otherwise.
function fileIsWriteable() {
  local _file="${1}";
  if [[ -n ${_file} ]] && [[ -w ${_file} ]]; then
    return ${TRUE};
  else
    return ${FALSE};
  fi
}

## Checks if an element is already contained in an array.
## -> [1]: The element to check
## -> [2]: The array (passed as "${array[@]}"
## <- 0: If the element is present in the array.
## <- 1: Otherwise
## Example:
##   a=("one" "two" "three" "other number")
##   if containsElement "other number" "${array[@]}"; then
##     ...
##   fi
function arrayContainsElement() {
  local _item="${1}";
  local _array="${2}";
  local _aux;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _aux in "${_array}"; do
    if [[ "${_aux}" == "${_item}" ]]; then
      return 0;
    fi
  done
  IFS="${_oldIFS}";
  return 1;
}

## Appends a new variable to ENV_VARIABLES.
## -> 1: The item to add.
##
## Example:
##   appendEnvVariable "item";
function appendEnvVariable() {
  local _variable="${1}";

  if declare -p ENV_VARIABLES > /dev/null 2>&1; then
    upvars -a$((${#ENV_VARIABLES[@]}+1)) ENV_VARIABLES "${ENV_VARIABLES[@]}" "${_variable}";
    export ENV_VARIABLES;
  else
    export -a ENV_VARIABLES=();
    upvars -a1 ENV_VARIABLES "${_variable}";
    export ENV_VARIABLES;
  fi
}

function addFileToCleanup() {
  local _file="${1}";
  #  logTrace "Appending ${result} to _CLEANUP_FILES";

  if declare -p _CLEANUP_FILES > /dev/null 2>&1; then
    upvars -a$((${#_CLEANUP_FILES[@]}+1)) _CLEANUP_FILES "${_CLEANUP_FILES[@]}" "${_file}";
    export _CLEANUP_FILES;
  else
    export -a _CLEANUP_FILES=();
    upvars -a1 _CLEANUP_FILES "${_file}";
    export _CREANUP_FILES;
  fi

#  local _oldIFS="${IFS}";
#  IFS=$' \t\n';
#  _CLEANUP_FILES=(\
#    $(for i in ${_CLEANUP_FILES[*]}; do echo $i; done) \
#      "${_file}" \
#  );
#  IFS="${_oldIFS}";
}

function createTempFolder() {
  local _prefix="$(echo ${SCRIPT_NAME} | awk -F"/" '{print $NF;}')";
  local _dirname="$(dirname ${SCRIPT_NAME})";
  if [ "${_dirname#\.\.}" == "${_dirname}" ]; then
    _dirname="$PWD/${_dirname#\.}";
  else
    _dirname="$PWD/../${_dirname#\.\.}";
  fi
  local result=$(mktemp -p "${_dirname}" -d -t ".${_prefix}.XXXXXX");
  local _aux=$?;
  if [ $_aux -ne 0 ]; then
    result=$(mktemp -d -t ".${_prefix}.XXXXXX");
    _aux=$?;
  fi
  if [ $_aux -ne 0 ]; then
     exitWithErrorCode $1;
  fi
  addFileToCleanup "${result}";

  export RESULT="${result}";
}

function extractFlags() {
  local result="";
  echo " $@" \
    | awk -F" -" '{for (i=2; i<=NF; i++){printf("-%s \n", $i);}}' \
    | awk -F" " '{print $1;}'
}

function extractFlagValue() {
  local flag=$1;
  shift;
  echo " $@" \
    | awk -F" -" '{printf("-"); for (i=2; i<=NF; i++){if(i%2 == 1) {printf("-");}; printf("%s \n", $i);}}' \
    | grep -e "^$flag " \
    | awk -v f="${flag}" '{printf("echo \"%s\" | sed -e \"s_^%s __g\"\n", $2, f);}' \
    | sh;
}

function logFlag() {
  local _flag="$1";
  local _value="$2";
  local _placeholders=$3;
  local _remaining="$4";

  if ! isEmpty "${_value}"; then
    _value=" ${_value}";
  fi
  if ! isEmpty "${_remaining}"; then
    _remaining=" Remaining ${_remaining}";
  fi
  logTrace "Parsed ${_flag} ${_value}. Shifting ${_placeholders} placeholder(s).${_remaining}";
}

# Finds a given file within a PATH variable.
# -> 1: The file name to look for.
# <- (stdin) the file path.
function findInPath() {
  cache _uncachedFindInPath $*;
}

# PRIVATE
# See findInPath()
function _uncachedFindInPath() {
  local _result="";
  local _paths="$(echo \"$PATH:.\" | awk -F":" '{for(i=1;i<=NF;i++) print $i;}')";

  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _path in $_paths; do
    if [ -f "${_path}/$1" ]; then
      _result="${_path}/$1";
      break;
    fi
  done
  IFS="${_oldIFS}";
  echo ${_result};
}

# Checks whether given keyword represents a success.
# -> 1: The keyword.
# <- 0/${TRUE} if the keyword is considered a success; 1/${FALSE} otherwise.
function isSuccessKeyword() {
  cache _uncachedIsSuccessKeyword $*;
}

# PRIVATE
# See isSuccessKeyword()
function _uncachedIsSuccessKeyword() {
  local _keyword="${1}";
  local _result=1;

  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  if    [ "x${SUCCESS_KEYWORDS}" != "x" ] \
     && [  ${SUCCESS_KEYWORDS[*]} != "" ]; then
    for i in ${SUCCESS_KEYWORDS[*]}; do
      if    [ "x${i}" == "x${_keyword}" ] \
         || [   "x$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
             == "x$(echo \"${i}\"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
#         || [   "x$(echo "${_keyword}" | tr [:upper:] [:lower:] 2> /dev/null)" \
#             == "x$(echo "${i}"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
        _result=${TRUE};
        break;
      fi;
    done
  fi

  if [ ${_result} == 1 ]; then
    for i in ${BUILTIN_SUCCESS_KEYWORDS[*]}; do
      if [ "x${i}" == "x${1}" ] \
          || [   "x$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
              == "x$(echo \"${i}\"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
#          || [   "x$(echo "${_keyword}" | tr [:upper:] [:lower:] 2> /dev/null)" \
#              == "x$(echo "${i}"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
        _result=${TRUE};
        break;
      fi;
    done
  fi
  IFS="${_oldIFS}";

  return ${_result};
}

# Checks whether given keyword represents a failure.
# -> 1: The keyword.
# <- 0/${TRUE} if the keyword is considered a failure; 1/${FALSE} otherwise.
function isFailureKeyword() {
  cache _uncachedIsFailureKeyword $*;
}

# PRIVATE
# See isFailureKeyword()
function _uncachedIsFailureKeyword() {
  local _keyword="${1}";
  local _result=${FALSE};

  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for i in ${FAILURE_KEYWORDS[*]}; do
    if    [ "x${i}" == "x${1}" ] \
       || [   "x$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
           == "x$(echo \"${i}\"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
#      || [   "x$(echo "${_keyword}" | tr [:upper:] [:lower:] 2> /dev/null)" \
#           == "x$(echo "${i}"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
      _result=${TRUE};
      break;
    fi;
  done

  if [ ${_result} != 0 ]; then
    for i in ${BUILTIN_FAILURE_KEYWORDS[*]}; do
      if [ "x${i}" == "x${1}" ] \
        || [   "x$(echo \"${_keyword}\" | tr [:upper:] [:lower:] 2> /dev/null)" \
            == "x$(echo \"${i}\"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
#        || [   "x$(echo "${_keyword}" | tr [:upper:] [:lower:] 2> /dev/null)" \
#            == "x$(echo "${i}"        | tr [:upper:] [:lower:] 2> /dev/null)" ]; then
        _result=${TRUE};
        break;
      fi;
    done
  fi
  IFS="${_oldIFS}";

  return ${_result};
}

function printErrorMessage() {
  local _result=${TRUE};
  local _message;
  local _error;
  local _interruption=${TRUE};

  local _oldIFS="${IFS}";
  IFS=$' \t\n';
#  set +o nounset  # allow unset variables
  for i in ${BUILTIN_ERRORS[@]}; do
    _result=$((_result+1));
    if [ "x${i}" == "x${1}" ]; then
      _message="$i";
      break;
    fi;
  done
  # TODO set -o nounset  # disallow unset variables

  if [ "x${_message}" == "x" ]; then
    # IFS issue
#    _result=${TRUE};
    for i in ${ERROR_MESSAGES[@]}; do
      _result=$((_result+1));
      if [ "x${i}" == "x${1}" ]; then
        _message="$i";
        break;
      fi;
    done
  fi
  IFS="${_oldIFS}";

  if [ "x${_message}" == "x" ]; then
    _error="Error $1, but no error message defined. Fix this script";
    _result=-1;
    shift;
  else
    shift;
    _error="$(echo ${_message} \
  | awk -v dollar="$" '{printf("echo %s{%s}\n", dollar, $0);}' | sh)";
#  | awk -v dollar="$" '{printf("echo \"%s{%s}\"\n", dollar, $0);}' | sh)";
  fi

  if [ ${#@} -gt 0 ]; then
    _error="${_error} ($@)";
  fi

  if [ ${_result} == 1 ]; then
    _error="${_error}. Finishing..";
  fi
  if isDebugEnabled; then
    _printUsage $SCRIPT_NAME;
  fi
  _printError "${_error}";

  return ${_result};
}

function exitWithErrorCode() {
  local _rescode;
  printErrorMessage $@;
  _rescode=$?;
  cleanup;
  exit ${_rescode};
}

# Internal functions

function _printError() {
  echo "Error: $@.";
}

function _printEnvironment() {
  local i=0;

  if [ -n "${ENV_VARIABLES:-}" ] \
     && isTraceEnabled; then
    cat <<EOF
Environment variables:
EOF
    local _oldIFS="${IFS}";
    IFS=$' \t\n';
    for ((i = 0; i < ${#ENV_VARIABLES[@]}; i++)); do
      echo "  ${ENV_VARIABLES[$i]} $(echo ${ENV_VARIABLES[$i]} | awk -v dollar="$" -v quote="\"" '{printf("echo %s(%s{%s}): %s{%s_DESCRIPTION}%s.\n", quote, dollar, $0, dollar, $0, quote);}' | sh)";
#      echo "  ${ENV_VARIABLES[$i]} $(echo ${ENV_VARIABLES[$i]} | awk -v dollar="$" -v quote="\"" '{printf("echo %s(%s%s%s{%s}): %s%s%s{%s_DESCRIPTION}%s%s.%s\n", quote, quote, quote, dollar, $0, quote, quote, dollar, $0, quote, quote, quote);}' | sh)";
    done
    IFS="${_oldIFS}";
  fi
}

function _printExitValues() {
  local i=0;
  local j=0;

  if isTraceEnabled; then
    cat <<EOF
Exit values:
  0: No error.
EOF
    local _oldIFS="${IFS}";
    IFS=$' \t\n';
    if [ ${#BUILTIN_ERRORS[@]} -gt 0 ]; then
      for ((i = 0; i < ${#BUILTIN_ERRORS[@]}; i++)); do
        echo "  $((i+1)): $(echo ${BUILTIN_ERRORS[$i]} | awk -v dollar="$" '{printf("echo %s{%s}\n", dollar, $0);}' | sh).";
      done
    fi
    if [ ${#ERROR_MESSAGES[@]} -gt 0 ]; then
      for ((j = 0; j < ${#ERROR_MESSAGES[@]}; j++)); do
        echo "  $((j+i+1)): $(echo ${ERROR_MESSAGES[$j]} | awk -v dollar="$" '{printf("echo %s{%s}\n", dollar, $0);}' | sh).";
      done
    fi
    IFS="${_oldIFS}";
  fi
}

function _printHelp() {

  if _functionPresent defineEnv "${SCRIPT_NAME}"; then
    defineEnv;
  fi
  usage $SCRIPT_NAME;
  _printEnvironment;
  _printExitValues;
}

function _printUsage() {
  _printHelp >&2
}

function _trapSignals() {
  trap 'exitWithErrorCode SCRIPT_INTERRUPTED' INT QUIT TSTP;
#  trap 'exitWithErrorCode UNKNOWN_ERROR " ${FUNCNAME[0]}"' ERR;
}

function _debugVariable() {
  local _name="${1}";
  shift;
  local _value="${@}";

  declare -t "${_name}"="${_value}";
  trap "echo ${_name} is being used here." DEBUG
}

# Converts given date (in days) to a formatted date.
# -> 1: The day-based timestamp.
# <- RESULT: year month day
function jd2date() {
  cache _uncachedJd2date $*;
}

# PRIVATE
# See jd2date()
function _uncachedJd2date() {
  local _standardJd;
  local _temp1;
  local _temp2;
  local _jd;
  local _year;
  local _month;
  local _day;

  local _jd=$1;

  _standardJd=$((_jd+2400001));
  _temp1=$((_standardJd+68569));
  _temp2=$((_temp1*4/146097));
  _temp1=$((_temp1-(146097*_temp2+3)/4));
  _year=$((4000*(_temp1+1)/1461001));
  _temp1=$((_temp1-1461*_year/4+31));
  _month=$((80*_temp1/2447));
  _day=$((_temp1-2447*_month/80));
  _temp1=$((_month/11));
  _month=$((_month+2-12*_temp1));
  _year=$((100*(_temp2-49)+_year+_temp1));

  export RESULT="$_year $_month $_day";
}

# Converts given formatted date to a day-based one.
# -> 1: The year.
# -> 2: The month.
# -> 3: The day.
# <- RESULT: The day-based timestamp.
function date2jd() {
  cache _uncachedDate2jd $*;
}

# PRIVATE
# See date2jd()
function _uncachedDate2jd() {
  local _result=0;

  local _year=$1;
  local _month=$2;
  local _day=$3;

  local _standardJd=$(( _day - 32075
       + 1461 * (_year + 4800 - (14 - _month)/12)/4
       + 367 * (_month - 2 + (14 - _month)/12*12)/12
       - 3 * ((_year + 4900 - (14 - _month)/12)/100)/4));

  _result=$((_standardJd-2400001));

  export RESULT=${_result};
}

# Converts given date (in seconds) to a formatted date.
# -> 1: The timestamp, in seconds.
# <- RESULT: days hour minute second
function jds2date() {
  cache _uncachedJds2date $*;
}

# PRIVATE
# See jds2date()
function _uncachedJds2date() {
  local _year;
  local _month;
  local _day;
  local _hour;
  local _minute;
  local _second;

  local _jd=$1;
  jd2date $((_jd/86400));
  local _date_in_days="${RESULT}";
  _year="$(echo ${_date_in_days} | cut -d ' ' -f 1)";
  _month="$(echo ${_date_in_days} | cut -d ' ' -f 2)";
  _day="$(echo ${_date_in_days} | cut -d ' ' -f 3)";

  local _temp=$((_jd%86400));
  _hour=$((_temp/3600))
  _temp=$((_temp-_hour*3600));
  _minute=$((_temp/60));
  _second=$((_temp-_minute*60));

  export RESULT="${_date_in_days} ${_hour} ${_minute} ${_second}";
}

# Converts given formatted date to a second-based one.
# -> 1: The year.
# -> 2: The month.
# -> 3: The day.
# -> 4: The hour.
# -> 5: The minute.
# -> 6: The second.
# <- RESULT: The number of seconds.
function date2jds() {
  cache _uncachedDate2jds $*;
}

# PRIVATE
# See date2jds()
function _uncachedDate2jds() {
  local _result=0;

  local _year=$1;
  local _month=$2;
  local _day=$3;
  local _hour=$4;
  local _minute=$5;
  local _second=$6;

  date2jd ${_year} ${_month} ${_day};
  _result=${RESULT};
  _result=$((_result*24+_hour));
  _result=$((_result*60+_minute));
  _result=$((_result*60+_second));

  export RESULT=${_result};
}

# Retrieves the TERM variable
# <- RESULT: the TERM variable.
function retrieveTERM() {
  cache _uncachedRetrieveTERM $*;
}

# PRIVATE
# See retrieveTERM()
function _uncachedRetrieveTERM() {
  local _result="${TERM}";

  if isEmpty "${_result}"; then
    _result="dumb";
  fi

  case ${_result} in
    dumb) _result="$(uname | tr '[:upper:]' '[:lower:]')";
         ;;
      *) ;;
  esac

  export RESULT="${_result}";

  return ${TRUE};
}

# PRIVATE
# Retrieves the column width, from an environment
# variable.
# <- RESULT: the column width; -1 if the environment variable
#           is not specified.
# <- 0/${TRUE} if the term width is specified via an environment variable;
#    1/${FALSE} otherwise.
# Example:
#   if retrieveTermWidthFromEnvVar; then
#     _width=${RESULT};
#   fi
function _retrieveTermWidthFromEnvVar() {
  local _rescode=${FALSE};
  if ! isEmpty "${DW_TERM_WIDTH}"; then
    _rescode=${TRUE};
    export RESULT="${DW_TERM_WIDTH}";
  fi

  return ${_rescode};
}

# PRIVATE
# Retrieves the width of the term.
# Exports the value, since values greater
# than 255 are not allowed as return codes.
# <- 0: if the calculation
# <- RESULT: the term width.
function getTermWidth() {
  cache _uncachedGetTermWidth $*;
}

## See getTermWidth
function _uncachedGetTermWidth() {
  local _result;
  local -i _rescode;
  local _term;

  _retrieveTermWidthFromEnvVar;
  _rescode=$?;
  if ! isTrue ${_rescode}; then
    retrieveTERM;
    _term="${RESULT}";
    getTermWidthForTerm "${_term}";
    _result="${RESULT}";
    export RESULT="${_result}";
    _rescode=$?;
  fi

  _debugEcho "term witdh -> ${_RESULT}";
  return ${_rescode};
}

# Retrieves the width of the term.
# Exports the value, since values greater
# than 255 are not allowed as return codes.
# -> 1: the TERM.
# <- 0: if the calculation is performed successfully.
# <- RESULT: the term width.
function getTermWidthForTerm() {
  cache _uncachedGetTermWidthForTerm $*;
}

## See getTermWidthForTerm
function _uncachedGetTermWidthForTerm() {
  local -i _rescode;
  local _result;
  local _term="${1}";

  if isEmpty "${_term}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'term' (1) is mandatory when calling ${FUNCNAME[2]}. Review ${FUNCNAME[3]}";
  fi

  $(tput cols &> /dev/null > /dev/null 2>&1);
  _rescode=$?;

  if isTrue ${_rescode}; then
    _result=$(tput cols);
  fi

  if    isEmpty ${_result} \
     || [ $((_result)) -le 0 ]; then

    if ! isEmpty "${_term}"; then

      $(tput -T ${_term} cols > /dev/null 2>&1);

      if isTrue ${_rescode}; then
        _result=$(tput -T ${_term} cols);
      fi
    fi
  fi
  if    isEmpty ${_result} \
     || [ $((_result)) -le 0 ]; then
    _result=${_DRY_WIT_DEFAULT_TERM_WIDTH};
  fi
  export RESULT=${_result};

  return ${_rescode};
}

# Logging functions

function setLogCategoryNamespace() {
  export LOG_CATEGORY_NAMESPACE="$1";
}

function getLogCategoryNamespace() {
  export RESULT="${LOG_CATEGORY_NAMESPACE}";
}

function setLogCategory() {
  export LOG_CATEGORY="$1";
}

function getLogCategory() {
  export RESULT="${LOG_CATEGORY}";
}

## Builds a new color.
## -> 1: The color name.
## -> 2: The foreground value.
## -> 3: The background value.
## Example:
##   buildColor "GREEN" "32" "42";
function buildColor() {
  local _color="${1}";
  local _fgValue="${2}";
  local _bgValue="${3}";
  local _result="";

  upvar "${_color}" "\033[0;${_fgValue}m";
  export "${_color}";
  upvar "${_color}_FG" "\033[0;${_fgValue}m";
  export "${_color}_FG";
  upvar "${_color}_BG" "\033[${_bgValue}m";
  export "${_color}_BG";
  upvar "LIGHT_${_color}_FG" "\033[1;${_fgValue}m";
  export "LIGHT_${_color}_FG";
  upvar "UNDERSCORE_${_color}_FG" "\033[4;${_fgValue}m";
  export "UNDERSCORE_${_color}_FG";
  upvar "BLINK_${_color}_FG" "\033[5;${_fgValue}m";
  export "BLINK_${_color}_FG";
  upvar "INVERSE_${_color}_FG" "\033[7;${_fgValue}m";
  export "INVERSE_${_color}_FG";
  upvar "CONCEALED_${_color}_FG" "\033[8;${_fgValue}m";
  export "CONCEALED_${_color}_FG";
}

#for c in "BLACK" "BLACK_B" "RED" "RED_B" "RED_S" "GREEN" "GREEN_B" "YELLOW" "YELLOW_B" "BLUE" "BLUE_B" "MAGENTA" "MAGENTA_B" "CYAN" "CYAN_B" "GREY" "WHITE" "WHITE_B" "NO_COLOR"; do
#  upvars -a1 "${c}_TPUT" "";
#  upvar "${c}" "";
#  ${c}_TPUT=();
#done

buildColor "NO_COLOR" "0";
buildColor "BLACK" "30" "0";
buildColor "RED" "31" "41";
buildColor "GREEN" "32" "42";
buildColor "YELLOW" "33" "43";
buildColor "BLUE" "34" "44";
buildColor "MAGENTA" "35" "45";
buildColor "CYAN" "36" "46";
buildColor "GRAY" "37" "47";

export SUCCESS_COLOR=GREEN;
export FAILURE_COLOR=RED;
export IN_PROGRESS_COLOR=BLUE;
export UNDEFINED_COLOR=GREY;
export DEFAULT_LOG_PREFIX_COLOR=GRAY;
export DEFAULT_LOG_OUTCOME_COLOR=GRAY;
export DEFAULT_LOG_RESUMING_TASK_COLOR=GRAY;

export LOG_PREFIX_COLORS=(\
  BLUE   \
  CYAN  \
  RED    \
  YELLOW \
  RED \
  GRAY \
  BLUE   \
);

export LOG_PREFIX_TOKENS=(\
    "[" \
    "timestamp"  \
    "<" \
    "category"  \
    ">" \
    "logLevel" \
    "]" \
);
export LOG_PREFIX_TIMESTAMP_POSITION=1;
export LOG_PREFIX_CATEGORY_POSITION=3;
export LOG_PREFIX_LEVEL_POSITION=5;

export INFO_LOG_PREFIX_TOKEN=".";
export DEBUG_LOG_PREFIX_TOKEN="o";
export TRACE_LOG_PREFIX_TOKEN="O";

export LOG_OUTCOME_COLORS=(\
    CYAN  \
    WHITE \
    CYAN  \
);

export LOG_OUTCOME_TOKENS=(\
    "[" \
    "done" \
    "]" \
);

export LOG_OUTCOME_TEXT_POSITION=1;

## Checks whether the terminal allows colors or not.
## <- 0/${TRUE} if the terminal supports colors; 1/${FALSE} otherwise.
function allowsColors() {
  cache _uncachedAllowsColors $*;
}

## See allowsColors
function _uncachedAllowsColors() {
  local _result;

  $(tput colors > /dev/null 2>&1);
  if isTrue $?; then
    _colors=$(tput colors);
    if [ ${_colors} -ge 8 ]; then
      env | grep -e '^_=' | grep env > /dev/null 2>&1;
      if isTrue $?; then
        _result=${TRUE};
      else
        result=${FALSE};
      fi
    else
      _result=${FALSE};
    fi
  else
    _result=${FALSE};
  fi;

  return ${_result};
}

function getColor() {
  local _colorConstant="${1}";
  local _defaultColor="${2:-${UNDEFINED_COLOR}}"
  local _result;

  if allowsColors; then
    evalConstant "${_colorConstant}" "${_defaultColor}";
    _result="${RESULT}";
  fi

  export RESULT="${_result}";
}

function findOutKeyword() {
  local _value="${1}";
  local _result;

  case "${_value}" in
    "SUCCESS") _result=${SUCCESS};
               ;;
    "FAILURE") _result=${FAILURE};
               ;;
    *) if isSuccessKeyword "${_value}"; then
         _result=${SUCCESS};
       elif isFailureKeyword "${_value}"; then
         _result=${FAILURE};
       else
         _result=${UNDEFINED};
       fi
       ;;
  esac

  return ${_result};
}

# Checks whether given tag is defined.
# -> 1: The tag to check.
# <- 0/${TRUE} if the tag is defined; 1/${FALSE} otherwise.
function definedTag() {
  cache _uncachedDefinedTag $*;
}

# PRIVATE
# See definedTag()
function _uncachedDefinedTag() {
  local _result;

  case "${1}" in
    "SUCCESS" | "FAILURE") _result=${TRUE};
       ;;
    *) _result=${FALSE};
       ;;
  esac

  return ${_result};
}

# Retrieves the verbosity flag.
# <- RESULT: -vv if trace is enabled;
#            -v if debug is enabled;
#            empty string otherwise.
function resolveVerbosity() {
  local _result="";

  if isTraceEnabled; then
    _result="-vv";
  elif isDebugEnabled; then
    _result="-v";
  elif isInfoEnabled; then
    _result="";
  fi;

  export RESULT="${_result}";
}

# Checks whether trace is enabled.
# <- 0/${TRUE} if trace is enabled; 1/${FALSE} otherwise.
function isTraceEnabled() {
  local _rescode=${FALSE};

  if isDebugEnabled; then
    if isTrue ${_DRY_WIT_LOG_TRACE}; then
      _rescode=${TRUE};
    fi
  fi

  return ${_rescode};
}

# Enables the trace level.
function setTraceEnabled() {
  _DRY_WIT_LOG_TRACE=${TRUE};
  setDebugEnabled;
}

# Logs given message under the "trace" level.
# -> 1: The message to log.
function logTrace() {
  if isTraceEnabled; then
    _logStuff TRACE "$@";
  fi
}

# Logs given text as a log result, under the "trace" level.
# -> 1: The result message to log.
function logTraceResult() {
  if isTraceEnabled; then
    _logStuffResult TRACE "$@";
  fi
}

# Logs the contents of given file, under the "trace" level.
# -> 1: The file to log.
function logTraceFile() {
  if isTraceEnabled; then
    cat "${1}" 2> /dev/null | while IFS='' read -r line; do _logStuff TRACE "${line}"; done
  fi
}

# Checks whether the debug level is enabled.
# <- 0/${TRUE} if debug is allowed; 1/${FALSE} otherwise.
function isDebugEnabled() {
  local _rescode=${FALSE};

  if isInfoEnabled; then
    if isTrue ${_DRY_WIT_LOG_DEBUG}; then
      _rescode=${TRUE};
    fi
  fi

  return ${_rescode};
}

# Enables the debug level.
function setDebugEnabled() {
  _DRY_WIT_LOG_DEBUG=${TRUE};
  setInfoEnabled;
}

# Logs the contents of given file, under the "debug" level.
# -> 1: The file to log.
function logDebugFile() {
  if isDebugEnabled; then
    cat "${1}" | while IFS='' read -r line; do _logStuff DEBUG "${line}"; done
  fi
}

# Logs given message under the "debug" level.
# -> 1: The message to log.
function logDebug() {
  if isDebugEnabled; then
    _logStuff DEBUG "$@";
  fi
}

# Logs given outcome under the "debug" level.
# -> 1: The outcome to log.
function logDebugResult() {
  if isDebugEnabled; then
    _logStuffResult DEBUG "$@";
  fi
}

# Checks whether the enabled log level is lower than "info".
# <- 0/${TRUE} in such case; 1/${FALSE} otherwise.
function isLowerThanInfoEnabled() {
  if isDebugEnabled || isTraceEnabled; then
    return ${TRUE};
  else
    return ${FALSE};
  fi
}

function isInfoEnabled() {
  local _rescode=${TRUE};

  if isTrue ${_DRY_WIT_LOG_QUIET}; then
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

function setInfoEnabled() {
  _DRY_WIT_LOG_QUIET=${FALSE};
}

function logInfoFile() {
  if isInfoEnabled; then
    cat "${1}" | while IFS='' read -r line; do _logStuff INFO "${line}"; done
  fi
}

function logInfo() {
  if isInfoEnabled; then
    _logStuff INFO "$@";
  fi
}

function logInfoResult() {
  if isInfoEnabled; then
    _logStuffResult INFO "$@";
  fi
}

function setQuietMode() {
  _DRY_WIT_LOG_QUIET=${TRUE};
}

function log() {
  _logInfo "$@";
}

function logResult() {
  _logInfoResult "$@";
}

function logFile() {
  cat "${1}" | while IFS='' read -r line; do _logStuff INFO "${line}"; done
}

function _logStuff() {
  local _level="${1}";
  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;
  local _minusN="${1}";
  if [ "-n" == "${_minusN}" ]; then
    shift;
  fi
  _logInProgress "${_level}" "$@";
  if [ "-n" != "${_minusN}" ]; then
    echo;
    _popLog;
    _popLogCategory;
  fi
}

function _logStuffResult() {
  local _level="${1}";
  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;
  local -i _nestedTasks;
  _numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if [ ${_nestedTasks} -eq 0 ]; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "No ongoing process to print the outcome for. Review ${FUNCNAME[2]}";
  fi
  _logCompleted "${_level}" "$@";
}

## PRIVATE
## Annotates the last log message.
## -> 1: The log message.
function _setLastLog() {
  _DRY_WIT_LAST_LOG="${@}";
}

## PRIVATE
## Retrieves the last log message.
## <- RESULT: The log message.
function _getLastLog() {
  export RESULT="${_DRY_WIT_LAST_LOG}";
}

## PRIVATE
## Pushes given message to the log stack.
## -> 1: The message to push.
function _pushLog() {
  _DRY_WIT_LOG_STACK[${#_DRY_WIT_LOG_STACK[@]}]="$*";
}

## PRIVATE
## Pushes given category to the log category stack.
## -> 1: The category to push.
function _pushLogCategory() {
  _DRY_WIT_LOG_CATEGORY_STACK[${#_DRY_WIT_LOG_CATEGORY_STACK[@]}]="$*";
}

## PRIVATE
## Pushes given level to the log level stack.
## -> 1: The level to push.
function _pushLogLevel() {
  _DRY_WIT_LOG_LEVEL_STACK[${#_DRY_WIT_LOG_LEVEL_STACK[@]}]="$*";
}

## PRIVATE
## Retrieves the number of "in-progress" tasks pending.
## <- Such count.
## Example:
##   _numberOfNestedInProgressTasks;
##   _count=$?
function _numberOfNestedInProgressTasks() {
  local _rescode;
  _rescode=${#_DRY_WIT_LOG_STACK[@]};
  return ${_rescode};
}

## PRIVATE
## Pops given message from the log stack.
## <- 0: if the stack contained at least the popped item; 1 otherwise.
## <- RESULT: The popped message.
## Example:
##   if _popLog; then
##     echo "Last log: ${RESULT}";
##   fi
function _popLog() {
  local _rescode;
  local _result="";
  local -i _len=${#_DRY_WIT_LOG_STACK[@]};
  local -i _newLen;
  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    _result="${_DRY_WIT_LOG_STACK[${_newLen}]}";
    eval "unset _DRY_WIT_LOG_STACK[${_newLen}]";
    _rescode=$?;
  else
    _rescode=1;
  fi
  export RESULT="${_result}";
  return ${_rescode};
}

## PRIVATE
## Peeks given message from top of the log stack.
## <- 0: if the stack contains at least the returned item; 1 otherwise.
## <- RESULT: The message.
## Example:
##   if _peekLog; then
##     echo "Last log: ${RESULT}";
##   fi
function _peekLog() {
  local _rescode;
  local _result="";
  local -i _len=${#_DRY_WIT_LOG_STACK[@]};
  local -i _newLen;
  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    _result="${_DRY_WIT_LOG_STACK[${_newLen}]}";
    _rescode=$?;
  else
    _rescode=1;
  fi
  export RESULT="${_result}";
  return ${_rescode};
}

## PRIVATE
## Pops given category from the log category stack.
## <- 0: if the stack contained at least the popped item; 1 otherwise.
## <- RESULT: The popped category.
## Example:
##   if _popLogCategory; then
##     echo "Last log category: ${RESULT}";
##   fi
function _popLogCategory() {
  local _rescode;
  local -i _len=${#_DRY_WIT_LOG_CATEGORY_STACK[@]};
  local -i _newLen;
  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    export RESULT="${_DRY_WIT_LOG_CATEGORY_STACK[${_newLen}]}";
    eval "unset _DRY_WIT_LOG_CATEGORY_STACK[${_newLen}]";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi
  return ${_rescode};
}

## PRIVATE
## Peeks given category from the log category stack.
## <- 0: if the stack contained at least the returned item; 1 otherwise.
## <- RESULT: The category.
## Example:
##   if _peekLogCategory; then
##     echo "Last log category: ${RESULT}";
##   fi
function _peekLogCategory() {
  local _rescode;
  local _result="";
  local -i _len=${#_DRY_WIT_LOG_CATEGORY_STACK[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    _result="${_DRY_WIT_LOG_CATEGORY_STACK[${_newLen}]}";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  export RESULT="${_result}";
  return ${_rescode};
}

## PRIVATE
## Pops given level from the log level stack.
## <- 0: if the stack contained at least the popped item; 1 otherwise.
## <- RESULT: The popped level.
## Example:
##   if _popLogLevel; then
##     echo "Last log level: ${RESULT}";
##   fi
function _popLogLevel() {
  local _rescode;
  local -i _len=${#_DRY_WIT_LOG_LEVEL_STACK[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    export RESULT="${_DRY_WIT_LOG_LEVEL_STACK[${_newLen}]}";
    eval "unset _DRY_WIT_LOG_LEVEL_STACK[${_newLen}]";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  return ${_rescode};
}

## PRIVATE
## Peeks given level from the log level stack.
## <- 0: if the stack contained at least the returned item; 1 otherwise.
## <- RESULT: The level.
## Example:
##   if _peekLogLevel; then
##     echo "Last log level: ${RESULT}";
##   fi
function _peekLogLevel() {
  local _rescode;
  local _result="";
  local -i _len=${#_DRY_WIT_LOG_LEVEL_STACK[@]};
  local -i _newLen;

  if [ ${_len} -gt 0 ]; then
    _newLen=$((${_len} - 1));
    _result="${_DRY_WIT_LOG_LEVEL_STACK[${_newLen}]}";
    _rescode=$?;
  else
    _rescode=${FALSE};
  fi

  export RESULT="${_result}";
  return ${_rescode};
}

## PRIVATE
## Checks whether the log line is currently opened.
## <- 0: if it's open; 1 otherwise.
## Example:
##   if _isLogLineOpen; then [..]; fi
function _isLogLineOpen() {
  return ${_DRY_WIT_LOG_LINE_OPEN};
}

## PRIVATE
## Opens the log line.
## Example:
##   _openLogLine;
function _openLogLine() {
  export _DRY_WIT_LOG_LINE_OPEN=${TRUE};
}

## PRIVATE
## Closes the log line.
## Example:
##   _closeLogLine;
function _closeLogLine() {
  export _DRY_WIT_LOG_LINE_OPEN=${FALSE};
}

## PRIVATE
## Retrieves the timestamp used for logging.
## <- RESULT: The timestamp.
## Note: Override LOG_TIMESTAMP to modify the timestamp format.
## Example:
##   _retrieveLogTimestamp;
##   echo "The log timestamp is ${RESULT}";
function _retrieveLogTimestamp() {
  export RESULT="$(date "${LOG_TIMESTAMP}")";
}

## PRIVATE
## Retrieves the position of the timestamp in
## the log prefix tokens array.
## <- RESULT: the timestamp position.
## Example:
##   _retrieveTimestampPositionInLogPrefix;
##   echo "timestamp -> ${RESULT}";
function _retrieveTimestampPositionInLogPrefix() {
  export RESULT=${LOG_PREFIX_TIMESTAMP_POSITION};
}

## PRIVATE
## Retrieves the position of the category in
## the log prefix tokens array.
## <- RESULT: the category position.
## Example:
##   _retrieveCategoryPositionInLogPrefix;
##   echo "category -> ${RESULT}";
function _retrieveCategoryPositionInLogPrefix() {
  export RESULT=${LOG_PREFIX_CATEGORY_POSITION};
}

## PRIVATE
## Retrieves the position of the log level in
## the log prefix tokens array.
## <- RESULT: the level position.
## Example:
##   _retrieveLevelPositionInLogPrefix;
##   echo "level -> ${RESULT}";
function _retrieveLevelPositionInLogPrefix() {
    export RESULT=${LOG_PREFIX_LEVEL_POSITION};
}

## PRIVATE
## Retrieves the position of the outcome token in
## the log outcome colors array.
## <- RESULT: the outcome text position.
## Example:
##   _retrieveOutcomeTextPositionInLogOutcome;
##   echo "outcome text -> ${RESULT}";
function _retrieveOutcomeTextPositionInLogOutcome() {
  export RESULT=${LOG_OUTCOME_TEXT_POSITION};
}

## PRIVATE
## Retrieves the tokens composing the log prefix.
## -> 1: The log category.
## -> 2: The log level (optional).
## Example:
##    _retrieveLogPrefixTokens "a:b:c" DEBUG;
##    echo "${_DRY_WIT_LOG_PREFIX_TOKENS[*]}"
function  _retrieveLogPrefixTokens() {
  local _category="${1}";
  if isEmpty "${_category}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'category' (1) cannot be empty when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  local _levelVar="${2}";

  evalConstant "${_levelVar}_LOG_PREFIX_TOKEN" "${INFO_LOG_PREFIX_TOKEN}";
  local _level="${RESULT}";
  local _result=();
  local _aux="";
  local _timestamp;
  local -i _i;
  local -i _len;
  local -i _timestampPosition;
  local -i _category_position;
  local -i _levelPosition;

  _len=$((${#LOG_PREFIX_TOKENS[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    _DRY_WIT_LOG_PREFIX_TOKENS[${_i}]="${LOG_PREFIX_TOKENS[${_i}]}";
  done
  IFS="${_oldIFS}";

  _retrieveLogTimestamp;
  _timestamp="${RESULT}";
  _retrieveTimestampPositionInLogPrefix;
  _timestampPosition=${RESULT};
  _DRY_WIT_LOG_PREFIX_TOKENS[${_timestampPosition}]="${_timestamp}";
  _retrieveCategoryPositionInLogPrefix;
  _categoryPosition=${RESULT};
  _DRY_WIT_LOG_PREFIX_TOKENS[${_categoryPosition}]="${_category}";
  _retrieveLevelPositionInLogPrefix;
  _levelPosition=${RESULT};
  _DRY_WIT_LOG_PREFIX_TOKENS[${_levelPosition}]="${_level}";
}

## PRIVATE
## Retrieves the tokens composing the log outcome.
## -> 1: The outcome text.
## <- RESULT: The output file to source to be able to use
##            _DRY_WIT_LOG_OUTCOME_TOKENS array.
## Example:
##    _retrieveLogOutcomeTokens "done";
##    source ${RESULT};
##    echo "${_DRY_WIT_LOG_OUTCOME_TOKENS[*]}"
function  _retrieveLogOutcomeTokens() {
  local _text="${1}";
  if isEmpty "${_text}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'text' (1) cannot be empty when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  local _result=();
  local _aux="";
  local _timestamp;
  local -i _i;
  local -i _len;
  local -i _outcomeTextPosition;

  _len=$((${#LOG_OUTCOME_TOKENS[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    _DRY_WIT_LOG_OUTCOME_TOKENS[${_i}]="${LOG_OUTCOME_TOKENS[${_i}]}";
  done
  IFS="${_oldIFS}";

  _retrieveOutcomeTextPositionInLogOutcome;
  _outcomeTextPosition=${RESULT};
  _DRY_WIT_LOG_OUTCOME_TOKENS[${_outcomeTextPosition}]="${_text}";

}

## PRIVATE
## Retrieves the tokens composing the log outcome.
## -> 1: The keyword (SUCCESS, FAILURE, IN_PROGRESS).
## <- RESULT: The output file to source to be able to use
##            _DRY_WIT_LOG_OUTCOME_COLORS array.
## Example:
##    _retrieveLogOutcomeColors SUCCESS "done";
##    source ${RESULT};
##    echo "${_DRY_WIT_LOG_OUTCOME_COLORS[*]}"
function _retrieveLogOutcomeColors() {
  local _keyword="${1}";
  if isEmpty "${_keyword}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'keyword' (1) cannot be empty when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  local _result=();
  local _aux="";
  _retrieveKeywordColor "${_keyword}";
  local _keywordColor="${RESULT}";
  local -i _i;
  local -i _len;
  local -i _outcomeTextPosition;

  _len=$((${#LOG_OUTCOME_COLORS[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    _DRY_WIT_LOG_OUTCOME_COLORS[${_i}]="${LOG_OUTCOME_COLORS[${_i}]}";
  done
  IFS="${_oldIFS}";

  _retrieveOutcomeTextPositionInLogOutcome;
  _outcomeTextPosition=${RESULT};
  _DRY_WIT_LOG_OUTCOME_COLORS[${_outcomeTextPosition}]="${_keywordColor}";
}

## PRIVATE
## Retrieves the color for a given keyword.
## -> 1: The keyword (SUCCESS, FAILURE, IN_PROGRESS).
## -> 2: The default color.
## <- RESULT: The associated color.
## Example:
##   _retrieveKeywordColor SUCCESS GREEN;
##   echo "Color -> ${RESULT}"
function _retrieveKeywordColor() {
  local _keyword="${1}";
  if isEmpty "${_keyword}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'keyword' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  local _defaultColor="${2:-${NO_COLOR}}";

  local _result;

  case ${_keyword} in
    SUCCESS | "${SUCCESS}") _result="${SUCCESS_COLOR}";
                            ;;
    FAILURE | "${FAILURE}" | "FAILED" | "failed" | "FAIL" | "fail") _result="${FAILURE_COLOR}";
                                                                    ;;
    IN_PROGRESS | "${IN_PROGRESS}") _result="${IN_PROGRESS_COLOR}";
                                    ;;
    *) _result="${_defaultColor}";
       ;;
  esac

  export RESULT="${_result}";
}

## PRIVATE
## Prints the log prefix.
## -> 1: The log category.
## -> 2: The log level.
## Example:
##   _echoLogPrefix "cat" DEBUG
function _echoLogPrefix() {
  local _category="${1}";
  if isEmpty "${_category}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'category' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  local _level="${2}";
  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (2) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  local _allowsColors;
  allowsColors;
  _allowsColors=$?;
  _echoColorAwareLogPrefix "${_category}" ${_allowsColors} "${_level}";
}

## PRIVATE
## Retrieves the log prefix.
## -> 1: The log category.
## -> 2: The log level.
## Example:
##   _retrieveLogPrefix "cat" DEBUG;
##   echo "log prefix -> ${RESULT}";
function _retrieveLogPrefix() {
  local _category="${1}";
  if isEmpty "${_category}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'category' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  local _level="${2}";
  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (2) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  local _result="$(_echoColorAwareLogPrefix "${_category}" ${FALSE} "${_level}")";
  export RESULT="${_result}";
}

## PRIVATE
## Prints the log prefix, for color terminals.
## -> 1: The log category.
## -> 2: ${TRUE} if using colors; ${FALSE} otherwise.
## -> 3: The log level.
## Example:
##   _echoColorAwareLogPrefix "cat" ${TRUE} DEBUG
function _echoColorAwareLogPrefix() {
  local _category="${1}";
  if isEmpty "${_category}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'category' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  local _allowsColors=${2};
  if isEmpty "${_allowsColors}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'allowsColors' (2) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  local _level="${3}";
  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (3) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  local _len;
  local _colors;

  _retrieveLogPrefixTokens "${_category}" "${_level}";
#  source ${RESULT};

  _len=$((${#_DRY_WIT_LOG_PREFIX_TOKENS[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    if isTrue ${_allowsColors}; then
      echoInColor -n "${LOG_PREFIX_COLORS[${_i}]}" "${_DRY_WIT_LOG_PREFIX_TOKENS[${_i}]}";
    else
      echo -n "${_DRY_WIT_LOG_PREFIX_TOKENS[${_i}]}";
    fi
  done
  IFS="${_oldIFS}";

  if isTrue ${_allowsColors}; then
    resetColor;
  fi
  echo -n " ";
}

## PRIVATE
## Retrieves the log namespace.
## <- RESULT: The log namespace.
function _retrieveLogNamespace() {
  local _namespace="${LOG_CATEGORY_NAMESPACE}";
  local _category="${LOG_CATEGORY}";
  local _result;

  if isEmpty "${_namespace}"; then
    if isEmpty "${SCRIPT_NAME}" ; then
      _result="?";
    else
      _result="$(basename ${SCRIPT_NAME} .sh)";
    fi
  fi

  if ! isEmpty ${_category} ; then
    _result="${_result}:${_category}";
  fi

  export RESULT="${_result}";
}

## PRIVATE
## Prints the log outcome.
## -> 1: The log level.
## -> 2: The keyword  (SUCCESS, FAILURE, IN_PROGRESS).
## -> 3: The outcome text.
## Example:
##   _echoLogOutcome DEBUG SUCCESS "sample"
function _echoLogOutcome() {
  local _level="${1}";
  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;

  local _keyword="${1}";
  if isEmpty "${_keyword}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'keyword' (2) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;

  local _text="${@}";
  local _len;
  local _allowsColors;
  local _colors;
  local _inProgressMessage;
  local _logPrefix;

  _retrieveLogOutcomeTokens "${_text}";

  allowsColors;
  _allowsColors=$?;

  if isTrue ${_allowsColors}; then
    _retrieveLogOutcomeColors ${_keyword};
  fi

  _peekLog;
  _inProgressMessage="${RESULT}";
  _peekLogCategory;
  _category="${RESULT}";
  if isEmpty "${_category}"; then
    exitWithErrorCode POSTCONDITION_NOT_SATISFIED "_peekLogCaterory must not return an empty string";
  fi
  _peekLogLevel;
  _level="${RESULT}";
  _retrieveLogPrefix "${_category}" "${_level}";
  _logPrefix="${RESULT}";
  _alignRight "${_logPrefix}${_inProgressMessage}" "${_text}";

  _len=$((${#_DRY_WIT_LOG_OUTCOME_TOKENS[@]} - 1));
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 0 ${_len}); do
    if isTrue ${_allowsColors}; then
      echo echoInColor \"-n\" "\"${_DRY_WIT_LOG_OUTCOME_COLORS[${_i}]}\"" "\"${_DRY_WIT_LOG_OUTCOME_TOKENS[${_i}]}\"" >> /tmp/echo.txt;
      echoInColor -n "${_DRY_WIT_LOG_OUTCOME_COLORS[${_i}]}" "${_DRY_WIT_LOG_OUTCOME_TOKENS[${_i}]}";
    else
      echo -n "${_DRY_WIT_LOG_OUTCOME_TOKENS[${_i}]}";
    fi
  done
  IFS="${_oldIFS}";

  if isTrue ${_allowsColors}; then
    resetColor;
  fi
}

## PRIVATE
## Prints the log outcome.
## -> 1: The log level.
## -> 2: The keyword  (SUCCESS, FAILURE, IN_PROGRESS).
## -> 3: The outcome text.
## Example:
##   _echoLogOutcome DEBUG SUCCESS "sample"
function _echoLogOutcomeNested() {
  local _level="${1}";
  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;

  local _keyword="${1}";
  if isEmpty "${_keyword}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'keyword' (2) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;

  local _text="${@}";
  local _inProgressMessage;
  local _alreadyInProgressMessage;
  local _category;
  local _alreadyInProgressCategory;
  local _indentation;
  local -i _i;
  _popLog;
  _inProgressMessage="${RESULT}";
  _popLogCategory;
  _category="${RESULT}";
  _echoLogOutcome "${_level}" "${_keyword}" "${_text}";
  _numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _i in $(seq 1 ${_nestedTasks}); do
    _indentation="${_indentation}${LOG_NESTED_INDENTATION}";
  done
  IFS="${_oldIFS}";
  _pushLog "${_indentation}${_inProgressMessage}";
  _pushLogCategory "${_category}";
}

## PRIVATE
## Writes spaces until the next message to print
## is aligned to the right.
## -> 1: The log-line message.
## -> 2: The log outcome message.
## Example:
##  _alignRight "Finishing work" "done";
function _alignRight() {
  local _logLineMessage="${1}";
  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  local _outcome="${2}";
  if isEmpty "${_outcome}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'outcome' (2) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  local _logMessage;

  local -i _termWidth;
  local -i _index;
  local -i _offset=0;
  local -i _end;
  local _allowsColors;

  _retrieveLogOutcomeTokens "${_outcome}";
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _token in "${_DRY_WIT_LOG_OUTCOME_TOKENS[@]}"; do
    _logMessage="${_logMessage}${_token}";
  done
  IFS="${_oldIFS}";

  getTermWidth;
  if isTrue $?; then
    _termWidth=${RESULT};
    if [ ${_termWidth} -le 0 ]; then
      exitWithErrorCode POSTCONDITION_NOT_SATISFIED "getTermWidth() must not return successfully providing 0 as output";
    fi
    _index=0;
    allowsColors;
    _allowsColors=$?;
    if isTrue ${_allowsColors}; then
      _offset=$((_offset));
    fi
    _end=$((${_offset}+${_termWidth}-${#_logLineMessage}%${_termWidth}-${#_logMessage}-1));
    while [ $((_end)) -lt 0 ]; do
      echo "";
      _end=$((-${_end}+${_offset}+${_termWidth}-${#_logMessage}));
    done
    while [ $((${_end}-${_index}+1)) != 0 ]; do
      _index=$((${_index}+1));
      echo -n "${LOG_OUTCOME_SEPARATOR}";
    done
  fi
}

## PUBLIC
## Prints a text in color.
## -> 1: -n : Whether to remove the CRLF from the end (optional).
## -> 2: The color.
## -> 3: The text to echo.
function echoInColor() {
  local _flagMinusN;
  local _colorAux;
  if [ "${1}" == "-n" ]; then
    _flagMinusN=${TRUE};
    shift;
  else
    _flagMinusN=${FALSE};
  fi
  local _color="${1}";
  if isEmpty "${_color}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'color' (1) is mandatory when calling '${FUNCNAME[0]}'. Review ${FUNCNAME[1]}";
  fi
  local _text="${2}";
  if isEmpty "${_text}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'text' (2) is mandatory when calling '${FUNCNAME[0]}'. Review ${FUNCNAME[1]}";
  fi
  local _colorAux="";
  local _inColor=${FALSE};

  if allowsColors; then
    if isVariableDefined "${_color}"; then
      _inColor=${TRUE};
      _evalVar "${_color}";
      _colorAux="${RESULT}";
    fi
  fi

  if isTrue ${_flagMinusN}; then
    if isTrue ${_inColor}; then
      echo -en "${_colorAux}${_text}${NO_COLOR}";
    else
      echo -n "${_text}";
    fi
  else
    if isTrue ${_inColor}; then
        echo -e "${_colorAux}${_text}${NO_COLOR}";
    else
      echo "${_text}";
    fi
  fi
}

## PUBLIC
## Prints a text in color.
## -> 1: -n : Whether to remove the CRLF from the end (optional).
## -> 2: The color.
## -> 3: The text to echo.
function resetColor() {
  echo -en ${NO_COLOR};
}

## PUBLIC
## Echoes given text, colorized.
## -> 1: The text to colorize.
## -> 2: The keyword (0 -> success; 1 -> failure; other -> try to infer from the text).
## -> 3: The default color (optional).
## Example:
##   echoColorizeText "done" SUCCESS;
function echoColorizedText() {
  local _text="${1}";
  local _keyword="${2}";
  local _defaultColor="${3:-${UNDEFINED_COLOR}}";
  local _color="";
  allowsColors;
  _allowsColors=$?;

  if isTrue ${_allowsColors}; then
    getColor ${_defaultColor};
    _undefinedColor="${RESULT}";
    getColor ${SUCCESS_COLOR};
    _successColor="${RESULT}";
    getColor ${FAILURE_COLOR};
    _failureColor="${RESULT}";
    case ${_keyword} in
      ${SUCCESS}) _color="${_successColor}";
         ;;
      ${FAILURE}) _color="${_failureColor}";
         ;;
      *) if isSuccessKeyword "${_text}"; then
           _color="${_successColor}";
         elif isFailureKeyword "${_text}"; then
           _color="${_failureColor}";
         else
           _color="${_undefinedColor}";
         fi
         ;;
    esac
  fi
  echoColorizedTextWithColor -n "${_color}" "${_text}";
}

## PUBLIC
## Echoes given text, colorized.
## -> 1: The text to colorize.
## -> 2: The text color.
## Example:
##   echoColorizeTextWithColor "${WHITE}" "done";
function echoColorizedTextWithColor() {
  local _flagMinusN;
  if [ "${1}" == "-n" ]; then
    _flagMinusN=${TRUE};
    shift;
  else
    _flagMinusN=${FALSE};
  fi
  evalConstant "${1}";
  local _color="${RESULT}";
  local _text="${2}";
  local _result;

  local _allowsColors;
  allowsColors;
  _allowsColors=$?;

  if isTrue ${_allowsColors}; then
    if isTrue ${_flagMinusN}; then
      echoInColor -n "${_color}" "${_text}";
    else
      echoInColor "${_color}" "${_text}";
    fi
    resetColor;
  elif isTrue ${_flagMinusN}; then
    echo -n "${_text}";
  else
    echo "${_text}";
  fi
}

## PRIVATE
## Prints a log message.
## -> 1: The log level.
## -> 2: The message.
## Example:
##   _logMessage INFO "A message to log"
##   # [...] A message to log
function _logMessage() {
  local _level="${1}";

  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  shift;
  local _message="$@";

  _logInProgress "${_level}" "${_message}";
  echo;
}

## PRIVATE
## Prints a log message, indicating some uncompleted task.
## -> 1: The message.
## Example:
##   _logInProgress "Calculating ...";
##   # [...] Calculating ...
function _logInProgress() {
  local _level="${1}";
  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;

  local _message="$@";
  local -i nestedTasks;
  local _category;
  _retrieveLogNamespace;
  _category="${RESULT}";

  _numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if [ ${_nestedTasks} -gt 0 ]; then
    _logInProgressNested "${_category}" "${_level}" "${_message}";
  else
    _logInProgressNoNested "${_category}" "${_level}" "${_message}";
  fi
}

## PRIVATE
## Prints a log message, indicating some uncompleted task,
## when there're nested tasks.
## -> 1: The category.
## -> 2: The log level.
## -> 3: The message.
## Example:
##   _logInProgressNested "cat" DEBUG "Calculating ...";
##   # [...<cat>|o] Calculating ...
function _logInProgressNested() {
  local _category="${1}";
  if isEmpty "${_category}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'category' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;

  local _level="${1}";
  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (2) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;

  local _message="$@";
  local _logPrefix;
  _pushLog "${_message}";
  _pushLogCategory "${_category}";
  _pushLogLevel "${_level}";
  _logCompletedNestedNoPop "${_level}" IN_PROGRESS "${NESTED_TASK_IN_PROGRESS}";
  echo;

  _retrieveLogPrefix "${_category}" "${_level}";
  _logPrefix="${RESULT}";
  _echoLogPrefix "${_category}" "${_level}";
  _peekLog;
  _actualMessage="${RESULT}";
  echoColorizedText "${_actualMessage}" "" "${DEFAULT_LOG_PREFIX_COLOR}";
}

## PRIVATE
## Prints a log message, indicating some uncompleted task,
## when there're no nested tasks.
## -> 1: The log category.
## -> 2: The log level.
## -> 3: The message.
## Example:
##   _logProgressNoNested "cat" INFO "Calculating ...";
##   # [...<cat|.>] Calculating ...
function _logInProgressNoNested() {
  local _category="${1}";
  if isEmpty "${_category}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'category' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;

  local _level="${1}";
  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (2) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;

  local _message="$@";
  local _logPrefix;

  _logPrefix="${RESULT}";
  _pushLogCategory "${_category}";
  _pushLog "${_message}";
  _pushLogLevel "${_level}";
  _echoLogPrefix "${_category}" "${_level}";
  echoColorizedText "${_message}" "" "${DEFAULT_LOG_PREFIX_COLOR}";
}

## PRIVATE
## Prints the result of a task.
## -> 1: The log level.
## -> 2: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS);
## -> 3: The outcome text.
## Example:
##   _logCompleted INFO SUCCESS "done";
function _logCompleted() {
  local _level="${1}";
  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;

  local _keyword="${1}";
  if isEmpty "${_keyword}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'keyword' (2) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;
  local _text="${@}";
  local -i nestedTasks;

  _numberOfNestedInProgressTasks;
  _nestedTasks=$?;
  if [ ${_nestedTasks} -gt 1 ]; then
    _logCompletedNested "${_level}" "${_keyword}" "${_text}";
  else
    _logCompletedNoNested "${_level}" "${_keyword}" "${_text}";
  fi
}

## PRIVATE
## Prints the result of a task.
## -> 1: The log level.
## -> 2: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS);
## -> 3: The outcome text.
## Example:
##   _logCompletedNoNested INFO SUCCESS "done";
function _logCompletedNoNested() {
  local _level="${1}";
  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;

  local _keyword="${1}";
  if isEmpty "${_keyword}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'keyword' (2) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;

  local _text="${@}";
  _echoLogOutcome "${_level}" "${_keyword}" "${_text}";
  _popLog;
  _popLogCategory;
  _popLogLevel;
  echo;
}

## PRIVATE
## Prints the result of a task, when there're nested tasks.
## -> 1: The log level.
## -> 2: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS);
## -> 3: The outcome text.
## Example:
##   _logCompletedNested INFO SUCCESS "done";
function _logCompletedNested() {
  local _level="${1}";
  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;

  local _keyword="${1}";
  if isEmpty "${_keyword}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'keyword' (2) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift

  local _message="$@";
  local _nestedTask;
  local _nestedTaskCategory;
  local _logPrefix;
  _echoLogOutcome "${_level}" "${_keyword}" "${_message}";
  echo;
  _popLogCategory;
  _peekLogCategory;
  _nestedTaskCategory="${RESULT}";
  _popLogLevel;
  _peekLogLevel;
  _nestedTaskLevel="${RESULT}";
  _popLog;
  _peekLog;
  _nestedTask="${RESULT}";
  _echoLogPrefix "${_nestedTaskCategory}" "${_nestedTaskLevel}";
  echoColorizedText "${_nestedTask}" "" "${DEFAULT_LOG_RESUMING_TASK_COLOR}";
}

## PRIVATE
## Prints the result of a task, when there're nested tasks.
## -> 1: The log level.
## -> 2: The outcome keyword (SUCCESS, FAILURE, IN_PROGRESS);
## -> 3: The outcome text.
## Example:
##   _logCompletedNested SUCCESS "done";
function _logCompletedNestedNoPop() {
  local _level="${1}";
  if isEmpty "${_level}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'level' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift;

  local _keyword="${1}";
  if isEmpty "${_keyword}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'keyword' (2) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  shift
  local _message="$@";
  _echoLogOutcomeNested "${_level}" "${_keyword}" "${_message}";
}

function urlEncode() {
  local _text="$1";
  if isEmpty "${_text}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'text' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

    echo "${_text}"  \
  | sed 's % %25 g'  \
  | sed 's \+ %2B g' \
  | sed 's| |+|g'    \
  | sed 's \[\[BR\]\] %0D%0A g' \
  | sed 's ! %21 g'  \
  | sed 's \* %2A g' \
  | sed "s ' %27 g" \
  | sed 's ( %28 g'  \
  | sed 's ) %29 g'  \
  | sed 's ; %3B g'  \
  | sed 's : %3A g'  \
  | sed 's @ %40 g'  \
  | sed 's & %26 g'  \
  | sed 's = %3D g'  \
  | sed 's \$ %24 g' \
  | sed 's , %2C g'  \
  | sed 's / %2F g'  \
  | sed 's \? %3F g' \
  | sed 's \[ %5B g' \
  | sed 's \] %5D g';

#  !    *    '    (    )    ;    :    @    &    =    +    $    ,    /
#%21  %2A  %27  %28  %29  %3B  %3A  %40  %26  %3D  %2B  %24  %2C  %2F
#  ?    %    #    [    ]
# %3F  %25  %23  %5B  %5D
}

## PUBLIC
## Reads given configuration file.
## -> 1: The config file.
## <- 0/${TRUE} if the file is read successfully; 1/${FALSE} otherwise.
## Example:
##   if readConfFile "/tmp/app.conf"; then
##     echo "/tmp/app.conf read successfully";
##   fi
function readConfFile() {
  local _confFile="${1}";
  if isEmpty "${_confFile}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'confFile' (1) is mandatory when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  local result=${TRUE};

  [ ! -e "${_confFile}" ] && result=${FALSE};

  local _actualConfFile="${_confFile}";

  createTempFile;
  result=$?;

  if isFalse ${result}; then
    return ${result};
  fi

  _actualConfFile="${RESULT}";

    grep -v '^#' "${_confFile}" | sed 's ${\(.*\)} _dollar{\1}_ g' \
  | sed 's ^\(.*\)=\(.*\) echo\ -n\ \1\ |\ tr\ \[:lower:\]\ \[:upper:]\;\ echo\ -n\ =\;\ echo\ \2 g' \
  | sh \
  | sed 's _dollar{\(.*\)}_ ${\1} g' \
  | sed 's_^\(.*\)=\(.*\)$_\1=\2; logTrace \1=\${\1};_ g' \
  | sed 's_^_export _g' > "${_actualConfFile}";

  . "${_actualConfFile}";

  return ${result};
}

function checkPasswordlessSudo() {
  local _result=${TRUE};

  which sudo > /dev/null 2>&1;
  _result=$?;

  if isTrue ${_result}; then
    local _tmp="${TEMP}";
    if [ ! -r "${_tmp}" ]; then
      _tmp="/tmp";
    fi
    if [ ! -r "${_tmp}" ]; then
      _tmp="$PWD";
    fi
    if [ -r "${_tmp}" ]; then
      echo "" | sudo -S sudo ls "${_tmp}" 2> /dev/null > /dev/null
      _result=$?;
    else
      _result=1;
    fi
  fi

  return ${_result};
}

function findRelativePathBetweenFolders() {
  # Given two paths, A and B, find the shortest way
  # to reach B from A.
  # For example, if A is /tmp/test and B is /tmp/my/private/temp,
  # the shortest path is ../my/private/temp.
  # The algorith is as follows:
  # 1) Find the greatest common parent to A and B -> parent
  # 2) Remove 'parent' from A and B -> A* and B*
  # 3) Find out the distance from A to A* -> d
  # 4) Replace the greatest 'd' parent folders with '..' in A -> P*
  # 5) Result=P*/B*
  local _pathA="$1";
  local _pathB="$2";
  local _parent;
  local _pathAb;
  local _pathBb;
  local _d;
  local _p;
  local _result;

  findGreatestCommonParentFolder "${_pathA}" "${_pathB}";
  _parent="${RESULT}";

  _pathAb="${_pathA#${_parent}}";
  _pathAb="${_pathAb#/}";
  _pathBb="${_pathB#${_parent}}";
  _pathBb="${_pathBb#/}";

  findFolderDistance "${_pathA}" "${_pathAb}";
  _d="${RESULT}";
  index=0;

  replaceNLeftmostTokens "${_pathA}" ".." ${_d} "/";
  _p="${RESULT}";
  local _aux=$(echo ${_pathA} | awk -F"/" '{print NF;};');
  replaceNRightmostTokens "${_p}" "" $((_aux-_d-1)) "/";
  _p="${RESULT}";

  _result="${_p}/${_pathBb}";

  export RESULT="${_result}";
}

function findGreatestCommonParentFolder() {
  local _pathA="$1";
  local _pathB="$2";
  local _result="";

  local _maxA=$(echo "${_pathA}" | awk -F"/" '{print NF;}');
  local _maxB=$(echo "${_pathB}" | awk -F"/" '{print NF;}');
  local _max=$((_maxA));
  if [ $((_max)) -lt $((_maxB)) ]; then
    _max=$((_maxB));
  fi

  local _index=1;
  local _auxA;
  local _auxB;

  while [ $((_index)) -le $((_max)) ]; do
    _auxA=$(echo "${_pathA}" | awk -F"/" -vindx=${_index} '{printf("%s", $indx);}');
    _auxB=$(echo "${_pathB}" | awk -F"/" -vindx=${_index} '{printf("%s", $indx);}');
    _index=$((_index+1));
    if [ "${_auxA}" == "${_auxB}" ]; then
      _result="${_result}/${_auxA}";
    else
      break;
    fi
  done

  _result=$(echo "${_result}" | sed 's ^/  g');

  export RESULT="${_result}";
}

function findFolderDistance() {
  local _pathA="$1";
  local _pathB="$2";
  local _result=-1;

  local _maxA=$(echo "${_pathA}" | awk -F"/" '{print NF;}');
  local _maxB=$(echo "${_pathB}" | awk -F"/" '{print NF;}');
  local _max=$((_maxA));
  if [ $((_max)) -lt $((_maxB)) ]; then
    _max=$((_maxB));
  fi

  local _index=$((_max));
  local _indexA=$((_maxA));
  local _indexB=$((_maxB));
  local _auxA;
  local _auxB;

  while [ $((_index)) -gt 0 ]; do
    _indexA=$((_maxA-_max+_index));
    _indexB=$((_maxB-_max+_index));
    if    [ $((_indexA)) -eq 0 ] \
       || [ $((_indexB)) -eq 0 ]; then
      _result=$((_max-_index));
      break;
    fi
    _auxA=$(echo "${_pathA}" | awk -F"/" -vindx=${_indexA} '{printf("%s", $indx);}');
    _auxB=$(echo "${_pathB}" | awk -F"/" -vindx=${_indexB} '{printf("%s", $indx);}');
    _index=$((_index-1));
    if [ "${_auxA}" != "${_auxB}" ]; then
      _result=${TRUE};
      break;
    fi
  done

#  if [ $((_result)) -ge 0 ]; then
#    _result=$((_max-_result));
#  else
#    _result=${TRUE};
#  fi

  export RESULT="${_result}";
}

function replaceNLeftmostTokens() {
  local _text="$1";
  local _newToken="$2";
  local _number=$(($3));
  local _separator="$4";
  local _result=$(echo "${_text}" | awk -F"${_separator}" -vd=${_number} -vnewT="${_newToken}" -vseparator="${_separator}" '{for (i=0;i<d&&i<NF;i++) {printf("%s%s", newT, separator);}for (i=d+2;i<=NF;i++){printf("%s%s", $i, separator);}}END{printf("\n");}' | sed "s ${_separator}$  g");
  export RESULT="${_result}";
}

function replaceNRightmostTokens() {
  local _text="$1";
  local _newToken="$2";
  local _number=$(($3));
  local _separator="$4";
  local _result=$(echo "${_text}" | awk -F"${_separator}" -vd=${_number} -vnewT="${_newToken}" -vseparator="${_separator}" '{for (i=NF;i>NF-d&&i>0;i--) {if (newT!="") {printf("%s%s", newT, separator);}}for (i=NF-d;i>0;i--){printf("%s%s", $i, separator);}}END{printf("\n");}' | sed "s ${_separator}$  g");
  export RESULT="${_result}";
}

###
 # Uncompresses given file to a concrete folder.
 # @param 1 the file.
 # @param 2 the output folder.
 # @return 0: No error.
 # @return 1: Invalid file format.
 # @return 2: Error uncompressing file.
##
function uncompress() {
  local _file="${1}";
  local _destination="${2}";
  local _result=${TRUE};

  createTempFile;
  local _errorOutput="${RESULT}";

  local _flags;

  # First, check whether the bundle is compressed bzip2 format.
  if file "${_file}" | cut -d ":" -f 2 | grep bzip2 > /dev/null 2>&1; then
    _flags="xfj";
  # Second try: check whether the bundle is compressed gzip format.
  elif file "${_file}" | cut -d ":" -f 2 | grep gzip /dev/null 2>&1; then
    _flags="xfz";
  # Otherwise, it can also be a standard, uncompressed tar.
  elif file "${_file}" | cut -d ":" -f 2 | grep tar /dev/null 2>&1; then
    _flags="xf";
  else
    _result=1;
  fi

  if [ ${_result} == 0 ]; then
    logInfo -n "Uncompressing ${_file}";
    tar ${_flags} "${_file}" -C "${_destination}" 2>&1 > "${_errorOutput}";
    if [ $? == 0 ]; then
      logInfoResult "Done";
    else
      logInfoResult "Failed";
      logDebugFile "${_errorOutput}";
      _result=2;
    fi
  fi

  return ${_result};
}

function removeExtension() {
  local _file="$1";
  local _result="$(basename ${_file}$)";
  _result="${_result%.*}";

  export RESULT="${_result}";
}

function remoteSshCommand() {
  local _result;
  local _resultCode=${TRUE};
  local _user="$1";
  local _server="$2";
  local _command="$3";

  _result=$(ssh ${_user}@${_server} "${_command}" 2> /dev/null);
  _resultCode=$?;
  if [ ${_resultCode} == 0 ]; then
    export RESULT="${_result}";
  fi

  return ${_resultCode};
}

# Retrieves the disk space available in the filesystem containing
# given folder. Prints the available space in bytes. Returns 0 if
# the space could be calculated.
# - folder: the folder.
function retrieveFreeDiskSpaceUnderFolder() {
  local _result;
  local _resultCode=1;
  local _folder="$1";
  local _aux="${_folder}";

  if [ -d "${_folder}" ]; then
    while [ "x${_aux}" != "x" -a "x${_aux}" != "x/" ] && \
          ! mountpoint -q "${_aux}"; do
      _aux="${_aux%/*}";
    done;

    mountpoint -q "${_aux}";
    _resultCode=$?;

    if [ ${_resultCode} -eq 0 ]; then
      _result="$(df | grep " ${_aux}$" | awk '{print $4;}')";
      _resultCode=$?;
    fi
  fi

  export RESULT="${_result}";

  return ${_resultCode};
}

function remoteSshCommandPipe() {
  local _result;
  local _resultCode=${TRUE};
  local _user="$1";
  local _server="$2";
  local _command="$3";
  shift;
  shift;
  shift;
  local _previousPipe="$@";

#  echo "_previousPipe=${_previousPipe}";
#  echo "_command=${_command}";
  _result=$(${_previousPipe} | while IFS='' read -r line; do echo ${line} | ssh "${_user}@${_server}" "${_command}"; done);
  _resultCode=$?;
  if [ ${_resultCode} == 0 ]; then
    export RESULT="${_result}";
  fi

  return ${_resultCode};
}

# Runs a command supporting logging of command-line and output.
# The output is stored in a single variable. If it's expected to
# be longer use 'runCommandLongOutput' instead.
# Parameters:
# - Command: The command to run.
function runCommand() {
  local _command="$(echo $@ | sed 's_\n_ _g')";
  local _result;
  local _resultCode;

  getLogCategory;
  local _previousLogCategory="${RESULT}";
  setLogCategory "${_previousLogCategory}:($1)";

  logDebug "${_command}";
  _result=$($@ 2>&1);
  _resultCode=$?;

  export RESULT="${_result}";

  setLogCategory "${_previousLogCategory}";
  return ${_resultCode};
}

# TODO: find out why this fails. _result gets modified
# externally in the getLogCategory/setLogCategory/logDebug block
# Runs a command supporting logging of command-line and output,
# even if it's long, since it uses a temporary file to store it.
# Parameters:
# - Command: The command to run.
function runCommandLongOutput() {
  local _command="$(echo $@ | sed 's_\n_ _g')";
  local _result;
  local _resultCode;

  createTempFile;
  _result="${RESULT}";

  getLogCategory;
  local _previousLogCategory="${RESULT}";
  setLogCategory "${_previousLogCategory}*";

  logDebug "${_command}";

  if isDebugEnabled; then
      $@ 2>&1 | tee "${_result}";
      _resultCode=${PIPESTATUS[0]};
  else
    $@ > "${_result}" 2>&1;
    _resultCode=$?;
  fi

  export RESULT="${_result}";

  setLogCategory "${_previousLogCategory}";

  return ${_resultCode};
}

function logDebugFileContents() {
  if isDebugEnabled; then
    [ -f "$1" ] && sed 's ^\s+$  g' "$1" | awk '{printf("logDebug \"%s\"\n", $0);}' | sh
  fi
}

## Retrieves the absolute path of given argument.
## -> 1: The relative path.
## <- RESULT: The absolute path.
function _retrieveAbsolutePath() {
  local _relativePath="${1}";
  export RESULT="$(readlink -f "${_relativePath}")";
}

function _functionPresent() {
  local _function=$1;
  local _script=$2;
  type ${_function} 2> /dev/null | grep -q 'shell function'
  local _rescode=$?;
  if [ ${_rescode} -ne 0 ]; then
    grep " ${_function}()" "${_script}" > /dev/null 2>&1;
    _rescode=$?;
  fi
  if [ ${_rescode} -ne 0 ]; then
    local _oldIFS="${IFS}";
    IFS=$' \t\n';
    for _inc in "./$(basename ${_script} .sh).inc.sh" \
                "${DRY_WIT_SCRIPT_FOLDER}/$(basename ${_script} .sh).inc.sh"; do
      if [ -e "${_inc}" ]; then
        _functionPresent "${_function}" "${_inc}";
        _rescode=$?;
	      if [ ${_rescode} -eq 0 ]; then
          break;
	      fi
      fi
    done
    IFS="${_oldIFS}";
  fi
  return ${_rescode};
}

## Converts given string to upper case.
## -> 1: The string to convert.
## <- RESULT: The converted string.
##
## Example:
##   local _text="abc";
##   toUpper "${_text}";
##   local _upcased="${RESULT}";
function toUpper() {
  local _text="${1}";
  if isEmpty "${_text}"; then
      exitWithErrorCode UNACCEPTABLE_API_CALL "'text' (1) cannot be empty when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi
  local _result=$(echo "${_text}" | awk '{print toupper($0);}');
  export RESULT="${_result}";
}

## PUBLIC
## Normalizes given string: converts non-alphanumeric characters to underscore, and converts it to upper case.
## -> 1: The string to convert.
## <- RESULT: The normalized string.
##
## Example:
##   normalize "a_b.C" # returns "A_B_C";
function normalize() {
  cache _uncachedNormalize $*;
}

## PRIVATE
## See normalize()
function _uncachedNormalize() {
  local _text="${1}";
  if isEmpty "${_text}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'text' (1) cannot be empty when calling ${FUNCNAME[1]}. Review ${FUNCNAME[3]}";
  fi
  local _result=$(echo "${_text}" | tr -c '[[:alnum:]]' '_' | sed 's/_*$//g' | awk '{print toupper($0);}');
  export RESULT="${_result}";
}

## Appends a new error to ERROR_MESSAGES.
## -> 1: The error to add.
##
## Example:
##   appendErrorMessage "item";
function appendErrorMessage() {
  local _error="${1}";

  if declare -p ERROR_MESSAGES > /dev/null 2>&1; then
    upvars -a$((${#ERROR_MESSAGES[@]}+1)) ERROR_MESSAGES "${ERROR_MESSAGES[@]}" "${_error}";
    export ERROR_MESSAGES;
  else
    export -a ERROR_MESSAGES=();
    upvars -a1 ERROR_MESSAGES "${_error}";
  fi
}

## Annotates a new error.
## -> 1: The error name.
## -> 1: The error message.
function addError() {
  local _errorName="${1}";
  local _message="${2}";
  local _normalizedErrorName;
  normalize "${_errorName}";
  _normalizedErrorName="${RESULT}";
  appendErrorMessage "${_normalizedErrorName}";
  upvar "${_normalizedErrorName}" "${_message}";
  export "${_normalizedErrorName}"="${_message}";
}

## Appends a new built-in error to BUILTIN_ERRORS.
## -> 1: The error to add.
##
## Example:
##   appendBuiltInError "error";
function _appendBuiltInError() {
  local _error="${1}";

  if declare -p BUILTIN_ERRORS > /dev/null 2>&1; then
    upvars -a$((${#BUILTIN_ERRORS[@]}+1)) BUILTIN_ERRORS "${BUILTIN_ERRORS[@]}" "${_error}";
    export BUILTIN_ERRORS;
  else
    export -a BUILTIN_ERRORS=();
    upvars -a1 BUILTIN_ERRORS "${_error}";
  fi
}

## Annotates a new built-in error.
## -> 1: The error name.
## -> 1: The error message.
function _addBuiltInError() {
  local _errorName="${1}";
  local _message="${2}";
  toUpper "${_errorName}";
  local _upcasedErrorName="${RESULT}";

  _appendBuiltInError "${_upcasedErrorName}";
  upvar "${_upcasedErrorName}" "${_message}";
  export "${_upcasedErrorName}"="${_message}";
}

## Declares dry-wit's error messages.
function _defineDryWitErrorMessages() {
  _addBuiltInError "SCRIPT_INTERRUPTED" "User interruption";
  _addBuiltInError "MISSING_MANDATORY_VARIABLES" "Script not complete, since it doesn't define all mandatory variables";
  _addBuiltInError "MISSING_MANDATORY_FUNCTIONS" "Script not complete, since it doesn't define all mandatory functions";
  _addBuiltInError "UNKNOWN_ERROR" "The script has finished due to an unexpected error";
  _addBuiltInError "UNACCEPTABLE_API_CALL" "Unacceptable call to dry-wit API: ";
  _addBuiltInError "POSTCONDITION_NOT_SATISFIED" "Postcondition not satisfied: ";
  _addBuiltInError "UNACCEPTABLE_ENVIRONMENT_VARIABLE" "Unacceptable environment variable: ";
}

## Annotates a new error describing a missing dependency.
## -> 1: The missing dependency.
function _addMissingDependencyError() {
  local _dependency="${1}";
  toUpper "${_dependency}_NOT_INSTALLED";
  local _constant="${RESULT}";

  addError "${_constant}" "${_dependency} is not installed";
}

## Checks a required dependency is available.
## -> 1: The program name.
## -> 2: The error code to throw if the dependency is not available. Optional.
function checkDependency() {
  local _req="${1}";
  local _errorCode="${2}";

  if [ -z "${_errorCode}" ]; then
    toUpper "${_req}_NOT_INSTALLED";
    _errorCode="${RESULT}";
  fi

  which ${_req} > /dev/null 2>&1;
  _rescode=$?;
  [ ${_rescode} -ne ${TRUE} ] && exitWithErrorCode ${_errorCode};
}

## Performs the checks for a required dependency.
## -> 1: The dependency.
function checkReq() {
  local _dependency="${1}";
  local _errorCode="${2:-}";

  if [ -z "${_errorCode}" ]; then
    _addMissingDependencyError "${_dependency}";
    checkDependency "${_dependency}";
  else
    checkDependency "${_dependency}" "${_errorCode}";
  fi
}

## Checks dry-wit's own requirements.
function _defineDryWitRequirements() {
  checkReq grep;
  checkReq mktemp;
}

## Parses the common flags. It sets the log level, whether to eval defaults, and
## the help flag.
## -> *: The arguments.
function _parseCommonInput() {

  local _help=${TRUE};
  setInfoEnabled;

  local _flags=$(extractFlags $@);
  local _flagCount=0;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _flag in ${_flags}; do
    _flagCount=$((_flagCount+1));
    case ${_flag} in
      -h | --help)
         _help=1;
         ;;
      -v)
         setDebugEnabled;
         ;;
      -vv)
         setTraceEnabled;
         ;;
      -q)
         setQuietMode;
         ;;
      -X:e | --X:eval-defaults)
          export DRY_WIT_EVAL_DEFAULTS_FLAG=1;
         ;;
    esac
  done
  IFS="${_oldIFS}";
  shift ${_flagCount};

  export DRY_WIT_HELP_FLAG=${_help};
}

## User/Group helpers
## Retrieves the uid of the owner user of given file or folder.
## -> 1: The file or folder.
## <- RESULT: The id of the user that owns the file or folder.
## Example:
##   retrieveOwnerUid /tmp
##   echo "The id of the owner of /tmp is ${RESULT}";
function retrieveOwnerUid() {
  local _file="${1}"
  local _result;

  _result="$(stat -c '%u' "${_file}")";

  export RESULT="${_result}";
}

## Retrieves the id of the owner group of given file or folder.
## -> 1: The file or folder.
## <- RESULT: The id of the group that owns the file or folder.
## Example:
##   retrieveOwnerGid /tmp
##   echo "The id of the group of /tmp is ${RESULT}";
function retrieveOwnerGid() {
  local _file="${1}"
  local _result;

  _result="$(stat -c '%g' "${_file}")";

  export RESULT="${_result}";
}

## Checks whether given uid already exists.
## -> 1: The user id.
## <- 0/${TRUE} if it exists; 1/${FALSE} otherwise.
##
## Example:
##   if uidAlreadyExists 1; then
##     echo "User 1 exists";
##   fi
function uidAlreadyExists() {
  local _uid="${1}";
  local _rescode;

  logDebug -n "Checking if uid ${_uid} is already used";
  getent passwd ${_uid} > /dev/null;
  _rescode=$?;

  if isTrue ${_rescode}; then
    logDebugResult SUCCESS "true";
  else
    logDebugResult FAILURE "false";
  fi

  return ${_rescode};
}

## Checks whether given gid already exists.
## -> 1: The group id.
## <- 0/${TRUE} if it exists; 1/${FALSE} otherwise.
##
## Example:
##   if gidAlreadyExists 103; then
##     echo "Group 103 exists";
##   fi
function gidAlreadyExists() {
  local _gid="${1}";
  local _rescode;

  logDebug -n "Checking if gid ${_gid} already exists";
  getent group ${_gid} > /dev/null;
  _rescode=$?;

  if isTrue ${_rescode}; then
    logDebugResult SUCCESS "true";
  else
    logDebugResult FAILURE "false";
  fi

  return ${_rescode};
}

## Checks whether given user already exists.
## -> 1: The user name.
## <- 0/${TRUE} if it exists; 1/${FALSE} otherwise.
##
## Example:
##   if userAlreadyExists guest; then
##     echo "User guest exists";
##   fi
function userAlreadyExists() {
  local _user="${1}";
  local _rescode;

  logDebug -n "Checking if user ${_user} is already used";
  getent passwd ${_user} > /dev/null;
  _rescode=$?;

  if isTrue ${_rescode}; then
    logDebugResult SUCCESS "true";
  else
    logDebugResult FAILURE "false";
  fi

  return ${_rescode};
}

## Checks whether given group already exists.
## -> 1: The group name.
## <- 0/${TRUE} if it exists; 1/${FALSE} otherwise.
##
## Example:
##   if groupAlreadyExists users; then
##     echo "Group users exists";
##   fi
function groupAlreadyExists() {
  local _group="${1}";
  local _rescode;

  logDebug -n "Checking if group ${_group} already exists";
  getent group ${_group} > /dev/null;
  _rescode=$?;

  if isTrue ${_rescode}; then
    logDebugResult SUCCESS "true";
  else
    logDebugResult FAILURE "false";
  fi

  return ${_rescode};
}

## Retrieves the user id of given user.
## -> 1: The user name.
## <- RESULT: The user id.
##
## Example:
##   retrieveUserFromUid "1";
##   echo "The name of user 1 is ${RESULT}";
function retrieveUserFromUid() {
  local _uid="${1}";
  local _result;
  local _rescode;

  _result=$(getent passwd ${_uid} | cut -d':' -f1);
  _rescode=$?;

  export RESULT="${_result}";

  return ${_rescode};
}

## Retrieves the group id of given group.
## -> 1: The group name.
## <- RESULT: The group id.
##
## Example:
##   retrieveGroupFromGid "100";
##   echo "The name of group 1 is ${RESULT}";
function retrieveGroupFromGid() {
  local _gid="${1}";
  local _result;
  local _rescode;

  _result=$(getent group ${_gid} | cut -d':' -f1);
  _rescode=$?;

  if isTrue ${_rescode}; then
    export RESULT="${_result}";
  fi

  return ${_rescode};
}

## Retrieves the name of the user matching given id.
## -> 1: The user id.
## <- RESULT: The user name.
##
## Example:
##   retrieveUidFromUser "root";
##   echo "The name of user root is ${RESULT}";
function retrieveUidFromUser() {
  local _user="${1}";
  local _result;
  local _rescode;

  logDebug -n "Retrieving uid of user ${_user}";
  _result=$(getent passwd ${_user} | cut -d':' -f3);
  _rescode=$?;
  if isTrue ${_rescode}; then
    logDebugResult SUCCESS "${_result}";
    export RESULT="${_result}";
  else
    logDebugResult FAILURE "failed";
  fi

  return ${_rescode};
}

## Retrieves the name of the group matching given id.
## -> 1: The group id.
## <- RESULT: The group name.
##
## Example:
##   retrieveGidFromGroup "admin";
##   echo "The name of group admin is ${RESULT}";
function retrieveGidFromGroup() {
  local _group="${1}";
  local _result;
  local _rescode;

  logDebug -n "Retrieving gid of group ${_group}";
  _result=$(getent group ${_group} | cut -d':' -f3);
  _rescode=$?;
  if isTrue ${_rescode}; then
    logDebugResult SUCCESS "${_result}";
    export RESULT="${_result}";
  else
    logDebugResult FAILURE "failed";
  fi

  return ${_rescode};
}

## Creates a new user.
## -> 1: The user name.
## <- 0/${TRUE} if the user gets created successfully; 1/${FALSE} otherwise.
##
## Example:
## if createUser "fakeuser"; then
##    echo "fakeuser created successfully";
## fi
function createUser() {
  local _userName="${1}";
  local _rescode;

  logDebug -n "Creating user ${_userName}";

  useradd -M -N -l "${_userName}";
  _rescode=$?;
  if isTrue ${_rescode}; then
    logDebugResult SUCCESS "done";
  else
    logDebugResult FAILURE "failed";
  fi

  return ${_rescode};
}

## Creates a new group.
## -> 1: The group name.
## <- 0/${TRUE} if the group gets created successfully; 1/${FALSE} otherwise.
##
## Example:
## if createGroup "fakegroup"; then
##    echo "fakegroup created successfully";
## fi
function createGroup() {
  local _groupName="${1}";
  local _rescode;

  logDebug -n "Creating group ${_groupName}";

  groupadd "${_groupName}";
  _rescode=$?;
  if isTrue ${_rescode}; then
    logDebugResult SUCCESS "done";
  else
    logDebugResult FAILURE "failed";
  fi

  return ${_rescode};
}

## Deletes given user.
## -> 1: The user name.
## <- 0/${TRUE} if the user is removed successfully; 1/${FALSE} otherwise.
##
## Example:
## if deleteUser "fakeuser"; then
##    echo "fakeuser deleted successfully";
## fi
function deleteUser() {
  local _userName="${1}";
  local _rescode;

  logDebug -n "Deleting user ${_userName}";

  userdel "${_userName}";
  _rescode=$?;
  if isTrue ${_rescode}; then
    logDebugResult SUCCESS "done";
  else
    logDebugResult FAILURE "failed";
  fi

  return ${_rescode};
}

## Deletes given group.
## -> 1: The group name.
## <- 0/${TRUE} if the group is removed successfully; 1/${FALSE} otherwise.
##
## Example:
## if deleteGroup "fakegroup"; then
##    echo "fakegroup deleted successfully";
## fi
function deleteGroup() {
  local _groupName="${1}";
  local _rescode;

  logDebug -n "Deleting group ${_groupName}";

  groupdel "${_groupName}";
  _rescode=$?;
  if isTrue ${_rescode}; then
    logDebugResult SUCCESS "done";
  else
    logDebugResult FAILURE "failed";
  fi

  return ${_rescode};
}

## Runs the command in a folder, under a given user.
## -> 1: The user id.
## -> 2: The group id.
## -> 3: the folder.
## -> 4+: the command.
## Example:
##  runCommandAsUidGid 1000 100 /tmp "ls -ltrhia"
function runCommandAsUidGid() {
  local _user="${1}";
  local _uid="${2}";
  local _gid="${3}";
  local _folder="${4}";
  local _command="${5}";
  shift
  shift
  shift
  shift
  shift
  local _args="${@}";
  local _exports="$(export)";

  createTempFile
  local _runme="${RESULT}";

  cat << EOF > ${_runme}
#!/bin/bash

${_exports}
declare -x HOME="/home/${_user}"
cd ${_folder}
${_command} ${_args}
EOF
  chmod +x ${_runme}

  logDebug "Running ${_command} ${_args} as ${SERVICE_USER}:${SERVICE_GROUP}";
  exec 2>&1
  chpst -u ${SERVICE_USER}:${SERVICE_GROUP} -U ${SERVICE_USER}:${SERVICE_GROUP} ${_runme}
}

## Updates the uid of the user.
## -> 1: The user.
## -> 2: The uid.
## <- 0/${TRUE} if the user's uid is updated successfully; 1/${FALSE} otherwise.
## Example:
## updateUserUid "guest" 1001
function updateUserUid() {
  local _user="${1}";
  local _uid="${2}";
  local _rescode;

  logInfo -n "Changing ${_user}'s uid to ${_uid}";
  usermod -u ${_uid} ${_user} > /dev/null 2>&1
  _rescode=$?;
  if isTrue ${_rescode}; then
    logInfoResult SUCCESS "done";
  else
    logInfoResult FAILURE "failed";
    usermod -u ${_uid} ${_user} 2>&1
  fi

  return ${_rescode};
}

## Updates the gid of the user.
## -> 1: The user.
## -> 2: The gid.
## <- 0/${TRUE} if the user's gid is updated successfully; 1/${FALSE} otherwise.
## Example:
## updateUserGid "guest" 103
function updateUserGid() {
  local _user="${1}";
  local _gid="${2}";
  local _rescode;

  logInfo -n "Changing ${_user}'s primary group as ${_gid}";
  usermod -g ${_gid} ${_user} > /dev/null 2>&1
  _rescode=$?;
  if isTrue ${_rescode}; then
    logInfoResult SUCCESS "done";
  else
    logInfoResult FAILURE "unneeded";
  fi

  return ${_rescode};
}

## Updates the gid of the group.
## -> 1: The group.
## -> 2: The gid.
## <- 0/${TRUE} if the group's gid is updated successfully; 1/${FALSE} otherwise.
##
## Example:
## updateUserGid "guests" 103
function updateGroupGid() {
  local _group="${1}";
  local _gid="${2}";
  local _rescode;

  logInfo -n "Changing ${_group}'s gid to ${_gid}";
  groupmod -g ${_gid} ${_group} > /dev/null 2>&1
  _rescode=$?;
  if isTrue ${_rescode}; then
    logInfoResult SUCCESS "done";
  else
    logInfoResult FAILURE "failed";
    groupmod -g ${_gid} ${_group} 2>&1
  fi

  return ${_rescode};
}

## Adds given user to a group.
## -> 1: The user.
## -> 2: The group.
## <- 0/${TRUE} if the user gets added to the group successfully; 1/${FALSE} otherwise.
##
## Example:
##   if addUserToGroup guest users; then
##     echo "User guest added to group users";
##   fi
function addUserToGroup() {
  local _user="${1}";
  local _group="${2}";
  local _rescode;

  gpasswd -a ${_user} ${_group} > /dev/null;
  _rescode=$?;

  return ${_rescode};
}

## Checks input common to all scripts.
function _checkCommonInput() {

  if [ ${DRY_WIT_HELP_FLAG} == 1 ]; then
    _printHelp;
    exit 0;
  fi
}

## Performs some checks on the script itself.
## -> 1: The script.
function _checkScript() {
  local _script=$1;
  local v;
  local f;

  setLogCategory "sanity-check";
  logTrace -n "Checking mandatory constants";
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for v in ${ERROR_MESSAGES[@]}; do
    if [ -z "${v}" ]; then
      exitWithErrorCode MISSING_MANDATORY_VARIABLES $v;
    fi
  done
  logTraceResult SUCCESS "Done";
  logTrace -n "Checking mandatory functions";
  for f in usage main; do
    _functionPresent $f $_script;
    if [ $? != 0 ]; then
      exitWithErrorCode MISSING_MANDATORY_FUNCTIONS $f;
    fi
  done
  IFS="${_oldIFS}";
  logTraceResult SUCCESS "Done";
}

## PUBLIC
## Sources given file, if it exists.
## -> 1: The file to source.
## <- 0/${TRUE} if the file is sourced; 1/${FALSE} otherwise.
## Example:
##   sourceFileIfExists "/tmp/my-env";
function sourceFileIfExists() {
  local _file="${1}";
  local _rescode=${FALSE};

  if isEmpty "${_file}"; then
    exitWithErrorCode UNACCEPTABLE_API_CALL "'file' (1) cannot be empty when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}";
  fi

  logTrace -n "Reading ${_file}";
  if [ -e "${_file}" ]; then
    _rescode=${TRUE};
    source "${_file}";
    logTraceResult SUCCESS "done";
  else
    logTraceResult SUCCESS "not found";
  fi

  return ${_rescode};
}

function _setup() {
  _trapSignals;
  local _f;
  local _oldIFS="${IFS}";
  IFS=$' \t\n';
  for _f in "${DRY_WIT_SCRIPT_FOLDER}/$(basename ${DRY_WIT_SCRIPT_PATH} .sh).inc.sh" \
            "./.$(basename ${DRY_WIT_SCRIPT_PATH} .sh).inc.sh" \
            "${DRY_WIT_SCRIPT_FOLDER}/.$(basename ${DRY_WIT_SCRIPT_PATH} .sh).inc.sh" \
            "./.$(basename ${DRY_WIT_SCRIPT_PATH} .sh).inc.sh"; do
    sourceFileIfExists "${_f}";
  done
  IFS="${_oldIFS}";

  evalEnvVars;
}

if [ "$1" != "" ]; then
  export SCRIPT_NAME="$(basename $1)";
else
  export SCRIPT_NAME="$0";
fi

function _main() {
  local _script="${1#./}";
  shift;
  local _absolutePath;
  _retrieveAbsolutePath "${_script}";
  export DRY_WIT_SCRIPT_PATH="${RESULT}";
  export DRY_WIT_SCRIPT_FOLDER="$(dirname ${DRY_WIT_SCRIPT_PATH})";

  _defineDryWitErrorMessages;

  _setup "${_script}";

  if _functionPresent defineErrors "${_script}"; then
    defineErrors;
  else
    export ERROR_MESSAGES=();
  fi

  if _functionPresent defineEnvDefaults "${_script}"; then
    defineEnvDefaults;
  fi

  if _functionPresent defineEnv "${_script}"; then
    defineEnv;
  fi

  if _functionPresent defineKeywords "${_script}"; then
    defineKeywords;
  fi

  _parseCommonInput $@;

  if _functionPresent parseInput "${_script}"; then
    evalEnvVars;
    parseInput $@;
  fi

  _checkCommonInput $@;

  _checkScript "${_script}";

  _defineDryWitRequirements;

  if _functionPresent checkRequirements "${_script}"; then
    logTrace -n "Checking declared requirements";
    checkRequirements;
    logTraceResult SUCCESS "Done";
  fi

  if _functionPresent checkInput "${_script}"; then
    evalEnvVars;
    checkInput $@;

    if _functionPresent postCheckInput "${_script}"; then
      postCheckInput $@;
    fi
  fi

  setLogCategory "main";
  main;
}

# Adapted from http://unix.stackexchange.com/questions/38101/does-bash-have-a-built-in-caching-command-available-sort-of-like-mktemp-or-spon
typeset -A result_cache;
typeset -A rescode_cache;

function cache() {
  local IFS='
  ';
  local _key="$*";
  local _rescode;
  local _result;
  local _cachedRescode=${rescode_cache["${_key}"]:--1};

  if [ ${_cachedRescode} -lt 0 ]; then
    ${_key};
    _rescode=$?;
    _result="${RESULT}";
    result_cache["${_key}"]="${_result}";
    _result="${result_cache[${_key}]}";
    rescode_cache["${_key}"]=${_rescode};
  else
    _rescode=${rescode_cache["${_key}"]};
    _result="${result_cache[${_key}]}";
  fi
  export RESULT="${_result}";
  return ${_rescode};
}

function uncache() {
  local IFS='
  ';
  unset result_cache["$*"]
  unset rescode_cahe["$*"]
}

source $@;
_main $@;
cleanup;

#!/usr/bin/env bash
# (c) 2008-today Automated Computing Machinery, S.L.
#
#    This file is part of dry-wit.
#
#    dry-wit is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    dry-wit is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with dry-wit.  If not, see <http://www.gnu.org/licenses/>.
# mod: bootstrap
# api: private
# txt: Bootstrap functions.

# fun: BOOTSTRAP.getModuleName
# api: public
# txt: Retrieves the name of the module.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the module.
# use: BOOTSTRAP.getModuleName;
# use: echo "Module: ${RESULT}";
function BOOTSTRAP.getModuleName() {
  export RESULT="BOOTSTRAP"
  return ${TRUE}
}

# fun: DW.declareGlobalInt module varName value
# api: public
# txt: Declares a global integer variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The name of the variable.
# opt: value: The initial value. Optional.
# txt: Returns 0/TRUE if the variable gets declared; 1/FALSE if it already exists.
# txt: The variable RESULT contains the new or the existing global variable name.
# use: if DW.declareGlobalInt "LOGGING" "ONE_THOUSAND" 1000; then
# use:   echo "ONE_THOUSAND variable name: ${RESULT}";
# use: fi
function DW.declareGlobalInt() {
  local _module="${1}"
  BOOTSTRAP.checkNotEmpty module "${_module}" 1
  local _varName="${2}"
  BOOTSTRAP.checkNotEmpty varName "${_varName}" 2
  local _value="${3}"

  DW.declareGlobalVariable "${_module}" "${_varName}" int "${_value}"
}

# fun: DW.setGlobalInt module varName value
# api: public
# txt: Sets the value of a global integer variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The name of the variable.
# opt: value: The initial value. Optional.
# txt: Returns 0/TRUE if the variable was previously declared; 1/FALSE if it doesn't exist already.
# use: if DW.setGlobalInt "LOGGING" "ONE_THOUSAND" 1000; then
# use:   echo "ONE_THOUSAND variable now is ${RESULT}";
# use: fi
function DW.setGlobalInt() {
  local _module="${1}"
  BOOTSTRAP.checkNotEmpty module "${_module}" 1
  local _varName="${2}"
  BOOTSTRAP.checkNotEmpty varName "${_varName}" 2
  local _value="${3}"

  if DW.getGlobalVariableName "${_module}" "${_varName}"; then
    local -n _variable="${RESULT}"
    _variable="${_value}"
  else
    DW.declareGlobalInt "${_module}" "${_varName}" ${_value}
  fi
}

# fun: DW.getGlobalInt module varName
# api: public
# txt: Retrieves the value of a global integer variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The name of the variable.
# opt: default: The default value if the variable is not defined. Optional.
# txt: Returns 0/TRUE if the variable exists; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the variable value.
# use: if DW.getGlobalInt "LOGGING" "ONE_THOUSAND"; then
# use:   echo "ONE_THOUSAND=${RESULT}";
# use: fi
function DW.getGlobalInt() {
  local _module="${1}"
  BOOTSTRAP.checkNotEmpty module "${_module}" 1
  local _varName="${2}"
  BOOTSTRAP.checkNotEmpty varName "${_varName}" 2
  local _default="${3:-${FALSE}}"

  local -i _rescode=${FALSE}
  local _result=""

  if DW.getGlobalString "${_module}" "${_varName}"; then
    _rescode=${TRUE}
    if BOOTSTRAP.isEmpty "${RESULT}"; then
      _result=${_default}
    else
      _result=${RESULT}
    fi
  fi

  if BOOTSTRAP.isTrue ${_rescode}; then
    export RESULT="${_result}"
  else
    export RESULT=""
  fi

  return ${_rescode}
}

# fun: DW.declareGlobalString module varName value
# api: private
# txt: Declares a global String variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The name of the variable.
# opt: value: The initial value. Optional.
# txt: Returns 0/TRUE if the variable gets declared; 1/FALSE it already exists.
# txt: The variable RESULT contains the new or the existing global variable name.
# use: if DW.declareGlobalString "LOGGING" "MY_STRING" "test"; then
# use:   echo "MY_STRING variable: ${RESULT}";
# use: fi
function DW.declareGlobalString() {
  local _module="${1}"
  BOOTSTRAP.checkNotEmpty module "${_module}" 1
  local _varName="${2}"
  BOOTSTRAP.checkNotEmpty varName "${_varName}" 2
  local _value="${3}"

  DW.declareGlobalVariable "${_module}" "${_varName}" string "${_value}"
}

# fun: DW.setGlobalString module varName value
# api: public
# txt: Sets the value of a global string variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The name of the variable.
# opt: value: The initial value. Optional.
# txt: Returns 0/TRUE if the variable was previously declared; 1/FALSE if it doesn't exist already.
# use: if DW.setGlobalString "LOGGING" "MY_STRING" "text"; then
# use:   echo "MY_STRING variable now is ${RESULT}";
# use: fi
function DW.setGlobalString() {
  local _module="${1}"
  BOOTSTRAP.checkNotEmpty module "${_module}" 1
  local _varName="${2}"
  BOOTSTRAP.checkNotEmpty varName "${_varName}" 2
  local _value="${3}"

  DW.declareGlobalString "${_module}" "${_varName}" "${_value}"
}

# fun: DW.getGlobalString module varName
# api: public
# txt: Retrieves the value of a global String variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The name of the variable.
# txt: Returns 0/TRUE if the variable exists; 1/FALSE otherwise.
# txt: If the function returns 0/TRUE, the variable RESULT contains the variable value.
# use: if DW.getGlobalString "LOGGING" "MY_STRING"; then
# use:   echo "MY_STRING=${RESULT}";
# use: fi
function DW.getGlobalString() {
  local _module="${1}"
  BOOTSTRAP.checkNotEmpty module "${_module}" 1
  local _varName="${2}"
  BOOTSTRAP.checkNotEmpty varName "${_varName}" 2

  local -i _rescode=${FALSE}

  if DW.getGlobalVariableName "${_module}" "${_varName}"; then
    local _variableName=${RESULT}
    local -n _result=${RESULT}
    if [[ "${_variableName}" != "${_result:-}" ]]; then
      _rescode=${TRUE}
    fi
    if BOOTSTRAP.isTrue ${_rescode}; then
      export RESULT="${_result:-}"
    fi
  fi

  if BOOTSTRAP.isFalse ${_rescode}; then
    export RESULT=""
  fi

  return ${_rescode}
}

# fun: DW.declareGlobalArray module varName values*
# api: public
# txt: Declares a global array variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The name of the variable.
# opt: values*: The initial values. Optional.
# txt: Returns 0/TRUE if the variable gets declared; 1/FALSE it already exists.
# txt: The variable RESULT contains the new or the existing global variable name.
# use: if DW.declareGlobalArray "LOGGING" "MY_LIST" "a" "b" "c"; then
# use:   echo "MY_LIST variable: ${RESULT}";
# use: fi
function DW.declareGlobalArray() {
  local _module="${1}"
  BOOTSTRAP.checkNotEmpty module "${_module}" 1
  local _varName="${2}"
  BOOTSTRAP.checkNotEmpty varName "${_varName}" 2
  shift
  shift
  DW.declareGlobalVariable "${_module}" "${_varName}" array ${@}
}

# fun: DW.declareGlobalMap module varName values*
# api: public
# txt: Declares a global associative array variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The name of the variable.
# opt: values: The initial values. Optional.
# txt: Returns 0/TRUE if the variable gets declared; 1/FALSE it already exists.
# txt: The variable RESULT contains the new or the existing global variable name.
# use: if DW.declareGlobalMap "LOGGING" "MY_ASSOCIATIVE_ARRAY"; then
# use:   local -n map=${RESULT};
# use: fi
function DW.declareGlobalMap() {
  local _module="${1}"
  BOOTSTRAP.checkNotEmpty module "${_module}" 1
  local _varName="${2}"
  BOOTSTRAP.checkNotEmpty varName "${_varName}" 2
  shift
  shift
  DW.declareGlobalVariable "${_module}" "${_varName}" map ${@}
}

# fun: DW.declareGlobalVariable module varName varType initialValue
# api: public
# txt: Declares a global variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The name of the variable.
# opt: varType: Either int, array, string or map.
# opt: initialValue: The initial value. Optional.
# txt: Returns 0/TRUE if the variable gets declared; 1/FALSE it already exists.
# txt: The variable RESULT contains the new or the existing global variable name.
# use: if DW.declareGlobalVariable "LOGGING" "MY_LIST" "array"; then
# use:   echo "MY_LIST variable name: ${RESULT}";
# use: fi
function DW.declareGlobalVariable() {
  local _module="${1}"
  BOOTSTRAP.checkNotEmpty module "${_module}" 1
  shift
  local _varName="${1}"
  BOOTSTRAP.checkNotEmpty varName "${_varName}" 2
  shift
  local _varType="${1}"
  BOOTSTRAP.checkNotEmpty varType "${_varType}" 3
  shift
  local _initialValue="${@:-}"

  DW.getGlobalVariableName "${_module}" "${_varName}"
  local -i _rescode=$?
  local _aux="${RESULT}"

  if BOOTSTRAP.isTrue ${_rescode}; then
    unset "${_aux}"
    local -i _initialValueProvided
    if BOOTSTRAP.isEmpty "${_initialValue}"; then
      _initialValueProvided=${FALSE}
    else
      _initialValueProvided=${TRUE}
    fi

    case "${_varType}" in
      int)
        if BOOTSTRAP.isTrue ${_initialValueProvided}; then
          declare -igx "${_aux}"=${_initialValue}
        else
          declare -igx "${_aux}"
        fi
        _rescode=$?
        ;;
      array)
        declare -agx "${_aux}"
        _rescode=$?
        if BOOTSTRAP.isTrue ${_rescode}; then
          local -n _tmp=${_aux}
          if BOOTSTRAP.isTrue ${_initialValueProvided}; then
            _tmp=(${@})
            _rescode=$?
          else
            _tmp=()
            _rescode=$?
          fi
        fi
        ;;
      map)
        declare -Agx "${_aux}"
        _rescode=$?
        ;;
      *)
        declare -gx "${_aux}"="${_initialValue}"
        _rescode=$?
        ;;
    esac
  else
    BOOTSTRAP.logDebug "DW.getGlobalVariableName ${_module} ${_varName} returned 1. Please fill-in a bug report (https://github.com/rydnr/dry-wit)"
  fi

  return ${_rescode}
}

# fun: DW.getGlobalVariableName module varName
# api: public
# txt: Retrieves the name of a global variable. Its name depends on the nesting level.
# opt: module: The name of the module.
# opt: varName: The (logical) name of the variable.
# txt: Returns 0/TRUE if the variable exists; 1/FALSE otherwise.

# txt: If the function returns 0/TRUE, the variable RESULT contains the name of the existing global variable.
# use: if DW.getGlobalVariableName "LOGGING" "MY_LIST"; then
# use:   local -n _var="${RESULT}";
# use: fi
function DW.getGlobalVariableName() {
  local _module="${1}"
  BOOTSTRAP.checkNotEmpty module "${_module}" 1
  local _varName="${2}"
  BOOTSTRAP.checkNotEmpty varName "${_varName}" 2

  local _result="_DW_$$_${_module^^}_${_varName^^}"

  export RESULT="${_result}"

  return ${TRUE}
}

# fun: DW.getScriptName
# api: public
# txt: Retrieves the name of the script.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the name of the script.
# use: DW.getScriptName;
# use: echo "Script name: ${RESULT}";
function DW.getScriptName() {
  BOOTSTRAP.getModuleName
  DW.getGlobalString "${RESULT}" SCRIPT_NAME
}

# fun: BOOTSTRAP.setScriptName name
# api: public
# txt: Annotates the name of the script.
# opt: name: The script name.
# txt: Returns 0/TRUE always.
# use: BOOTSTRAP.setScriptName "myScript";
function BOOTSTRAP.setScriptName() {
  local _name="${1}"
  BOOTSTRAP.checkNotEmpty name "${_name}" 1

  BOOTSTRAP.getModuleName
  local _module="${RESULT}"

  DW.declareGlobalString "${_module}" SCRIPT_NAME "${_name}"
}

# fun: DW.getScriptPath
# api: public
# txt: Retrieves the path of the script.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the path of the script.
# use: DW.getScriptPath;
# use: echo "Script path: ${RESULT}";
function DW.getScriptPath() {
  BOOTSTRAP.getModuleName
  DW.getGlobalString "${RESULT}" SCRIPT_PATH
}

# fun: BOOTSTRAP.setScriptPath path
# api: public
# txt: Annotates the path of the script.
# opt: path: The script path.
# txt: Returns 0/TRUE always.
# use: BOOTSTRAP.setScriptPath "myScript";
function BOOTSTRAP.setScriptPath() {
  local _path="${1}"
  BOOTSTRAP.checkNotEmpty path "${_path}" 1

  BOOTSTRAP.getModuleName
  local _module="${RESULT}"

  DW.declareGlobalString "${_module}" SCRIPT_PATH "${_path}"
}

# fun: DW.getDryWitPath
# api: public
# txt: Retrieves the path of dry-wit.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the path of dry-wit.
# use: DW.getDryWitPath;
# use: echo "dry-wit path: ${RESULT}";
function DW.getDryWitPath() {
  BOOTSTRAP.getModuleName
  DW.getGlobalString "${RESULT}" DRYWIT_PATH
}

# fun: BOOTSTRAP.setDryWitPath path
# api: public
# txt: Annotates the path of dry-wit.
# opt: path: The path.
# txt: Returns 0/TRUE always.
# use: BOOTSTRAP.setDryWitPath "myScript";
function BOOTSTRAP.setDryWitPath() {
  local _path="${1}"
  BOOTSTRAP.checkNotEmpty path "${_path}" 1

  BOOTSTRAP.getModuleName
  local _module="${RESULT}"

  DW.declareGlobalString "${_module}" DRYWIT_PATH "${_path}"
}

# fun: DW.getScriptFolder
# api: public
# txt: Retrieves the folder of the script.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the folder of the script.
# use: DW.getScriptFolder;
# use: echo "Script folder: ${RESULT}";
function DW.getScriptFolder() {
  BOOTSTRAP.getModuleName
  DW.getGlobalString "${RESULT}" SCRIPT_FOLDER
}

# fun: BOOTSTRAP.setScriptFolder folder
# api: public
# txt: Annotates the folder of the script.
# opt: folder: The script folder.
# txt: Returns 0/TRUE always.
# use: BOOTSTRAP.setScriptFolder "myScript";;
function BOOTSTRAP.setScriptFolder() {
  local _folder="${1}"
  BOOTSTRAP.checkNotEmpty folder "${_folder}" 1

  BOOTSTRAP.getModuleName
  local _module="${RESULT}"

  DW.declareGlobalString "${_module}" SCRIPT_FOLDER "${_folder}"
}

# fun: BOOTSTRAP.exitWithError label message
# api: private
# txt: A fail-safe version of exitWithError.
# opt: label: The error label.
# opt: message: The error message.
# use: BOOTSTRAP.exitWithError UNACCEPTABLE_API_CALL "'name' cannot be empty";
function BOOTSTRAP.exitWithError() {
  local _label="${1}"
  local _message="${2}"

  if BOOTSTRAP.isFunctionDefined "exitWithError"; then
    exitWithError "${_label}" "${_message}"
  else
    echo "${_message}"
    exit 1
  fi
}

# fun: BOOTSTRAP.checkNotEmpty name value index
# api: private
# txt: A fail-safe version of checkNotEmpty.
# opt: name: The parameter name.
# opt: value: The parameter value.
# opt: index: The parameter index.
# txt: Exits if the parameter value is empty.
# use: BOOTSTRAP.checkNotEmpty module "${module}" 1
function BOOTSTRAP.checkNotEmpty() {
  local _name="${1}"
  if [ -z "${_name}" ]; then
    BOOTSTRAP.exitWithError UNACCEPTABLE_API_CALL "'name' (1) cannot be empty when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}"
  fi

  local _value="${2}"
  if [ -z "${_value}" ]; then
    BOOTSTRAP.exitWithError UNACCEPTABLE_API_CALL "'${_name}' (${_value}) cannot be empty when calling ${FUNCNAME[1]}. Review ${FUNCNAME[2]}"
  fi

  local _index="${3}"
  if [ -z "${_index}" ]; then
    BOOTSTRAP.exitWithError UNACCEPTABLE_API_CALL "'index' (3) cannot be empty when calling ${FUNCNAME[0]}. Review ${FUNCNAME[1]}"
  fi
}

# fun: BOOTSTRAP.isEmpty value
# api: private
# txt: A fail-safe version of isEmpty.
# opt: value: The parameter value.
# txt: Returns 0/TRUE if the value is empty; 1/FALSE otherwise.
# use: if BOOTSTRAP.isEmpty "${value}"; then
# use:   echo "value is empty";
# use: fi
function BOOTSTRAP.isEmpty() {
  local _value="${1}"
  local -i _rescode

  if [[ -z "${_value}" ]]; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: BOOTSTRAP.isTrue value
# api: private
# txt: A version of isTrue prior to loading check.dw.
# opt: value: The parameter value.
# txt: Returns 0/TRUE if the value is true; 1/FALSE otherwise.
# use: if BOOTSTRAP.isTrue ${value}; then
# use:   echo "...";
# use: fi
function BOOTSTRAP.isTrue() {
  local _value="${1}"
  local -i _rescode

  if [[ "${_value}" == "${TRUE}" ]]; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: BOOTSTRAP.isFalse value
# api: private
# txt: A version of isFalse prior to loading check.dw.
# opt: value: The parameter value.
# txt: Returns 0/TRUE if the value is false; 1/FALSE otherwise.
# use: if BOOTSTRAP.isFalse ${value}; then
# use:   echo "...";
# use: fi
function BOOTSTRAP.isFalse() {
  local _value="${1}"
  local -i _rescode

  if BOOTSTRAP.isTrue "${_value}"; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
  fi

  return ${_rescode}
}

# fun: BOOTSTRAP.isDebugEnabled
# api: private
# txt: Checks if bootstrap debug is enabled.
# txt: Returns 0/TRUE if DEBUG logging is enabled; 1/FALSE otherwise.
# use: if BOOTSTRAP.isDebugEnabled; then
# use:   echo "Debug enabled";
# use: fi
function BOOTSTRAP.isDebugEnabled() {
  local -i _rescode=${FALSE}
  local _oldIFS="${IFS}"

  local _flag
  IFS="${DWIFS}"
  for _flag in "${BASH_ARGV[@]}"; do
    IFS="${_oldIFS}"
    if [ "${_flag}" == "-DW:v" ]; then
      _rescode=${TRUE}
      break
    fi
  done
  IFS="${_oldIFS}"

  return ${_rescode}
}

# fun: BOOTSTRAP.isTraceEnabled
# api: private
# txt: Checks if bootstrap tracing is enabled.
# txt: Returns 0/TRUE if tracing is enabled; 1/FALSE otherwise.
# use: if BOOTSTRAP.isTraceEnabled; then
# use:   echo "Tracing enabled";
# use: fi
function BOOTSTRAP.isTraceEnabled() {
  local -i _rescode=${FALSE}
  local _oldIFS="${IFS}"

  local _flag
  IFS="${DWIFS}"
  for _flag in "${BASH_ARGV[@]}"; do
    IFS="${_oldIFS}"
    if [ "${_flag}" == "-DW:vv" ]; then
      _rescode=${TRUE}
      break
    fi
  done
  IFS="${_oldIFS}"

  return ${_rescode}
}

# fun: BOOTSTRAP.isXtraceEnabled
# api: private
# txt: Checks if extreme tracing is enabled.
# txt: Returns 0/TRUE if tracing is enabled; 1/FALSE otherwise.
# use: if BOOTSTRAP.isXtraceEnabled; then
# use:   echo "Extreme tracing enabled";
# use: fi
function BOOTSTRAP.isXtraceEnabled() {
  local -i _rescode=${FALSE}
  local _oldIFS="${IFS}"

  local _flag
  IFS="${DWIFS}"
  for _flag in "${BASH_ARGV[@]}"; do
    IFS="${_oldIFS}"
    if [ "${_flag}" == "-DW:xv" ]; then
      _rescode=${TRUE}
      break
    fi
  done
  IFS="${_oldIFS}"

  return ${_rescode}
}

# fun: BOOTSTRAP.failsafeIsTraceEnabled
# api: private
# txt: A fail-safe version of isTraceEnabled.
# txt: Returns 0/TRUE if TRACE logging is enabled; 1/FALSE otherwise.
# use: if BOOTSTRAP.failsafeIsTraceEnabled; then ...; fi
function BOOTSTRAP.failsafeIsTraceEnabled() {
  local -i _rescode=${FALSE}
  local _oldIFS="${IFS}"

  if BOOTSTRAP.failsafeIsFunctionDefined "isTraceEnabled"; then
    isTraceEnabled
    _rescode=$?
  else
    IFS="${DWIFS}"
    for _flag in "${BASH_ARGV[@]}"; do
      IFS="${_oldIFS}"
      if [ "${_flag}" == "-vv" ]; then
        _rescode=${TRUE}
        break
      fi
    done
    IFS="${_oldIFS}"
  fi

  return ${_rescode}
}

# fun: BOOTSTRAP.logDebug [-n]? message
# api: private
# txt: A fail-safe version of logDebug.
# opt: -n: Whether to omit a newline. Optional.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: BOOTSTRAP.logDebug "Processing file ${file}";
function BOOTSTRAP.logDebug() {
  local _message="${1}"
  local -i _newline=0
  local -i _position=1

  if [ "${_message}" == "-n" ]; then
    _newline=1
    _message="${2}"
    _position=2
  fi
  BOOTSTRAP.checkNotEmpty message "${_message}" ${_position}

  if BOOTSTRAP.isDebugEnabled; then
    if BOOTSTRAP.isTrue ${_newline}; then
      command echo "[dry-wit:bootstrap] ${_message}"
    else
      command echo -n "[dry-wit:bootstrap] ${_message} ... "
    fi
  fi
}

# fun: BOOTSTRAP.logTrace [-n]? message
# api: private
# txt: A fail-safe version of logTrace.
# opt: -n: Whether to omit a newline. Optional.
# opt: message: The message.
# txt: Returns 0/TRUE always.
# use: BOOTSTRAP.logTrace "Processing file ${file}";
function BOOTSTRAP.logTrace() {
  local _message="${1}"
  local -i _newline=0
  local -i _position=1

  if [ "${_message}" == "-n" ]; then
    _newline=1
    _message="${2}"
    _position=2
  fi
  BOOTSTRAP.checkNotEmpty message "${_message}" ${_position}

  if BOOTSTRAP.isTraceEnabled; then
    if BOOTSTRAP.isTrue ${_newline}; then
      command echo "[dry-wit:bootstrap] ${_message}"
    else
      command echo -n "[dry-wit:bootstrap] ${_message} ... "
    fi
  fi
}

# fun: BOOTSTRAP.logDebugResult outcome message
# api: private
# txt: A fail-safe version of logDebugResult.
# opt: outcome: The outcome.
# opt: message: The message. Optional.
# txt: Returns 0/TRUE always.
# use: BOOTSTRAP.logDebugResult SUCCESS "done";
function BOOTSTRAP.logDebugResult() {
  local _outcome="${1}"
  BOOTSTRAP.checkNotEmpty outcome "${_outcome}" 1
  local _outcomeMessage="${2}"

  if BOOTSTRAP.isEmpty "${_outcomeMessage}"; then
    _outcomeMessage="unset"
  fi

  if BOOTSTRAP.isDebugEnabled; then
    command echo "[${_outcomeMessage}]"
  fi
}

# fun: BOOTSTRAP.logTraceResult outcome message
# api: private
# txt: A fail-safe version of logTraceResult.
# opt: outcome: The outcome.
# opt: message: The message. Optional.
# use: BOOTSTRAP.logTraceResult SUCCESS "done"
function BOOTSTRAP.logTraceResult() {
  local _outcome="${1}"
  BOOTSTRAP.checkNotEmpty outcome "${_outcome}" 1
  local _outcomeMessage="${2}"

  if BOOTSTRAP.isEmpty "${_outcomeMessage}"; then
    _outcomeMessage="unset"
  fi

  if BOOTSTRAP.isTraceEnabled; then
    command echo "[${_outcomeMessage}]"
  fi
}

# fun: BOOTSTRAP.isFunctionDefined name
# api: private
# txt: A fail-safe version of isFunctionDefined.
# opt: name: The function name.
# txt: Returns 0/TRUE if the function is defined; 1/FALSE otherwise.
# use: if BOOTSTRAP.isFunctionDefined "readFile"; then echo "readFile defined"; fi
function BOOTSTRAP.isFunctionDefined() {
  local _function="${1}"
  BOOTSTRAP.checkNotEmpty name "${_function}" 1

  command type "${_function}" 2>/dev/null | command grep -q 'function'
  local -i _rescode=$?

  return ${_rescode}
}

# fun: BOOTSTRAP.arrayContains item array
# api: private
# txt: A fail-safe version of arrayContains.
# opt: array: The array (passed as "${array[@]}".
# opt: element: The element to check.
# txt: Returns 0/TRUE: If the element is present in the array; 1/FALSE otherwise.
# use: a=("one" "two" "three" "other number"); if BOOTSTRAP.arrayContains "${a[@]}" "other number"; then ...; fi
function BOOTSTRAP.arrayContains() {
  local _item="${1}"
  local _array="${2}"
  local -i _rescode=${FALSE}
  local _oldIFS="${IFS}"

  BOOTSTRAP.checkNotEmpty item "${_item}" 1

  local _aux
  IFS="${DWIFS}"
  for _aux in ${_array}; do
    IFS="${_oldIFS}"
    if [[ "${_aux}" == "${_item}" ]]; then
      _rescode=${TRUE}
      break
    fi
  done
  IFS="${_oldIFS}"

  return ${_rescode}
}

# fun: BOOTSTRAP.toUpper text
# api: public
# txt: Converts given string to upper case.
# opt: text: The string to convert.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the string in upper case.
# use: local _text="abc"; toUpper "${_text}"; local _upcased="${RESULT}";
function BOOTSTRAP.toUpper() {
  local _text="${1}"
  BOOTSTRAP.checkNotEmpty text "${_text}" 1

  local _result=$(echo "${_text}" | awk '{print toupper($0);}')
  export RESULT="${_result}"
}

# fun: BOOTSTRAP.toLower text
# api: public
# txt: Converts given string to lower case.
# opt: text: The string to convert.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the string in lower case.
# use: local _text="abc"; toLower "${_text}"; local _lowcased="${RESULT}";
function BOOTSTRAP.toLower() {
  local _text="${1}"
  BOOTSTRAP.checkNotEmpty text "${_text}" 1

  local _result=$(echo "${_text}" | awk '{print tolower($0);}')
  export RESULT="${_result}"
}

# fun: BOOTSTRAP.normalize text
# api: public
# txt: Converts given string to upper case and replaces non-alphanumeric characters with underscores.
# opt: text: The string to convert.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the normalized string.
# use: local _text="abc&oeu"; normalize "${_text}"; local _normalized="${RESULT}";
function BOOTSTRAP.normalize() {
  local _text="${1}"
  BOOTSTRAP.checkNotEmpty text "${_text}" 1

  local _result=$(echo "${_text}" | tr -c '[[:alnum:]]' '_' | sed 's/_*$//g')
  BOOTSTRAP.toUpper "${_result}"
}

# fun: downloadModule module
# api: public
# txt: Downloads given module.
# opt: module: The module name.
# txt: Returns 0/TRUE if the module is downloaded; 1/FALSE otherwise.
# use: if downloadModule "fibonacci"; then
# use:   echo "fibonacci module downloaded";
# use: fi
function downloadModule() {
  local _module="${1}"
  BOOTSTRAP.checkNotEmpty module "${_module}" 1
  local -i _rescode
  local _result=""

  getModulePath
  local _modulePath="${RESULT}"
  mkdir -p "${_modulePath}"

  BOOTSTRAP.getModuleUrl
  local _moduleUrl="${RESULT}"

  BOOTSTRAP.logDebug -n "Downloading ${_moduleUrl}/${_module}.dw to ${_moduleUrl}/${_module}.dw"
  curl -s "${_moduleUrl}/${_module}.dw" >"${_modulePath}/${_module}.dw"
  _rescode=$?
  if BOOTSTRAP.isTrue ${_rescode}; then
    export RESULT="${_modulePath}/${_module}.dw"
  else
    rm -f "${_modulePath}/${_module}.dw"
    curl -s "${_moduleUrl}/ext/${_module}.dw" >"${_modulePath}/ext/${_module}.dw"
    _rescode=$?

    if BOOTSTRAP.isTrue ${_rescode}; then
      BOOTSTRAP.logDebugResult SUCCESS "done"
      export RESULT="${_modulePath}/ext/${_module}.dw"
    else
      rm -f "${_modulePath}/ext/${_module}.dw"
      BOOTSTRAP.logDebugResult FAILURE "failed"
    fi
  fi

  return ${_rescode}
}

# fun: BOOTSTRAP.getBootstrapModulesVariableName
# api: private
# txt: Retrieves the name of the variable containing the bootstrap modules.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the name of the variable with the bootstrap modules.
# use: BOOTSTRAP.getBootstrapModulesVariableName; local -n bootstrapModules=${RESULT};
function BOOTSTRAP.getBootstrapModulesVariableName() {
  BOOTSTRAP.getModuleName
  local _moduleName="${RESULT}"
  DW.getGlobalVariableName "${_moduleName}" BOOTSTRAP_MODULES
}

# fun: BOOTSTRAP.getEssentialModulesVariableName
# api: private
# txt: Retrieves the name of the variable containing the essential modules.
# txt: Returns 0/TRUE always.
# txt: The RESULT variable contains the name of the variable with the essential modules.
# use: BOOTSTRAP.getEssentialModulesVariableName; local -n essentialModules=${RESULT};
function BOOTSTRAP.getEssentialModulesVariableName() {
  BOOTSTRAP.getModuleName
  local _moduleName="${RESULT}"
  DW.getGlobalVariableName "${_moduleName}" ESSENTIAL_MODULES
}

# fun: BOOTSTRAP.bootstrap
# txt: Bootstraps dry-wit.
# txt: Returns always 0/TRUE.
# use: BOOTSTRAP.bootstrap;
function BOOTSTRAP.bootstrap() {
  local _modulePath
  local _oldIFS="${IFS}"

  local _module
  IFS=${DWIFS}
  for _module in "${_DW_BOOTSTRAP_ESSENTIAL_MODULES[@]}"; do
    IFS="${_oldIFS}"
    DW.import "${_module}"
  done
  IFS="${_oldIFS}"

  IFS=${DWIFS}
  for _module in "${_DW_BOOTSTRAP_EXTRA_MODULES[@]}"; do
    IFS="${_oldIFS}"
    DW.import "${_module}"
  done
  IFS="${_oldIFS}"
}

# fun: DW.import module
# api: public
# txt: Imports given module.
# opt: module: The module to import.
# txt: Returns 0/TRUE always. If the module cannot be imported, exits.
# use: DW.import logging;
function DW.import() {
  local _module="${1}"
  BOOTSTRAP.checkNotEmpty module "${_module}" 1

  BOOTSTRAP.getImportedModulesVariableName
  local _importedModulesVariableName="${RESULT}"
  local -n _importedModules=${_importedModulesVariableName}

  if BOOTSTRAP.isEmpty "${_importedModules[*]}" ||
    ! BOOTSTRAP.arrayContains "${_module}" "${_importedModules[*]}"; then

    local _modulePath

    if findModule "${_module}"; then
      _modulePath="${RESULT}"
    elif BOOTSTRAP.isOnlineMode && downloadModule "${_module}"; then
      _modulePath="${RESULT}"
    else
      echo "ERROR: Required module ${_module}.dw not found. Is it correctly spelled?"
      exit 1
    fi

    BOOTSTRAP.logTrace -n "Loading ${_modulePath}"
    source "${_modulePath}"
    BOOTSTRAP.logTraceResult SUCCESS "done"

    BOOTSTRAP.normalize "${_module}"
    local _normalizedModule="${RESULT^^}"

    if BOOTSTRAP.isFunctionDefined "${_normalizedModule}.resetState"; then
      BOOTSTRAP.logTrace -n "Resetting ${_modulePath} state"
      ${_normalizedModule}.resetState
      BOOTSTRAP.logTraceResult SUCCESS "done"
    fi
    if BOOTSTRAP.isFunctionDefined "${_normalizedModule}.defaultState"; then
      BOOTSTRAP.logTrace -n "Restoring ${_modulePath} default state"
      ${_normalizedModule}.defaultState
      BOOTSTRAP.logTraceResult SUCCESS "done"
    fi

    _importedModules[${#_importedModules[@]}]="${_module}"
  else
    BOOTSTRAP.logTrace "Skipping ${_module} since it's already imported"
  fi
}

# fun: BOOTSTRAP.getImportedModulesVariableName
# api: private
# txt: Retrieves the name of the variable containing the imported modules.
# txt: Returns 0/TRUE always.
# use: BOOTSTRAP.getImportedModulesVariableName;
# use: local -n importedModules=${RESULT};
function BOOTSTRAP.getImportedModulesVariableName() {
  BOOTSTRAP.getModuleName
  DW.getGlobalVariableName "${RESULT}" IMPORTED_MODULES
}

# fun: findModule module
# api: public
# txt: Finds given module locally.
# opt: module: The name of the module.
# txt: Returns 0/TRUE if the module is found; 1/FALSE otherwise.
# use: if findModule "fibonacci"; then
# use:   DW.import fibonacci;
# use: fi
function findModule() {
  local _module="${1}"
  BOOTSTRAP.checkNotEmpty module "${_module}" 1

  local _result
  local -i _rescode=${FALSE}

  getModulePath
  local _modulePath="${RESULT}"

  DW.getScriptPath
  local _scriptPath="${RESULT}"

  local _localPath="${BASH_SOURCE[0]}"

  local _dryWitPath="${HOME}/.dry-wit"

  local _scriptFolder
  _scriptFolder=$(command dirname "${_scriptPath}")
  local _oldIFS="${IFS}"

  IFS="${DWIFS}"
  for _result in "${_dryWitPath}/src/modules/${_module}.dw" \
    "${_dryWitPath}/src/modules/ext/${_module}.dw" \
    "${_modulePath}/${_module}.dw" \
    "${_modulePath}/ext/${_module}.dw" \
    "${_modulePath}/.${_module}/${_module}.dw" \
    "${_modulePath}/.${_module}/.dw/${_module}.dw" \
    "${_scriptFolder}/${_module}.dw" \
    "${_scriptFolder}/.dw/${_module}.dw" \
    "${_scriptFolder}/.${_module}/${_module}.dw" \
    "${_scriptFolder}/.${_module}/.dw/${_module}.dw" \
    "${_localPath}/${_module}.dw" \
    "${_localPath}/.dw/${_module}.dw" \
    "${_localPath}/${_module}/${_module}.dw" \
    "${_localPath}/${_module}/.dw/${_module}.dw"; do
    IFS="${_oldIFS}"
    BOOTSTRAP.logTrace -n "Checking if ${_result} exists"
    if [[ -e "${_result}" ]]; then
      _rescode=${TRUE}
      BOOTSTRAP.logTraceResult SUCCESS "true"
      break
    else
      BOOTSTRAP.logTraceResult FAILURE "false"
    fi
  done
  IFS="${_oldIFS}"

  if BOOTSTRAP.isTrue ${_rescode}; then
    export RESULT="${_result}"
  fi

  return ${_rescode}
}

# fun: BOOTSTRAP.endsWith text substring
# api: private
# txt: Checks whether the first parameter ends with the second value.
# opt: text: The text.
# opt: substring: The substring to check.
# txt: Returns 0/TRUE if the text ends with the substring; 1/FALSE otherwise.
# use: if BOOTSTRAP.endsWith "${text}" "c"; then
# use:   echo "${text} ends with c";
# use: fi
function BOOTSTRAP.endsWith() {
  local _container="${1}"
  BOOTSTRAP.checkNotEmpty text "${_container}" 1
  local _substring="${2}"
  BOOTSTRAP.checkNotEmpty substring "${_substring}" 2

  local -i _rescode

  if [[ "${_container%${_substring}}" == "${_container}" ]]; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
  fi

  return ${_rescode}
}

# fun: DW.initialized
# api: private
# txt: Checks whether the initialization has already been done.
# txt: Returns 0/TRUE if the initialization was done; 1/FALSE otherwise.
# use: if DW.initialized; then
# use:   echo "Initialized already";
# use: fi
function DW.initialized() {
  local -i _rescode

  if [ -z ${DW_INITIALIZED+x} ]; then
    _rescode=${FALSE}
  else
    _rescode=${TRUE}
  fi

  return ${_rescode}

}

# fun: BOOTSTRAP.setNested flag
# api: private
# txt: Checks whether this script is running within another dry-wit script.
# opt: flag: The nested flag.
# txt: Returns 0/TRUE always.
# use: BOOTSTRAP.setNested ${FALSE};
function BOOTSTRAP.setNested() {
  local _flag="${1}"
  BOOTSTRAP.checkNotEmpty flag "${_flag}" 1

  BOOTSTRAP.getModuleName
  local _moduleName="${RESULT}"
  DW.declareGlobalString "${_moduleName}" NESTED "${_flag}"
}

# fun: BOOTSTRAP.isNested
# api: private
# txt: Checks whether this script is running within another dry-wit script.
# txt: Returns 0/TRUE if this script is nested within another dry-wit; 1/FALSE otherwise.
# use: if BOOTSTRAP.isNested; then
# use:   echo "Nesting detected";
# use: fi
function BOOTSTRAP.isNested() {
  local -i _rescode

  BOOTSTRAP.getModuleName
  local _moduleName="${RESULT}"
  DW.getGlobalString "${_moduleName}" NESTED

  if BOOTSTRAP.isTrue "${RESULT}"; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# fun: DW.initScriptName scriptArgs*
# api: private
# txt: Initializes the script name stuff.
# opt: scriptArgs: The script arguments.
# txt: Returns 0/TRUE always.
# use: DW.initScriptName $*;
function DW.initScriptName() {
  local _scriptName
  local _scriptPath
  local _scriptFolder
  if [ "$1" == "" ]; then
    _scriptName="$(basename "${0}" 2>&1)"
    _scriptPath="${0}"
    _scriptFolder="$(dirname "${0}" 2>&1)"
  else
    _scriptName="$(basename "${1}" 2>&1)"
    _scriptPath="${1}"
    _scriptFolder="$(dirname "${1}" 2>&1)"
    shift
  fi
  if [ "${_scriptFolder}" == "." ]; then
    _scriptFolder="${PWD}"
  fi

  BOOTSTRAP.setScriptName "${_scriptName}"
  BOOTSTRAP.setScriptPath "${_scriptPath}"
  BOOTSTRAP.setScriptFolder "${_scriptFolder}"
}

# fun: DW.init
# api: private
# txt: Initializes dry-wit.
# use: DW.init
function DW.init() {

  DW.initScriptName "$@"

  declare -igx DW_INITIALIZED=${TRUE}
}

function DW.ifTestRunDryWitTest() {
  DW.getScriptName
  local _scriptName="${RESULT}"

  if [[ -n ${_scriptName} ]]; then
    if BOOTSTRAP.endsWith "${_scriptName}" "-tests.sh" ||
      BOOTSTRAP.endsWith "${_scriptName}" "-test.sh"; then
      source $(command which dry-wit-test) "${_scriptName}" "$@"
    fi
  fi
}

# fun: BOOTSTRAP.getModuleTag
# api: private
# txt: Retrieves the module tag.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the module tag.
# use: BOOTSTRAP.getModuleTag;
# use: echo "module tag: ${RESULT}";
function BOOTSTRAP.getModuleTag() {
  BOOTSTRAP.getModuleName
  local _moduleName
  _moduleName="${RESULT}"
  DW.getGlobalString "${_moduleName}" MODULE_TAG
}

# fun: BOOTSTRAP.setModuleTag tag
# api: private
# txt: Specifies the module tag.
# opt: tag: The module tag.
# txt: Returns 0/TRUE always.
# use: BOOTSTRAP.setModuleTag "${HOME}/.dry-wit/src/modules";
function BOOTSTRAP.setModuleTag() {
  local _tag="${1}"

  BOOTSTRAP.getModuleName
  DW.declareGlobalString "${RESULT}" MODULE_TAG "${_tag}"
}

# fun: BOOTSTRAP.getModuleUrl
# api: private
# txt: Retrieves the url of the modules.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the module url.
# use: BOOTSTRAP.getModuleUrl;
# use: echo "module url: ${RESULT}";
function BOOTSTRAP.getModuleUrl() {
  BOOTSTRAP.getModuleName
  local _moduleName="${RESULT}"
  DW.getGlobalString "${_moduleName}" MODULE_URL
}

# fun: BOOTSTRAP.setModuleUrl url
# api: private
# txt: Specifies the module url.
# opt: url: The module url.
# txt: Returns 0/TRUE always.
# use: BOOTSTRAP.setModuleUrl "https://raw.githubusercontent.com/rydnr/dry-wit/master/src/modules";
function BOOTSTRAP.setModuleUrl() {
  local _url="${1}"

  BOOTSTRAP.getModuleName
  DW.declareGlobalString "${RESULT}" MODULE_URL "${_url}"
}

# fun: getModulePath
# api: public
# txt: Retrieves the module path.
# txt: Returns 0/TRUE always.
# txt: The variable RESULT contains the module path.
# use: getModulePath;
# use: echo "module path: ${RESULT}";
function getModulePath() {
  BOOTSTRAP.getModuleName
  DW.getGlobalString "${RESULT}" MODULE_PATH
}

# fun: BOOTSTRAP.setModulePath path
# api: private
# txt: Specifies the module path.
# opt: path: The module path.
# txt: Returns 0/TRUE always.
# use: BOOTSTRAP.setModulePath "${HOME}/.dry-wit/src/modules";
function BOOTSTRAP.setModulePath() {
  local _path="${1}"
  BOOTSTRAP.checkNotEmpty path "${_path}" 1

  BOOTSTRAP.getModuleName
  DW.declareGlobalString "${RESULT}" MODULE_PATH "${_path}"
}

# fun: BOOTSTRAP.setOnlineMode mode
# api: private
# txt: Specifies whether to attempt to download missing modules from the Internet.
# opt: mode: The flag.
# txt: Returns 0/TRUE always.
# use: BOOTSTRAP.setOnlineMode ${FALSE};
function BOOTSTRAP.setOnlineMode() {
  local _mode="${1}"
  BOOTSTRAP.checkNotEmpty mode "${_mode}" 1

  BOOTSTRAP.getModuleName
  DW.declareGlobalString "${RESULT}" ONLINE_MODE "${_mode}"
}

# fun: BOOTSTRAP.isOnlineMode
# api: private
# txt: Retrieves whether attempting to download missing modules from the Internet is enabled.
# txt: Returns 0/TRUE if online mode is enabled; 1/FALSE otherwise.
# use: if BOOTSTRAP.isOnlineMode; then
# use:   echo "Online mode enabled";
# use: fi
function BOOTSTRAP.isOnlineMode() {
  local -i _rescode

  BOOTSTRAP.getModuleName
  local _moduleName="${RESULT}"

  DW.getGlobalString "${_moduleName}" ONLINE_MODE

  if BOOTSTRAP.isTrue "${RESULT}"; then
    _rescode=${TRUE}
  else
    _rescode=${FALSE}
  fi

  return ${_rescode}
}

# env: TRUE: A synomim for 0.
declare -igx TRUE=0

# env: FALSE: A synomim for 1.
declare -igx FALSE=1

# env: DWIFS: The IFS used by dry-wit.
declare -gx DWIFS=$' \t\n'

# fun: BOOTSTRAP.declareModules
# api: private
# txt: Declares the essential and extra modules.
# txt: Returns 0/TRUE always.
# use: BOOTSTRAP.declareModules;
function BOOTSTRAP.declareModules() {
  # env: _DW_BOOTSTRAP_ESSENTIAL_MODULES: The modules included in the bootstrap process.
  declare -agx _DW_BOOTSTRAP_ESSENTIAL_MODULES

  _DW_BOOTSTRAP_ESSENTIAL_MODULES[${#_DW_BOOTSTRAP_ESSENTIAL_MODULES[@]}]=bash-options
  _DW_BOOTSTRAP_ESSENTIAL_MODULES[${#_DW_BOOTSTRAP_ESSENTIAL_MODULES[@]}]=trap
  _DW_BOOTSTRAP_ESSENTIAL_MODULES[${#_DW_BOOTSTRAP_ESSENTIAL_MODULES[@]}]=check
  _DW_BOOTSTRAP_ESSENTIAL_MODULES[${#_DW_BOOTSTRAP_ESSENTIAL_MODULES[@]}]=stdlib
  _DW_BOOTSTRAP_ESSENTIAL_MODULES[${#_DW_BOOTSTRAP_ESSENTIAL_MODULES[@]}]=number
  _DW_BOOTSTRAP_ESSENTIAL_MODULES[${#_DW_BOOTSTRAP_ESSENTIAL_MODULES[@]}]=string
  _DW_BOOTSTRAP_ESSENTIAL_MODULES[${#_DW_BOOTSTRAP_ESSENTIAL_MODULES[@]}]=array
  _DW_BOOTSTRAP_ESSENTIAL_MODULES[${#_DW_BOOTSTRAP_ESSENTIAL_MODULES[@]}]=envvar

  # env: _DW_BOOTSTRAP_EXTRA_MODULES: The modules included in the bootstrap process.
  declare -agx _DW_BOOTSTRAP_EXTRA_MODULES
  _DW_BOOTSTRAP_EXTRA_MODULES[${#_DW_BOOTSTRAP_EXTRA_MODULES[@]}]=constant
  _DW_BOOTSTRAP_EXTRA_MODULES[${#_DW_BOOTSTRAP_EXTRA_MODULES[@]}]=color
  _DW_BOOTSTRAP_EXTRA_MODULES[${#_DW_BOOTSTRAP_EXTRA_MODULES[@]}]=debug
  _DW_BOOTSTRAP_EXTRA_MODULES[${#_DW_BOOTSTRAP_EXTRA_MODULES[@]}]=echo
  _DW_BOOTSTRAP_EXTRA_MODULES[${#_DW_BOOTSTRAP_EXTRA_MODULES[@]}]=logging
  _DW_BOOTSTRAP_EXTRA_MODULES[${#_DW_BOOTSTRAP_EXTRA_MODULES[@]}]=error
  _DW_BOOTSTRAP_EXTRA_MODULES[${#_DW_BOOTSTRAP_EXTRA_MODULES[@]}]=file
  _DW_BOOTSTRAP_EXTRA_MODULES[${#_DW_BOOTSTRAP_EXTRA_MODULES[@]}]=dw-plumbing
  _DW_BOOTSTRAP_EXTRA_MODULES[${#_DW_BOOTSTRAP_EXTRA_MODULES[@]}]=term
  _DW_BOOTSTRAP_EXTRA_MODULES[${#_DW_BOOTSTRAP_EXTRA_MODULES[@]}]=cli
  _DW_BOOTSTRAP_EXTRA_MODULES[${#_DW_BOOTSTRAP_EXTRA_MODULES[@]}]=package
}

# fun: BOOTSTRAP.resetState
# api: private
# txt: Resets the module state.
# txt: Returns 0/TRUE always.
# use: BOOTSTRAP.resetState
function BOOTSTRAP.resetState() {
  BOOTSTRAP.getModuleName
  local _moduleName="${RESULT}"

  # env: IMPORTED_MODULES: The modules eventually imported in the bootstrap process.
  DW.declareGlobalArray "${_moduleName}" IMPORTED_MODULES

  local _moduleTag="master"

  # env: MODULE_TAG: The dry-wit git tag used to download modules from github.
  BOOTSTRAP.setModuleTag "${_moduleTag}"

  # env: MODULE_URL: The url to download dry-wit modules.
  BOOTSTRAP.setModuleUrl "https://raw.githubusercontent.com/rydnr/dry-wit/${_moduleTag}/src/modules"

  # env: MODULE_PATH: Where to download dry-wit modules.
  BOOTSTRAP.setModulePath "${HOME:-/root}/.dry-wit/src/modules"

  # env: ONLINE_MODE: Whether to attempt downloading missing modules from the Internet.
  BOOTSTRAP.setOnlineMode ${FALSE}
}

BOOTSTRAP.declareModules

#set -o errexit;  # terminate on any unhandled error
#set -o nounset;  # terminate on any unset variable
#set -o pipefail; # In a pipe, the exit status of the last command that threw a non-zero exit code is returned.

if BOOTSTRAP.isXtraceEnabled; then
  set -o xtrace # trace what gets executed
fi

if [ ! -z ${SKIP_LOADING_DRY_WIT+x} ]; then
  exit 0
fi

if DW.initialized; then
  BOOTSTRAP.setNested ${TRUE}
else
  BOOTSTRAP.setNested ${FALSE}
fi

DW.init "$@"

BOOTSTRAP.resetState

BOOTSTRAP.bootstrap

BOOTSTRAP.setDryWitPath "${BASH_SOURCE[0]}"

DW.ifTestRunDryWitTest

DRYWIT.main "$@"
__dw__rescode=$?

if BOOTSTRAP.isNested; then
  cleanup
fi

exit ${__dw__rescode}
# vim: syntax=sh ts=2 sw=2 sts=4 sr noet
